// Autogenerated file, do not hand-edit!
use crate::parse::{Id, IResult, Parse, ParseInner};
use nom::{
    branch::{alt},
    bytes::complete::{tag},
    character::complete::{char},
    combinator::{map},
    multi::{many0},
    sequence::{delimited},
};
pub struct AbsFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AbsFunction<'a> = Id<AbsFunction_<'a>>;
pub struct AcosFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AcosFunction<'a> = Id<AcosFunction_<'a>>;
pub struct Action_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Action<'a> = Id<Action_<'a>>;
pub struct ActionAssignment_<'a> { // entity
    pub assigned_action: Action<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionAssignment<'a> = Id<ActionAssignment_<'a>>;
pub struct ActionDirective_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub analysis: Text<'a>,
    pub comment: Text<'a>,
    pub requests: Vec<VersionedActionRequest<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionDirective<'a> = Id<ActionDirective_<'a>>;
pub enum ActionItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    ActionRequestSolution(ActionRequestSolution<'a>),
    AlternateProductRelationship(AlternateProductRelationship<'a>),
    AppliedActionAssignment(AppliedActionAssignment<'a>),
    AppliedClassificationAssignment(AppliedClassificationAssignment<'a>),
    AppliedPersonAndOrganizationAssignment(AppliedPersonAndOrganizationAssignment<'a>),
    ApprovalStatus(ApprovalStatus<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    Certification(Certification<'a>),
    Class(Class<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationEffectivity(ConfigurationEffectivity<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment<'a>),
    Contract(Contract<'a>),
    DocumentFile(DocumentFile<'a>),
    DraughtingModel(DraughtingModel<'a>),
    DrawingRevision(DrawingRevision<'a>),
    ExecutedAction(ExecutedAction<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    OrganizationRelationship(OrganizationRelationship<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PersonAndOrganization(PersonAndOrganization<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    RequirementForActionResource(RequirementForActionResource<'a>),
    ResourceProperty(ResourceProperty<'a>),
    SecurityClassification(SecurityClassification<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel<'a>),
    ShapeAspect(ShapeAspect<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ActionItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| ActionItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| ActionItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| ActionItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| ActionItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| ActionItem::ActionRelationship(r)),
            map(<ActionRequestSolution<'a>>::parse, |r| ActionItem::ActionRequestSolution(r)),
            map(<AlternateProductRelationship<'a>>::parse, |r| ActionItem::AlternateProductRelationship(r)),
            map(<AppliedActionAssignment<'a>>::parse, |r| ActionItem::AppliedActionAssignment(r)),
            map(<AppliedClassificationAssignment<'a>>::parse, |r| ActionItem::AppliedClassificationAssignment(r)),
            map(<AppliedPersonAndOrganizationAssignment<'a>>::parse, |r| ActionItem::AppliedPersonAndOrganizationAssignment(r)),
            map(<ApprovalStatus<'a>>::parse, |r| ActionItem::ApprovalStatus(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| ActionItem::AssemblyComponentUsageSubstitute(r)),
            map(<Certification<'a>>::parse, |r| ActionItem::Certification(r)),
            map(<Class<'a>>::parse, |r| ActionItem::Class(r)),
            map(<ClassSystem<'a>>::parse, |r| ActionItem::ClassSystem(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| ActionItem::ConfigurationDesign(r)),
            map(<ConfigurationEffectivity<'a>>::parse, |r| ActionItem::ConfigurationEffectivity(r)),
            map(<ConfigurationItem<'a>>::parse, |r| ActionItem::ConfigurationItem(r)),
            map(<ConfiguredEffectivityAssignment<'a>>::parse, |r| ActionItem::ConfiguredEffectivityAssignment(r)),
        alt((
            map(<Contract<'a>>::parse, |r| ActionItem::Contract(r)),
            map(<DocumentFile<'a>>::parse, |r| ActionItem::DocumentFile(r)),
            map(<DraughtingModel<'a>>::parse, |r| ActionItem::DraughtingModel(r)),
            map(<DrawingRevision<'a>>::parse, |r| ActionItem::DrawingRevision(r)),
            map(<ExecutedAction<'a>>::parse, |r| ActionItem::ExecutedAction(r)),
            map(<GeneralProperty<'a>>::parse, |r| ActionItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| ActionItem::MaterialDesignation(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| ActionItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<OrganizationRelationship<'a>>::parse, |r| ActionItem::OrganizationRelationship(r)),
            map(<OrganizationalProject<'a>>::parse, |r| ActionItem::OrganizationalProject(r)),
            map(<PersonAndOrganization<'a>>::parse, |r| ActionItem::PersonAndOrganization(r)),
            map(<PresentationArea<'a>>::parse, |r| ActionItem::PresentationArea(r)),
            map(<Product<'a>>::parse, |r| ActionItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| ActionItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| ActionItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| ActionItem::ProductConceptFeatureAssociation(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| ActionItem::ProductConceptFeatureCategory(r)),
            map(<ProductConceptFeatureCategoryUsage<'a>>::parse, |r| ActionItem::ProductConceptFeatureCategoryUsage(r)),
            map(<ProductDefinition<'a>>::parse, |r| ActionItem::ProductDefinition(r)),
        alt((
            map(<ProductDefinitionFormation<'a>>::parse, |r| ActionItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| ActionItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| ActionItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| ActionItem::ProductDefinitionSubstitute(r)),
            map(<PropertyDefinition<'a>>::parse, |r| ActionItem::PropertyDefinition(r)),
            map(<RequirementForActionResource<'a>>::parse, |r| ActionItem::RequirementForActionResource(r)),
            map(<ResourceProperty<'a>>::parse, |r| ActionItem::ResourceProperty(r)),
            map(<SecurityClassification<'a>>::parse, |r| ActionItem::SecurityClassification(r)),
            map(<SecurityClassificationLevel<'a>>::parse, |r| ActionItem::SecurityClassificationLevel(r)),
            map(<ShapeAspect<'a>>::parse, |r| ActionItem::ShapeAspect(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| ActionItem::ShapeRepresentation(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| ActionItem::VersionedActionRequest(r)),
        ))))))(s)
    }
}
pub struct ActionMethod_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub consequence: Text<'a>,
    pub purpose: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionMethod<'a> = Id<ActionMethod_<'a>>;
pub struct ActionMethodRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_method: ActionMethod<'a>,
    pub related_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionMethodRelationship<'a> = Id<ActionMethodRelationship_<'a>>;
pub struct ActionProperty_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub definition: CharacterizedActionDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionProperty<'a> = Id<ActionProperty_<'a>>;
pub struct ActionPropertyRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub property: ActionProperty<'a>,
    pub representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionPropertyRepresentation<'a> = Id<ActionPropertyRepresentation_<'a>>;
pub struct ActionRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_action: Action<'a>,
    pub related_action: Action<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRelationship<'a> = Id<ActionRelationship_<'a>>;
pub struct ActionRequestAssignment_<'a> { // entity
    pub assigned_action_request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRequestAssignment<'a> = Id<ActionRequestAssignment_<'a>>;
pub enum ActionRequestItem<'a> { // select
    Action(Action<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    AlternateProductRelationship(AlternateProductRelationship<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationEffectivity(ConfigurationEffectivity<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment<'a>),
    DocumentFile(DocumentFile<'a>),
    DraughtingModel(DraughtingModel<'a>),
    DrawingRevision(DrawingRevision<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    ResourceProperty(ResourceProperty<'a>),
    ShapeAspect(ShapeAspect<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ActionRequestItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| ActionRequestItem::Action(r)),
            map(<ActionMethod<'a>>::parse, |r| ActionRequestItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| ActionRequestItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| ActionRequestItem::ActionRelationship(r)),
            map(<AlternateProductRelationship<'a>>::parse, |r| ActionRequestItem::AlternateProductRelationship(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| ActionRequestItem::AssemblyComponentUsageSubstitute(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| ActionRequestItem::ConfigurationDesign(r)),
            map(<ConfigurationEffectivity<'a>>::parse, |r| ActionRequestItem::ConfigurationEffectivity(r)),
            map(<ConfigurationItem<'a>>::parse, |r| ActionRequestItem::ConfigurationItem(r)),
            map(<ConfiguredEffectivityAssignment<'a>>::parse, |r| ActionRequestItem::ConfiguredEffectivityAssignment(r)),
            map(<DocumentFile<'a>>::parse, |r| ActionRequestItem::DocumentFile(r)),
            map(<DraughtingModel<'a>>::parse, |r| ActionRequestItem::DraughtingModel(r)),
            map(<DrawingRevision<'a>>::parse, |r| ActionRequestItem::DrawingRevision(r)),
            map(<GeneralProperty<'a>>::parse, |r| ActionRequestItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| ActionRequestItem::MaterialDesignation(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| ActionRequestItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<OrganizationalProject<'a>>::parse, |r| ActionRequestItem::OrganizationalProject(r)),
            map(<PresentationArea<'a>>::parse, |r| ActionRequestItem::PresentationArea(r)),
            map(<Product<'a>>::parse, |r| ActionRequestItem::Product(r)),
        alt((
            map(<ProductConcept<'a>>::parse, |r| ActionRequestItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| ActionRequestItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| ActionRequestItem::ProductConceptFeatureAssociation(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| ActionRequestItem::ProductConceptFeatureCategory(r)),
            map(<ProductConceptFeatureCategoryUsage<'a>>::parse, |r| ActionRequestItem::ProductConceptFeatureCategoryUsage(r)),
            map(<ProductDefinition<'a>>::parse, |r| ActionRequestItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| ActionRequestItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| ActionRequestItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| ActionRequestItem::ProductDefinitionSubstitute(r)),
            map(<PropertyDefinition<'a>>::parse, |r| ActionRequestItem::PropertyDefinition(r)),
            map(<ResourceProperty<'a>>::parse, |r| ActionRequestItem::ResourceProperty(r)),
            map(<ShapeAspect<'a>>::parse, |r| ActionRequestItem::ShapeAspect(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| ActionRequestItem::ShapeRepresentation(r)),
        ))))(s)
    }
}
pub struct ActionRequestSolution_<'a> { // entity
    pub method: ActionMethod<'a>,
    pub request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRequestSolution<'a> = Id<ActionRequestSolution_<'a>>;
pub struct ActionRequestStatus_<'a> { // entity
    pub status: Label<'a>,
    pub assigned_request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRequestStatus<'a> = Id<ActionRequestStatus_<'a>>;
pub struct ActionResource_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub usage: Vec<SupportedItem<'a>>,
    pub kind: ActionResourceType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionResource<'a> = Id<ActionResource_<'a>>;
pub struct ActionResourceRequirement_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub kind: ResourceRequirementType<'a>,
    pub operations: Vec<CharacterizedActionDefinition<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionResourceRequirement<'a> = Id<ActionResourceRequirement_<'a>>;
pub struct ActionResourceType_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionResourceType<'a> = Id<ActionResourceType_<'a>>;
pub struct ActionStatus_<'a> { // entity
    pub status: Label<'a>,
    pub assigned_action: ExecutedAction<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionStatus<'a> = Id<ActionStatus_<'a>>;
pub struct Address_<'a> { // entity
    pub internal_location: Option<Label<'a>>,
    pub street_number: Option<Label<'a>>,
    pub street: Option<Label<'a>>,
    pub postal_box: Option<Label<'a>>,
    pub town: Option<Label<'a>>,
    pub region: Option<Label<'a>>,
    pub postal_code: Option<Label<'a>>,
    pub country: Option<Label<'a>>,
    pub facsimile_number: Option<Label<'a>>,
    pub telephone_number: Option<Label<'a>>,
    pub electronic_mail_address: Option<Label<'a>>,
    pub telex_number: Option<Label<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Address<'a> = Id<Address_<'a>>;
pub struct AdvancedBrepShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AdvancedBrepShapeRepresentation<'a> = Id<AdvancedBrepShapeRepresentation_<'a>>;
pub struct AdvancedFace_<'a> { // entity
    pub name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    pub face_geometry: Surface<'a>,
    pub same_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AdvancedFace<'a> = Id<AdvancedFace_<'a>>;
pub enum AheadOrBehind<'a> { // enum
    Ahead,
    Exact,
    Behind,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for AheadOrBehind<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use AheadOrBehind::*;
        alt((
            map(tag(".AHEAD."), |_| Ahead),
            map(tag(".EXACT."), |_| Exact),
            map(tag(".BEHIND."), |_| Behind),
        ))(s)
    }
}
pub struct AlternateProductRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub definition: Option<Text<'a>>,
    pub alternate: Product<'a>,
    pub base: Product<'a>,
    pub basis: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AlternateProductRelationship<'a> = Id<AlternateProductRelationship_<'a>>;
pub struct AmountOfSubstanceMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for AmountOfSubstanceMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> AmountOfSubstanceMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct AmountOfSubstanceMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AmountOfSubstanceMeasureWithUnit<'a> = Id<AmountOfSubstanceMeasureWithUnit_<'a>>;
pub struct AmountOfSubstanceUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AmountOfSubstanceUnit<'a> = Id<AmountOfSubstanceUnit_<'a>>;
pub struct AndExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AndExpression<'a> = Id<AndExpression_<'a>>;
pub enum AngleRelator<'a> { // enum
    Equal,
    Large,
    Small,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for AngleRelator<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use AngleRelator::*;
        alt((
            map(tag(".EQUAL."), |_| Equal),
            map(tag(".LARGE."), |_| Large),
            map(tag(".SMALL."), |_| Small),
        ))(s)
    }
}
pub struct AngularDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularDimension<'a> = Id<AngularDimension_<'a>>;
pub struct AngularLocation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    pub angle_selection: AngleRelator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularLocation<'a> = Id<AngularLocation_<'a>>;
pub struct AngularSize_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    pub angle_selection: AngleRelator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularSize<'a> = Id<AngularSize_<'a>>;
pub struct AngularityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularityTolerance<'a> = Id<AngularityTolerance_<'a>>;
pub struct AnnotationCurveOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationCurveOccurrence<'a> = Id<AnnotationCurveOccurrence_<'a>>;
pub struct AnnotationFillArea_<'a> { // entity
    pub name: Label<'a>,
    pub boundaries: Vec<Curve<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationFillArea<'a> = Id<AnnotationFillArea_<'a>>;
pub struct AnnotationFillAreaOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub fill_style_target: Point<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationFillAreaOccurrence<'a> = Id<AnnotationFillAreaOccurrence_<'a>>;
pub struct AnnotationOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationOccurrence<'a> = Id<AnnotationOccurrence_<'a>>;
pub struct AnnotationOccurrenceAssociativity_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_annotation_occurrence: AnnotationOccurrence<'a>,
    pub related_annotation_occurrence: AnnotationOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationOccurrenceAssociativity<'a> = Id<AnnotationOccurrenceAssociativity_<'a>>;
pub struct AnnotationOccurrenceRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_annotation_occurrence: AnnotationOccurrence<'a>,
    pub related_annotation_occurrence: AnnotationOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationOccurrenceRelationship<'a> = Id<AnnotationOccurrenceRelationship_<'a>>;
pub struct AnnotationPlane_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub elements: Option<Vec<AnnotationPlaneElement<'a>>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationPlane<'a> = Id<AnnotationPlane_<'a>>;
pub enum AnnotationPlaneElement<'a> { // select
    DraughtingCallout(DraughtingCallout<'a>),
    StyledItem(StyledItem<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for AnnotationPlaneElement<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<DraughtingCallout<'a>>::parse, |r| AnnotationPlaneElement::DraughtingCallout(r)),
            map(<StyledItem<'a>>::parse, |r| AnnotationPlaneElement::StyledItem(r)),
        ))(s)
    }
}
pub struct AnnotationSubfigureOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationSubfigureOccurrence<'a> = Id<AnnotationSubfigureOccurrence_<'a>>;
pub struct AnnotationSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationSymbol<'a> = Id<AnnotationSymbol_<'a>>;
pub struct AnnotationSymbolOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationSymbolOccurrence<'a> = Id<AnnotationSymbolOccurrence_<'a>>;
pub enum AnnotationSymbolOccurrenceItem<'a> { // select
    AnnotationSymbol(AnnotationSymbol<'a>),
    DefinedSymbol(DefinedSymbol<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for AnnotationSymbolOccurrenceItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<AnnotationSymbol<'a>>::parse, |r| AnnotationSymbolOccurrenceItem::AnnotationSymbol(r)),
            map(<DefinedSymbol<'a>>::parse, |r| AnnotationSymbolOccurrenceItem::DefinedSymbol(r)),
        ))(s)
    }
}
pub struct AnnotationText_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationText<'a> = Id<AnnotationText_<'a>>;
pub struct AnnotationTextCharacter_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    pub alignment: TextAlignment<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationTextCharacter<'a> = Id<AnnotationTextCharacter_<'a>>;
pub struct AnnotationTextOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationTextOccurrence<'a> = Id<AnnotationTextOccurrence_<'a>>;
pub enum AnnotationTextOccurrenceItem<'a> { // select
    TextLiteral(TextLiteral<'a>),
    AnnotationText(AnnotationText<'a>),
    AnnotationTextCharacter(AnnotationTextCharacter<'a>),
    DefinedCharacterGlyph(DefinedCharacterGlyph<'a>),
    CompositeText(CompositeText<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for AnnotationTextOccurrenceItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<TextLiteral<'a>>::parse, |r| AnnotationTextOccurrenceItem::TextLiteral(r)),
            map(<AnnotationText<'a>>::parse, |r| AnnotationTextOccurrenceItem::AnnotationText(r)),
            map(<AnnotationTextCharacter<'a>>::parse, |r| AnnotationTextOccurrenceItem::AnnotationTextCharacter(r)),
            map(<DefinedCharacterGlyph<'a>>::parse, |r| AnnotationTextOccurrenceItem::DefinedCharacterGlyph(r)),
            map(<CompositeText<'a>>::parse, |r| AnnotationTextOccurrenceItem::CompositeText(r)),
        ))(s)
    }
}
pub struct Apex_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Apex<'a> = Id<Apex_<'a>>;
pub struct ApplicationContext_<'a> { // entity
    pub application: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationContext<'a> = Id<ApplicationContext_<'a>>;
pub struct ApplicationContextElement_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationContextElement<'a> = Id<ApplicationContextElement_<'a>>;
pub struct ApplicationContextRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_context: ApplicationContext<'a>,
    pub related_context: ApplicationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationContextRelationship<'a> = Id<ApplicationContextRelationship_<'a>>;
pub struct ApplicationProtocolDefinition_<'a> { // entity
    pub status: Label<'a>,
    pub application_interpreted_model_schema_name: Label<'a>,
    pub application_protocol_year: YearNumber<'a>,
    pub application: ApplicationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationProtocolDefinition<'a> = Id<ApplicationProtocolDefinition_<'a>>;
pub struct AppliedActionAssignment_<'a> { // entity
    pub assigned_action: Action<'a>,
    pub items: Vec<ActionItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedActionAssignment<'a> = Id<AppliedActionAssignment_<'a>>;
pub struct AppliedActionRequestAssignment_<'a> { // entity
    pub assigned_action_request: VersionedActionRequest<'a>,
    pub items: Vec<ActionRequestItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedActionRequestAssignment<'a> = Id<AppliedActionRequestAssignment_<'a>>;
pub struct AppliedApprovalAssignment_<'a> { // entity
    pub assigned_approval: Approval<'a>,
    pub items: Vec<ApprovalItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedApprovalAssignment<'a> = Id<AppliedApprovalAssignment_<'a>>;
pub struct AppliedArea_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedArea<'a> = Id<AppliedArea_<'a>>;
pub struct AppliedCertificationAssignment_<'a> { // entity
    pub assigned_certification: Certification<'a>,
    pub items: Vec<CertificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedCertificationAssignment<'a> = Id<AppliedCertificationAssignment_<'a>>;
pub struct AppliedClassificationAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub role: ClassificationRole<'a>,
    pub items: Vec<ClassificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedClassificationAssignment<'a> = Id<AppliedClassificationAssignment_<'a>>;
pub struct AppliedContractAssignment_<'a> { // entity
    pub assigned_contract: Contract<'a>,
    pub items: Vec<ContractItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedContractAssignment<'a> = Id<AppliedContractAssignment_<'a>>;
pub struct AppliedDateAndTimeAssignment_<'a> { // entity
    pub assigned_date_and_time: DateAndTime<'a>,
    pub role: DateTimeRole<'a>,
    pub items: Vec<DateAndTimeItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDateAndTimeAssignment<'a> = Id<AppliedDateAndTimeAssignment_<'a>>;
pub struct AppliedDateAssignment_<'a> { // entity
    pub assigned_date: Date<'a>,
    pub role: DateRole<'a>,
    pub items: Vec<DateItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDateAssignment<'a> = Id<AppliedDateAssignment_<'a>>;
pub struct AppliedDocumentReference_<'a> { // entity
    pub assigned_document: Document<'a>,
    pub source: Label<'a>,
    pub items: Vec<DocumentReferenceItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDocumentReference<'a> = Id<AppliedDocumentReference_<'a>>;
pub struct AppliedDocumentUsageConstraintAssignment_<'a> { // entity
    pub assigned_document_usage: DocumentUsageConstraint<'a>,
    pub role: DocumentUsageRole<'a>,
    pub items: Vec<DocumentReferenceItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDocumentUsageConstraintAssignment<'a> = Id<AppliedDocumentUsageConstraintAssignment_<'a>>;
pub struct AppliedEffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    pub items: Vec<EffectivityItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedEffectivityAssignment<'a> = Id<AppliedEffectivityAssignment_<'a>>;
pub struct AppliedEventOccurrenceAssignment_<'a> { // entity
    pub assigned_event_occurrence: EventOccurrence<'a>,
    pub role: EventOccurrenceRole<'a>,
    pub items: Vec<EventOccurrenceItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedEventOccurrenceAssignment<'a> = Id<AppliedEventOccurrenceAssignment_<'a>>;
pub struct AppliedExternalIdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    pub source: ExternalSource<'a>,
    pub items: Vec<ExternalIdentificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedExternalIdentificationAssignment<'a> = Id<AppliedExternalIdentificationAssignment_<'a>>;
pub struct AppliedGroupAssignment_<'a> { // entity
    pub assigned_group: Group<'a>,
    pub items: Vec<GroupItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedGroupAssignment<'a> = Id<AppliedGroupAssignment_<'a>>;
pub struct AppliedIdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    pub items: Vec<IdentificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedIdentificationAssignment<'a> = Id<AppliedIdentificationAssignment_<'a>>;
pub struct AppliedIneffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    pub items: Vec<EffectivityItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedIneffectivityAssignment<'a> = Id<AppliedIneffectivityAssignment_<'a>>;
pub struct AppliedNameAssignment_<'a> { // entity
    pub assigned_name: Label<'a>,
    pub items: Vec<NameItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedNameAssignment<'a> = Id<AppliedNameAssignment_<'a>>;
pub struct AppliedOrganizationAssignment_<'a> { // entity
    pub assigned_organization: Organization<'a>,
    pub role: OrganizationRole<'a>,
    pub items: Vec<OrganizationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedOrganizationAssignment<'a> = Id<AppliedOrganizationAssignment_<'a>>;
pub struct AppliedOrganizationalProjectAssignment_<'a> { // entity
    pub assigned_organizational_project: OrganizationalProject<'a>,
    pub role: OrganizationalProjectRole<'a>,
    pub items: Vec<OrganizationalProjectItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedOrganizationalProjectAssignment<'a> = Id<AppliedOrganizationalProjectAssignment_<'a>>;
pub struct AppliedPersonAndOrganizationAssignment_<'a> { // entity
    pub assigned_person_and_organization: PersonAndOrganization<'a>,
    pub role: PersonAndOrganizationRole<'a>,
    pub items: Vec<PersonAndOrganizationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedPersonAndOrganizationAssignment<'a> = Id<AppliedPersonAndOrganizationAssignment_<'a>>;
pub struct AppliedPresentedItem_<'a> { // entity
    pub items: Vec<PresentedItemSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedPresentedItem<'a> = Id<AppliedPresentedItem_<'a>>;
pub struct AppliedSecurityClassificationAssignment_<'a> { // entity
    pub assigned_security_classification: SecurityClassification<'a>,
    pub items: Vec<SecurityClassificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedSecurityClassificationAssignment<'a> = Id<AppliedSecurityClassificationAssignment_<'a>>;
pub struct AppliedTimeIntervalAssignment_<'a> { // entity
    pub assigned_time_interval: TimeInterval<'a>,
    pub role: TimeIntervalRole<'a>,
    pub items: Vec<TimeIntervalItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedTimeIntervalAssignment<'a> = Id<AppliedTimeIntervalAssignment_<'a>>;
pub struct Approval_<'a> { // entity
    pub status: ApprovalStatus<'a>,
    pub level: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Approval<'a> = Id<Approval_<'a>>;
pub struct ApprovalAssignment_<'a> { // entity
    pub assigned_approval: Approval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalAssignment<'a> = Id<ApprovalAssignment_<'a>>;
pub struct ApprovalDateTime_<'a> { // entity
    pub date_time: DateTimeSelect<'a>,
    pub dated_approval: Approval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalDateTime<'a> = Id<ApprovalDateTime_<'a>>;
pub enum ApprovalItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRequestSolution(ActionRequestSolution<'a>),
    AlternateProductRelationship(AlternateProductRelationship<'a>),
    AppliedActionAssignment(AppliedActionAssignment<'a>),
    AppliedClassificationAssignment(AppliedClassificationAssignment<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    Certification(Certification<'a>),
    Class(Class<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationEffectivity(ConfigurationEffectivity<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment<'a>),
    Contract(Contract<'a>),
    DocumentFile(DocumentFile<'a>),
    DraughtingModel(DraughtingModel<'a>),
    DrawingRevision(DrawingRevision<'a>),
    ExecutedAction(ExecutedAction<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    ResourceProperty(ResourceProperty<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ApprovalItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| ApprovalItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| ApprovalItem::ActionDirective(r)),
            map(<ActionProperty<'a>>::parse, |r| ApprovalItem::ActionProperty(r)),
            map(<ActionRequestSolution<'a>>::parse, |r| ApprovalItem::ActionRequestSolution(r)),
            map(<AlternateProductRelationship<'a>>::parse, |r| ApprovalItem::AlternateProductRelationship(r)),
            map(<AppliedActionAssignment<'a>>::parse, |r| ApprovalItem::AppliedActionAssignment(r)),
            map(<AppliedClassificationAssignment<'a>>::parse, |r| ApprovalItem::AppliedClassificationAssignment(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| ApprovalItem::AssemblyComponentUsageSubstitute(r)),
            map(<Certification<'a>>::parse, |r| ApprovalItem::Certification(r)),
            map(<Class<'a>>::parse, |r| ApprovalItem::Class(r)),
            map(<ClassSystem<'a>>::parse, |r| ApprovalItem::ClassSystem(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| ApprovalItem::ConfigurationDesign(r)),
            map(<ConfigurationEffectivity<'a>>::parse, |r| ApprovalItem::ConfigurationEffectivity(r)),
            map(<ConfiguredEffectivityAssignment<'a>>::parse, |r| ApprovalItem::ConfiguredEffectivityAssignment(r)),
            map(<Contract<'a>>::parse, |r| ApprovalItem::Contract(r)),
            map(<DocumentFile<'a>>::parse, |r| ApprovalItem::DocumentFile(r)),
            map(<DraughtingModel<'a>>::parse, |r| ApprovalItem::DraughtingModel(r)),
            map(<DrawingRevision<'a>>::parse, |r| ApprovalItem::DrawingRevision(r)),
            map(<ExecutedAction<'a>>::parse, |r| ApprovalItem::ExecutedAction(r)),
        alt((
            map(<GeneralProperty<'a>>::parse, |r| ApprovalItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| ApprovalItem::MaterialDesignation(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| ApprovalItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<OrganizationalProject<'a>>::parse, |r| ApprovalItem::OrganizationalProject(r)),
            map(<PresentationArea<'a>>::parse, |r| ApprovalItem::PresentationArea(r)),
            map(<Product<'a>>::parse, |r| ApprovalItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| ApprovalItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| ApprovalItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| ApprovalItem::ProductConceptFeatureAssociation(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| ApprovalItem::ProductConceptFeatureCategory(r)),
            map(<ProductConceptFeatureCategoryUsage<'a>>::parse, |r| ApprovalItem::ProductConceptFeatureCategoryUsage(r)),
            map(<ProductDefinition<'a>>::parse, |r| ApprovalItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| ApprovalItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| ApprovalItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| ApprovalItem::ProductDefinitionSubstitute(r)),
            map(<PropertyDefinition<'a>>::parse, |r| ApprovalItem::PropertyDefinition(r)),
            map(<ResourceProperty<'a>>::parse, |r| ApprovalItem::ResourceProperty(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| ApprovalItem::ShapeRepresentation(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| ApprovalItem::VersionedActionRequest(r)),
        ))))(s)
    }
}
pub struct ApprovalPersonOrganization_<'a> { // entity
    pub person_organization: PersonOrganizationSelect<'a>,
    pub authorized_approval: Approval<'a>,
    pub role: ApprovalRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalPersonOrganization<'a> = Id<ApprovalPersonOrganization_<'a>>;
pub struct ApprovalRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_approval: Approval<'a>,
    pub related_approval: Approval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalRelationship<'a> = Id<ApprovalRelationship_<'a>>;
pub struct ApprovalRole_<'a> { // entity
    pub role: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalRole<'a> = Id<ApprovalRole_<'a>>;
pub struct ApprovalStatus_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalStatus<'a> = Id<ApprovalStatus_<'a>>;
pub enum ApproximationMethod<'a> { // enum
    ChordalDeviation,
    ChordalLength,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ApproximationMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ApproximationMethod::*;
        alt((
            map(tag(".CHORDAL_DEVIATION."), |_| ChordalDeviation),
            map(tag(".CHORDAL_LENGTH."), |_| ChordalLength),
        ))(s)
    }
}
pub struct ApproximationTolerance_<'a> { // entity
    pub tolerance: ToleranceSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApproximationTolerance<'a> = Id<ApproximationTolerance_<'a>>;
pub struct ApproximationToleranceDeviation_<'a> { // entity
    pub tessellation_type: ApproximationMethod<'a>,
    pub tolerances: Vec<ToleranceDeviationSelect<'a>>,
    pub definition_space: ProductOrPresentationSpace<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApproximationToleranceDeviation<'a> = Id<ApproximationToleranceDeviation_<'a>>;
pub struct ApproximationToleranceParameter_<'a> { // entity
    pub tolerances: Vec<ToleranceParameterSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApproximationToleranceParameter<'a> = Id<ApproximationToleranceParameter_<'a>>;
pub struct AreaInSet_<'a> { // entity
    pub area: PresentationArea<'a>,
    pub in_set: PresentationSet<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AreaInSet<'a> = Id<AreaInSet_<'a>>;
pub struct AreaMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for AreaMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> AreaMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct AreaMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AreaMeasureWithUnit<'a> = Id<AreaMeasureWithUnit_<'a>>;
pub enum AreaOrView<'a> { // select
    PresentationArea(PresentationArea<'a>),
    PresentationView(PresentationView<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for AreaOrView<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PresentationArea<'a>>::parse, |r| AreaOrView::PresentationArea(r)),
            map(<PresentationView<'a>>::parse, |r| AreaOrView::PresentationView(r)),
        ))(s)
    }
}
pub struct AreaUnit_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AreaUnit<'a> = Id<AreaUnit_<'a>>;
pub struct AsinFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AsinFunction<'a> = Id<AsinFunction_<'a>>;
pub struct AssemblyComponentUsage_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AssemblyComponentUsage<'a> = Id<AssemblyComponentUsage_<'a>>;
pub struct AssemblyComponentUsageSubstitute_<'a> { // entity
    pub name: Label<'a>,
    pub definition: Option<Text<'a>>,
    pub base: AssemblyComponentUsage<'a>,
    pub substitute: AssemblyComponentUsage<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AssemblyComponentUsageSubstitute<'a> = Id<AssemblyComponentUsageSubstitute_<'a>>;
pub struct AtanFunction_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AtanFunction<'a> = Id<AtanFunction_<'a>>;
pub struct AttributeClassificationAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub attribute_name: Label<'a>,
    pub role: ClassificationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeClassificationAssignment<'a> = Id<AttributeClassificationAssignment_<'a>>;
pub struct AttributeLanguageAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub attribute_name: Label<'a>,
    pub role: ClassificationRole<'a>,
    pub items: Vec<AttributeLanguageItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeLanguageAssignment<'a> = Id<AttributeLanguageAssignment_<'a>>;
pub enum AttributeLanguageItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    AlternateProductRelationship(AlternateProductRelationship<'a>),
    ApplicationContext(ApplicationContext<'a>),
    ApprovalRelationship(ApprovalRelationship<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    AttributeValueAssignment(AttributeValueAssignment<'a>),
    Certification(Certification<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    Contract(Contract<'a>),
    DataEnvironment(DataEnvironment<'a>),
    DateRole(DateRole<'a>),
    DateTimeRole(DateTimeRole<'a>),
    DescriptiveRepresentationItem(DescriptiveRepresentationItem<'a>),
    DocumentRelationship(DocumentRelationship<'a>),
    DraughtingTitle(DraughtingTitle<'a>),
    Effectivity(Effectivity<'a>),
    EffectivityRelationship(EffectivityRelationship<'a>),
    EventOccurrence(EventOccurrence<'a>),
    ExternalSource(ExternalSource<'a>),
    GeneralProperty(GeneralProperty<'a>),
    GeneralPropertyRelationship(GeneralPropertyRelationship<'a>),
    GeometricRepresentationItem(GeometricRepresentationItem<'a>),
    GeometricTolerance(GeometricTolerance<'a>),
    Group(Group<'a>),
    GroupRelationship(GroupRelationship<'a>),
    IdentificationRole(IdentificationRole<'a>),
    KinematicPair(KinematicPair<'a>),
    MappedItem(MappedItem<'a>),
    NameAssignment(NameAssignment<'a>),
    OrganizationRelationship(OrganizationRelationship<'a>),
    OrganizationRole(OrganizationRole<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    OrganizationalProjectRelationship(OrganizationalProjectRelationship<'a>),
    PairActuator(PairActuator<'a>),
    PersonAndOrganizationRole(PersonAndOrganizationRole<'a>),
    PresentationLayerAssignment(PresentationLayerAssignment<'a>),
    ProcessProductAssociation(ProcessProductAssociation<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptRelationship(ProductConceptRelationship<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    ProductRelatedProductCategory(ProductRelatedProductCategory<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    PropertyDefinitionRelationship(PropertyDefinitionRelationship<'a>),
    Representation(Representation<'a>),
    RepresentationRelationship(RepresentationRelationship<'a>),
    RequirementForActionResource(RequirementForActionResource<'a>),
    ResourceProperty(ResourceProperty<'a>),
    ResourceRequirementType(ResourceRequirementType<'a>),
    SecurityClassification(SecurityClassification<'a>),
    ShapeAspect(ShapeAspect<'a>),
    ShapeAspectRelationship(ShapeAspectRelationship<'a>),
    StyledItem(StyledItem<'a>),
    TimeIntervalRole(TimeIntervalRole<'a>),
    TopologicalRepresentationItem(TopologicalRepresentationItem<'a>),
    UncertaintyMeasureWithUnit(UncertaintyMeasureWithUnit<'a>),
    UncertaintyQualifier(UncertaintyQualifier<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    VersionedActionRequestRelationship(VersionedActionRequestRelationship<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for AttributeLanguageItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| AttributeLanguageItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| AttributeLanguageItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| AttributeLanguageItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| AttributeLanguageItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| AttributeLanguageItem::ActionRelationship(r)),
            map(<AlternateProductRelationship<'a>>::parse, |r| AttributeLanguageItem::AlternateProductRelationship(r)),
            map(<ApplicationContext<'a>>::parse, |r| AttributeLanguageItem::ApplicationContext(r)),
            map(<ApprovalRelationship<'a>>::parse, |r| AttributeLanguageItem::ApprovalRelationship(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| AttributeLanguageItem::AssemblyComponentUsageSubstitute(r)),
            map(<AttributeValueAssignment<'a>>::parse, |r| AttributeLanguageItem::AttributeValueAssignment(r)),
            map(<Certification<'a>>::parse, |r| AttributeLanguageItem::Certification(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| AttributeLanguageItem::ConfigurationDesign(r)),
            map(<ConfigurationItem<'a>>::parse, |r| AttributeLanguageItem::ConfigurationItem(r)),
            map(<Contract<'a>>::parse, |r| AttributeLanguageItem::Contract(r)),
            map(<DataEnvironment<'a>>::parse, |r| AttributeLanguageItem::DataEnvironment(r)),
            map(<DateRole<'a>>::parse, |r| AttributeLanguageItem::DateRole(r)),
            map(<DateTimeRole<'a>>::parse, |r| AttributeLanguageItem::DateTimeRole(r)),
            map(<DescriptiveRepresentationItem<'a>>::parse, |r| AttributeLanguageItem::DescriptiveRepresentationItem(r)),
            map(<DocumentRelationship<'a>>::parse, |r| AttributeLanguageItem::DocumentRelationship(r)),
        alt((
            map(<DraughtingTitle<'a>>::parse, |r| AttributeLanguageItem::DraughtingTitle(r)),
            map(<Effectivity<'a>>::parse, |r| AttributeLanguageItem::Effectivity(r)),
            map(<EffectivityRelationship<'a>>::parse, |r| AttributeLanguageItem::EffectivityRelationship(r)),
            map(<EventOccurrence<'a>>::parse, |r| AttributeLanguageItem::EventOccurrence(r)),
            map(<ExternalSource<'a>>::parse, |r| AttributeLanguageItem::ExternalSource(r)),
            map(<GeneralProperty<'a>>::parse, |r| AttributeLanguageItem::GeneralProperty(r)),
            map(<GeneralPropertyRelationship<'a>>::parse, |r| AttributeLanguageItem::GeneralPropertyRelationship(r)),
            map(<GeometricRepresentationItem<'a>>::parse, |r| AttributeLanguageItem::GeometricRepresentationItem(r)),
            map(<GeometricTolerance<'a>>::parse, |r| AttributeLanguageItem::GeometricTolerance(r)),
            map(<Group<'a>>::parse, |r| AttributeLanguageItem::Group(r)),
            map(<GroupRelationship<'a>>::parse, |r| AttributeLanguageItem::GroupRelationship(r)),
            map(<IdentificationRole<'a>>::parse, |r| AttributeLanguageItem::IdentificationRole(r)),
            map(<KinematicPair<'a>>::parse, |r| AttributeLanguageItem::KinematicPair(r)),
            map(<MappedItem<'a>>::parse, |r| AttributeLanguageItem::MappedItem(r)),
            map(<NameAssignment<'a>>::parse, |r| AttributeLanguageItem::NameAssignment(r)),
            map(<OrganizationRelationship<'a>>::parse, |r| AttributeLanguageItem::OrganizationRelationship(r)),
            map(<OrganizationRole<'a>>::parse, |r| AttributeLanguageItem::OrganizationRole(r)),
            map(<OrganizationalProject<'a>>::parse, |r| AttributeLanguageItem::OrganizationalProject(r)),
            map(<OrganizationalProjectRelationship<'a>>::parse, |r| AttributeLanguageItem::OrganizationalProjectRelationship(r)),
        alt((
            map(<PairActuator<'a>>::parse, |r| AttributeLanguageItem::PairActuator(r)),
            map(<PersonAndOrganizationRole<'a>>::parse, |r| AttributeLanguageItem::PersonAndOrganizationRole(r)),
            map(<PresentationLayerAssignment<'a>>::parse, |r| AttributeLanguageItem::PresentationLayerAssignment(r)),
            map(<ProcessProductAssociation<'a>>::parse, |r| AttributeLanguageItem::ProcessProductAssociation(r)),
            map(<Product<'a>>::parse, |r| AttributeLanguageItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| AttributeLanguageItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| AttributeLanguageItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| AttributeLanguageItem::ProductConceptFeatureAssociation(r)),
            map(<ProductConceptRelationship<'a>>::parse, |r| AttributeLanguageItem::ProductConceptRelationship(r)),
            map(<ProductDefinition<'a>>::parse, |r| AttributeLanguageItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| AttributeLanguageItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| AttributeLanguageItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| AttributeLanguageItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| AttributeLanguageItem::ProductDefinitionSubstitute(r)),
            map(<ProductRelatedProductCategory<'a>>::parse, |r| AttributeLanguageItem::ProductRelatedProductCategory(r)),
            map(<PropertyDefinition<'a>>::parse, |r| AttributeLanguageItem::PropertyDefinition(r)),
            map(<PropertyDefinitionRelationship<'a>>::parse, |r| AttributeLanguageItem::PropertyDefinitionRelationship(r)),
            map(<Representation<'a>>::parse, |r| AttributeLanguageItem::Representation(r)),
            map(<RepresentationRelationship<'a>>::parse, |r| AttributeLanguageItem::RepresentationRelationship(r)),
        alt((
            map(<RequirementForActionResource<'a>>::parse, |r| AttributeLanguageItem::RequirementForActionResource(r)),
            map(<ResourceProperty<'a>>::parse, |r| AttributeLanguageItem::ResourceProperty(r)),
            map(<ResourceRequirementType<'a>>::parse, |r| AttributeLanguageItem::ResourceRequirementType(r)),
            map(<SecurityClassification<'a>>::parse, |r| AttributeLanguageItem::SecurityClassification(r)),
            map(<ShapeAspect<'a>>::parse, |r| AttributeLanguageItem::ShapeAspect(r)),
            map(<ShapeAspectRelationship<'a>>::parse, |r| AttributeLanguageItem::ShapeAspectRelationship(r)),
            map(<StyledItem<'a>>::parse, |r| AttributeLanguageItem::StyledItem(r)),
            map(<TimeIntervalRole<'a>>::parse, |r| AttributeLanguageItem::TimeIntervalRole(r)),
            map(<TopologicalRepresentationItem<'a>>::parse, |r| AttributeLanguageItem::TopologicalRepresentationItem(r)),
            map(<UncertaintyMeasureWithUnit<'a>>::parse, |r| AttributeLanguageItem::UncertaintyMeasureWithUnit(r)),
            map(<UncertaintyQualifier<'a>>::parse, |r| AttributeLanguageItem::UncertaintyQualifier(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| AttributeLanguageItem::VersionedActionRequest(r)),
            map(<VersionedActionRequestRelationship<'a>>::parse, |r| AttributeLanguageItem::VersionedActionRequestRelationship(r)),
        ))))))))(s)
    }
}
pub enum AttributeType<'a> { // select
    Label(Label<'a>),
    Text(Text<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for AttributeType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Label<'a>>::parse, |r| AttributeType::Label(r)),
            map(<Text<'a>>::parse, |r| AttributeType::Text(r)),
        ))(s)
    }
}
pub struct AttributeValueAssignment_<'a> { // entity
    pub attribute_name: Label<'a>,
    pub attribute_value: AttributeType<'a>,
    pub role: AttributeValueRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeValueAssignment<'a> = Id<AttributeValueAssignment_<'a>>;
pub struct AttributeValueRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeValueRole<'a> = Id<AttributeValueRole_<'a>>;
pub struct Axis1Placement_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    pub axis: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Axis1Placement<'a> = Id<Axis1Placement_<'a>>;
pub enum Axis2Placement<'a> { // select
    Axis2Placement2d(Axis2Placement2d<'a>),
    Axis2Placement3d(Axis2Placement3d<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for Axis2Placement<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Axis2Placement2d<'a>>::parse, |r| Axis2Placement::Axis2Placement2d(r)),
            map(<Axis2Placement3d<'a>>::parse, |r| Axis2Placement::Axis2Placement3d(r)),
        ))(s)
    }
}
pub struct Axis2Placement2d_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    pub ref_direction: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Axis2Placement2d<'a> = Id<Axis2Placement2d_<'a>>;
pub struct Axis2Placement3d_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    pub axis: Option<Direction<'a>>,
    pub ref_direction: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Axis2Placement3d<'a> = Id<Axis2Placement3d_<'a>>;
pub struct BSplineCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Option<bool>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineCurve<'a> = Id<BSplineCurve_<'a>>;
pub enum BSplineCurveForm<'a> { // enum
    PolylineForm,
    CircularArc,
    EllipticArc,
    ParabolicArc,
    HyperbolicArc,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BSplineCurveForm<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BSplineCurveForm::*;
        alt((
            map(tag(".POLYLINE_FORM."), |_| PolylineForm),
            map(tag(".CIRCULAR_ARC."), |_| CircularArc),
            map(tag(".ELLIPTIC_ARC."), |_| EllipticArc),
            map(tag(".PARABOLIC_ARC."), |_| ParabolicArc),
            map(tag(".HYPERBOLIC_ARC."), |_| HyperbolicArc),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
pub struct BSplineCurveWithKnots_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Option<bool>,
    pub self_intersect: Option<bool>,
    pub knot_multiplicities: Vec<i64>,
    pub knots: Vec<ParameterValue<'a>>,
    pub knot_spec: KnotType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineCurveWithKnots<'a> = Id<BSplineCurveWithKnots_<'a>>;
pub struct BSplineSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Option<bool>,
    pub v_closed: Option<bool>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineSurface<'a> = Id<BSplineSurface_<'a>>;
pub enum BSplineSurfaceForm<'a> { // enum
    PlaneSurf,
    CylindricalSurf,
    ConicalSurf,
    SphericalSurf,
    ToroidalSurf,
    SurfOfRevolution,
    RuledSurf,
    GeneralisedCone,
    QuadricSurf,
    SurfOfLinearExtrusion,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BSplineSurfaceForm<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BSplineSurfaceForm::*;
        alt((
            map(tag(".PLANE_SURF."), |_| PlaneSurf),
            map(tag(".CYLINDRICAL_SURF."), |_| CylindricalSurf),
            map(tag(".CONICAL_SURF."), |_| ConicalSurf),
            map(tag(".SPHERICAL_SURF."), |_| SphericalSurf),
            map(tag(".TOROIDAL_SURF."), |_| ToroidalSurf),
            map(tag(".SURF_OF_REVOLUTION."), |_| SurfOfRevolution),
            map(tag(".RULED_SURF."), |_| RuledSurf),
            map(tag(".GENERALISED_CONE."), |_| GeneralisedCone),
            map(tag(".QUADRIC_SURF."), |_| QuadricSurf),
            map(tag(".SURF_OF_LINEAR_EXTRUSION."), |_| SurfOfLinearExtrusion),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
pub struct BSplineSurfaceWithKnots_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Option<bool>,
    pub v_closed: Option<bool>,
    pub self_intersect: Option<bool>,
    pub u_multiplicities: Vec<i64>,
    pub v_multiplicities: Vec<i64>,
    pub u_knots: Vec<ParameterValue<'a>>,
    pub v_knots: Vec<ParameterValue<'a>>,
    pub knot_spec: KnotType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineSurfaceWithKnots<'a> = Id<BSplineSurfaceWithKnots_<'a>>;
pub struct BackgroundColour_<'a> { // entity
    pub presentation: AreaOrView<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BackgroundColour<'a> = Id<BackgroundColour_<'a>>;
pub struct BarringHole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BarringHole<'a> = Id<BarringHole_<'a>>;
pub struct Bead_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Bead<'a> = Id<Bead_<'a>>;
pub struct BeadEnd_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BeadEnd<'a> = Id<BeadEnd_<'a>>;
pub struct BezierCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Option<bool>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BezierCurve<'a> = Id<BezierCurve_<'a>>;
pub struct BezierSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Option<bool>,
    pub v_closed: Option<bool>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BezierSurface<'a> = Id<BezierSurface_<'a>>;
pub struct BinaryBooleanExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryBooleanExpression<'a> = Id<BinaryBooleanExpression_<'a>>;
pub struct BinaryFunctionCall_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryFunctionCall<'a> = Id<BinaryFunctionCall_<'a>>;
pub struct BinaryGenericExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryGenericExpression<'a> = Id<BinaryGenericExpression_<'a>>;
pub struct BinaryNumericExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryNumericExpression<'a> = Id<BinaryNumericExpression_<'a>>;
pub struct Block_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub x: PositiveLengthMeasure<'a>,
    pub y: PositiveLengthMeasure<'a>,
    pub z: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Block<'a> = Id<Block_<'a>>;
pub struct BooleanDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanDefinedFunction<'a> = Id<BooleanDefinedFunction_<'a>>;
pub struct BooleanExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanExpression<'a> = Id<BooleanExpression_<'a>>;
pub struct BooleanLiteral_<'a> { // entity
    pub the_value: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanLiteral<'a> = Id<BooleanLiteral_<'a>>;
pub enum BooleanOperand<'a> { // select
    SolidModel(SolidModel<'a>),
    HalfSpaceSolid(HalfSpaceSolid<'a>),
    CsgPrimitive(CsgPrimitive<'a>),
    BooleanResult(BooleanResult<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for BooleanOperand<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<SolidModel<'a>>::parse, |r| BooleanOperand::SolidModel(r)),
            map(<HalfSpaceSolid<'a>>::parse, |r| BooleanOperand::HalfSpaceSolid(r)),
            map(<CsgPrimitive<'a>>::parse, |r| BooleanOperand::CsgPrimitive(r)),
            map(<BooleanResult<'a>>::parse, |r| BooleanOperand::BooleanResult(r)),
        ))(s)
    }
}
pub enum BooleanOperator<'a> { // enum
    Union,
    Intersection,
    Difference,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BooleanOperator<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BooleanOperator::*;
        alt((
            map(tag(".UNION."), |_| Union),
            map(tag(".INTERSECTION."), |_| Intersection),
            map(tag(".DIFFERENCE."), |_| Difference),
        ))(s)
    }
}
pub struct BooleanResult_<'a> { // entity
    pub name: Label<'a>,
    pub operator: BooleanOperator<'a>,
    pub first_operand: BooleanOperand<'a>,
    pub second_operand: BooleanOperand<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanResult<'a> = Id<BooleanResult_<'a>>;
pub struct BooleanVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanVariable<'a> = Id<BooleanVariable_<'a>>;
pub struct Boss_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Boss<'a> = Id<Boss_<'a>>;
pub struct BossTop_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BossTop<'a> = Id<BossTop_<'a>>;
pub struct BoundaryCurve_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundaryCurve<'a> = Id<BoundaryCurve_<'a>>;
pub struct BoundedCurve_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedCurve<'a> = Id<BoundedCurve_<'a>>;
pub struct BoundedPcurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedPcurve<'a> = Id<BoundedPcurve_<'a>>;
pub struct BoundedSurface_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedSurface<'a> = Id<BoundedSurface_<'a>>;
pub struct BoundedSurfaceCurve_<'a> { // entity
    pub name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: Vec<PcurveOrSurface<'a>>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedSurfaceCurve<'a> = Id<BoundedSurfaceCurve_<'a>>;
pub enum BoxCharacteristicSelect<'a> { // select
    BoxHeight(BoxHeight<'a>),
    BoxWidth(BoxWidth<'a>),
    BoxSlantAngle(BoxSlantAngle<'a>),
    BoxRotateAngle(BoxRotateAngle<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for BoxCharacteristicSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<BoxHeight<'a>>::parse, |r| BoxCharacteristicSelect::BoxHeight(r)),
            map(<BoxWidth<'a>>::parse, |r| BoxCharacteristicSelect::BoxWidth(r)),
            map(<BoxSlantAngle<'a>>::parse, |r| BoxCharacteristicSelect::BoxSlantAngle(r)),
            map(<BoxRotateAngle<'a>>::parse, |r| BoxCharacteristicSelect::BoxRotateAngle(r)),
        ))(s)
    }
}
pub struct BoxDomain_<'a> { // entity
    pub corner: CartesianPoint<'a>,
    pub xlength: PositiveLengthMeasure<'a>,
    pub ylength: PositiveLengthMeasure<'a>,
    pub zlength: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoxDomain<'a> = Id<BoxDomain_<'a>>;

pub struct BoxHeight<'a>(pub PositiveRatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxHeight<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("BOX_HEIGHT("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> BoxHeight<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(PositiveRatioMeasure::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}

pub struct BoxRotateAngle<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxRotateAngle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("BOX_ROTATE_ANGLE("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> BoxRotateAngle<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}

pub struct BoxSlantAngle<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxSlantAngle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("BOX_SLANT_ANGLE("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> BoxSlantAngle<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}

pub struct BoxWidth<'a>(pub PositiveRatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxWidth<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("BOX_WIDTH("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> BoxWidth<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(PositiveRatioMeasure::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct BoxedHalfSpace_<'a> { // entity
    pub name: Label<'a>,
    pub base_surface: Surface<'a>,
    pub agreement_flag: bool,
    pub enclosure: BoxDomain<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoxedHalfSpace<'a> = Id<BoxedHalfSpace_<'a>>;
pub struct BrepWithVoids_<'a> { // entity
    pub name: Label<'a>,
    pub outer: ClosedShell<'a>,
    pub voids: Vec<OrientedClosedShell<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BrepWithVoids<'a> = Id<BrepWithVoids_<'a>>;
pub struct CalendarDate_<'a> { // entity
    pub year_component: YearNumber<'a>,
    pub day_component: DayInMonthNumber<'a>,
    pub month_component: MonthInYearNumber<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CalendarDate<'a> = Id<CalendarDate_<'a>>;
pub struct CameraImage_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraImage<'a> = Id<CameraImage_<'a>>;
pub struct CameraImage2dWithScale_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraImage2dWithScale<'a> = Id<CameraImage2dWithScale_<'a>>;
pub struct CameraImage3dWithScale_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraImage3dWithScale<'a> = Id<CameraImage3dWithScale_<'a>>;
pub struct CameraModel_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModel<'a> = Id<CameraModel_<'a>>;
pub struct CameraModelD2_<'a> { // entity
    pub name: Label<'a>,
    pub view_window: PlanarBox<'a>,
    pub view_window_clipping: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModelD2<'a> = Id<CameraModelD2_<'a>>;
pub struct CameraModelD3_<'a> { // entity
    pub name: Label<'a>,
    pub view_reference_system: Axis2Placement3d<'a>,
    pub perspective_of_volume: ViewVolume<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModelD3<'a> = Id<CameraModelD3_<'a>>;
pub struct CameraModelD3WithHlhsr_<'a> { // entity
    pub name: Label<'a>,
    pub view_reference_system: Axis2Placement3d<'a>,
    pub perspective_of_volume: ViewVolume<'a>,
    pub hidden_line_surface_removal: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModelD3WithHlhsr<'a> = Id<CameraModelD3WithHlhsr_<'a>>;
pub struct CameraUsage_<'a> { // entity
    pub mapping_origin: RepresentationItem<'a>,
    pub mapped_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraUsage<'a> = Id<CameraUsage_<'a>>;
pub struct CartesianPoint_<'a> { // entity
    pub name: Label<'a>,
    pub coordinates: Vec<LengthMeasure<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianPoint<'a> = Id<CartesianPoint_<'a>>;
#[allow(non_snake_case)]
pub struct CartesianTransformationOperator_<'a> { // entity
    pub name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub axis1: Option<Direction<'a>>,
    pub axis2: Option<Direction<'a>>,
    pub local_origin: CartesianPoint<'a>,
    pub scale: Option<f64>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianTransformationOperator<'a> = Id<CartesianTransformationOperator_<'a>>;
#[allow(non_snake_case)]
pub struct CartesianTransformationOperator2d_<'a> { // entity
    pub name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub axis1: Option<Direction<'a>>,
    pub axis2: Option<Direction<'a>>,
    pub local_origin: CartesianPoint<'a>,
    pub scale: Option<f64>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianTransformationOperator2d<'a> = Id<CartesianTransformationOperator2d_<'a>>;
#[allow(non_snake_case)]
pub struct CartesianTransformationOperator3d_<'a> { // entity
    pub name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub axis1: Option<Direction<'a>>,
    pub axis2: Option<Direction<'a>>,
    pub local_origin: CartesianPoint<'a>,
    pub scale: Option<f64>,
    pub axis3: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianTransformationOperator3d<'a> = Id<CartesianTransformationOperator3d_<'a>>;
pub enum CategoryUsageItem<'a> { // select
    ProductClass(ProductClass<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CategoryUsageItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<ProductClass<'a>>::parse, |r| CategoryUsageItem::ProductClass(r))(s)
    }
}
pub struct CelsiusTemperatureMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CelsiusTemperatureMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> CelsiusTemperatureMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct CelsiusTemperatureMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CelsiusTemperatureMeasureWithUnit<'a> = Id<CelsiusTemperatureMeasureWithUnit_<'a>>;
pub enum CentralOrParallel<'a> { // enum
    Central,
    Parallel,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for CentralOrParallel<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use CentralOrParallel::*;
        alt((
            map(tag(".CENTRAL."), |_| Central),
            map(tag(".PARALLEL."), |_| Parallel),
        ))(s)
    }
}
pub struct CentreOfSymmetry_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CentreOfSymmetry<'a> = Id<CentreOfSymmetry_<'a>>;
pub struct Certification_<'a> { // entity
    pub name: Label<'a>,
    pub purpose: Text<'a>,
    pub kind: CertificationType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Certification<'a> = Id<Certification_<'a>>;
pub struct CertificationAssignment_<'a> { // entity
    pub assigned_certification: Certification<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CertificationAssignment<'a> = Id<CertificationAssignment_<'a>>;
pub enum CertificationItem<'a> { // select
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CertificationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ProductDefinition<'a>>::parse, |r| CertificationItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| CertificationItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| CertificationItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| CertificationItem::ProductDefinitionRelationship(r)),
        ))(s)
    }
}
pub struct CertificationType_<'a> { // entity
    pub description: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CertificationType<'a> = Id<CertificationType_<'a>>;
pub struct Chamfer_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Chamfer<'a> = Id<Chamfer_<'a>>;
pub struct ChamferOffset_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ChamferOffset<'a> = Id<ChamferOffset_<'a>>;
pub struct CharacterGlyphSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    pub character_box: PlanarExtent<'a>,
    pub baseline_ratio: RatioMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CharacterGlyphSymbol<'a> = Id<CharacterGlyphSymbol_<'a>>;
pub enum CharacterSpacingSelect<'a> { // select
    LengthMeasure(LengthMeasure<'a>),
    RatioMeasure(RatioMeasure<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CharacterSpacingSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<LengthMeasure<'a>>::parse, |r| CharacterSpacingSelect::LengthMeasure(r)),
            map(<RatioMeasure<'a>>::parse, |r| CharacterSpacingSelect::RatioMeasure(r)),
            map(<MeasureWithUnit<'a>>::parse, |r| CharacterSpacingSelect::MeasureWithUnit(r)),
            map(<DescriptiveMeasure<'a>>::parse, |r| CharacterSpacingSelect::DescriptiveMeasure(r)),
        ))(s)
    }
}
pub enum CharacterStyleSelect<'a> { // select
    TextStyleForDefinedFont(TextStyleForDefinedFont<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CharacterStyleSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<TextStyleForDefinedFont<'a>>::parse, |r| CharacterStyleSelect::TextStyleForDefinedFont(r))(s)
    }
}
pub enum CharacterizedActionDefinition<'a> { // select
    Action(Action<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionMethodRelationship(ActionMethodRelationship<'a>),
    ActionRelationship(ActionRelationship<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CharacterizedActionDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| CharacterizedActionDefinition::Action(r)),
            map(<ActionMethod<'a>>::parse, |r| CharacterizedActionDefinition::ActionMethod(r)),
            map(<ActionMethodRelationship<'a>>::parse, |r| CharacterizedActionDefinition::ActionMethodRelationship(r)),
            map(<ActionRelationship<'a>>::parse, |r| CharacterizedActionDefinition::ActionRelationship(r)),
        ))(s)
    }
}
#[allow(non_snake_case)]
pub struct CharacterizedClass_<'a> { // entity
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CharacterizedClass<'a> = Id<CharacterizedClass_<'a>>;
pub enum CharacterizedDefinition<'a> { // select
    CharacterizedObject(CharacterizedObject<'a>),
    CharacterizedProductDefinition(CharacterizedProductDefinition<'a>),
    ShapeDefinition(ShapeDefinition<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CharacterizedDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<CharacterizedObject<'a>>::parse, |r| CharacterizedDefinition::CharacterizedObject(r)),
            map(<CharacterizedProductDefinition<'a>>::parse, |r| CharacterizedDefinition::CharacterizedProductDefinition(r)),
            map(<ShapeDefinition<'a>>::parse, |r| CharacterizedDefinition::ShapeDefinition(r)),
        ))(s)
    }
}
pub enum CharacterizedMaterialProperty<'a> { // select
    MaterialPropertyRepresentation(MaterialPropertyRepresentation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CharacterizedMaterialProperty<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<MaterialPropertyRepresentation<'a>>::parse, |r| CharacterizedMaterialProperty::MaterialPropertyRepresentation(r))(s)
    }
}
pub struct CharacterizedObject_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CharacterizedObject<'a> = Id<CharacterizedObject_<'a>>;
pub enum CharacterizedProductDefinition<'a> { // select
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CharacterizedProductDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ProductDefinition<'a>>::parse, |r| CharacterizedProductDefinition::ProductDefinition(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| CharacterizedProductDefinition::ProductDefinitionRelationship(r)),
        ))(s)
    }
}
pub enum CharacterizedResourceDefinition<'a> { // select
    ActionResource(ActionResource<'a>),
    ActionResourceRequirement(ActionResourceRequirement<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CharacterizedResourceDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ActionResource<'a>>::parse, |r| CharacterizedResourceDefinition::ActionResource(r)),
            map(<ActionResourceRequirement<'a>>::parse, |r| CharacterizedResourceDefinition::ActionResourceRequirement(r)),
        ))(s)
    }
}
pub struct Circle_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Circle<'a> = Id<Circle_<'a>>;
pub struct CircularClosedProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CircularClosedProfile<'a> = Id<CircularClosedProfile_<'a>>;
pub struct CircularPattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CircularPattern<'a> = Id<CircularPattern_<'a>>;
pub struct CircularRunoutTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CircularRunoutTolerance<'a> = Id<CircularRunoutTolerance_<'a>>;
pub struct Class_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Class<'a> = Id<Class_<'a>>;
pub struct ClassSystem_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassSystem<'a> = Id<ClassSystem_<'a>>;
pub struct ClassUsageEffectivityContextAssignment_<'a> { // entity
    pub assigned_effectivity_assignment: EffectivityAssignment<'a>,
    pub role: EffectivityContextRole<'a>,
    pub items: Vec<ClassUsageEffectivityContextItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassUsageEffectivityContextAssignment<'a> = Id<ClassUsageEffectivityContextAssignment_<'a>>;
pub enum ClassUsageEffectivityContextItem<'a> { // select
    ProductDefinition(ProductDefinition<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ClassUsageEffectivityContextItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<ProductDefinition<'a>>::parse, |r| ClassUsageEffectivityContextItem::ProductDefinition(r))(s)
    }
}
pub struct ClassificationAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub role: ClassificationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassificationAssignment<'a> = Id<ClassificationAssignment_<'a>>;
pub enum ClassificationItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    ApprovalStatus(ApprovalStatus<'a>),
    Class(Class<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    Contract(Contract<'a>),
    DescriptiveRepresentationItem(DescriptiveRepresentationItem<'a>),
    DocumentFile(DocumentFile<'a>),
    DocumentType(DocumentType<'a>),
    Effectivity(Effectivity<'a>),
    ExecutedAction(ExecutedAction<'a>),
    FeatureDefinition(FeatureDefinition<'a>),
    GeneralFeature(GeneralFeature<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PlusMinusTolerance(PlusMinusTolerance<'a>),
    ProcessOperation(ProcessOperation<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    ResourceProperty(ResourceProperty<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel<'a>),
    ShapeAspect(ShapeAspect<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ClassificationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| ClassificationItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| ClassificationItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| ClassificationItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| ClassificationItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| ClassificationItem::ActionRelationship(r)),
            map(<ApprovalStatus<'a>>::parse, |r| ClassificationItem::ApprovalStatus(r)),
            map(<Class<'a>>::parse, |r| ClassificationItem::Class(r)),
            map(<ConfigurationItem<'a>>::parse, |r| ClassificationItem::ConfigurationItem(r)),
            map(<Contract<'a>>::parse, |r| ClassificationItem::Contract(r)),
            map(<DescriptiveRepresentationItem<'a>>::parse, |r| ClassificationItem::DescriptiveRepresentationItem(r)),
            map(<DocumentFile<'a>>::parse, |r| ClassificationItem::DocumentFile(r)),
            map(<DocumentType<'a>>::parse, |r| ClassificationItem::DocumentType(r)),
            map(<Effectivity<'a>>::parse, |r| ClassificationItem::Effectivity(r)),
            map(<ExecutedAction<'a>>::parse, |r| ClassificationItem::ExecutedAction(r)),
            map(<FeatureDefinition<'a>>::parse, |r| ClassificationItem::FeatureDefinition(r)),
            map(<GeneralFeature<'a>>::parse, |r| ClassificationItem::GeneralFeature(r)),
            map(<GeneralProperty<'a>>::parse, |r| ClassificationItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| ClassificationItem::MaterialDesignation(r)),
            map(<OrganizationalProject<'a>>::parse, |r| ClassificationItem::OrganizationalProject(r)),
        alt((
            map(<PlusMinusTolerance<'a>>::parse, |r| ClassificationItem::PlusMinusTolerance(r)),
            map(<ProcessOperation<'a>>::parse, |r| ClassificationItem::ProcessOperation(r)),
            map(<Product<'a>>::parse, |r| ClassificationItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| ClassificationItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| ClassificationItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| ClassificationItem::ProductConceptFeatureCategory(r)),
            map(<ProductDefinition<'a>>::parse, |r| ClassificationItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| ClassificationItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| ClassificationItem::ProductDefinitionRelationship(r)),
            map(<PropertyDefinition<'a>>::parse, |r| ClassificationItem::PropertyDefinition(r)),
            map(<ResourceProperty<'a>>::parse, |r| ClassificationItem::ResourceProperty(r)),
            map(<SecurityClassificationLevel<'a>>::parse, |r| ClassificationItem::SecurityClassificationLevel(r)),
            map(<ShapeAspect<'a>>::parse, |r| ClassificationItem::ShapeAspect(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| ClassificationItem::VersionedActionRequest(r)),
        ))))(s)
    }
}
pub struct ClassificationRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassificationRole<'a> = Id<ClassificationRole_<'a>>;
pub struct ClosedPathProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClosedPathProfile<'a> = Id<ClosedPathProfile_<'a>>;
pub struct ClosedShell_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClosedShell<'a> = Id<ClosedShell_<'a>>;
pub struct CoaxialityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CoaxialityTolerance<'a> = Id<CoaxialityTolerance_<'a>>;
pub struct Colour_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Colour<'a> = Id<Colour_<'a>>;
pub struct ColourRgb_<'a> { // entity
    pub name: Label<'a>,
    pub red: f64,
    pub green: f64,
    pub blue: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ColourRgb<'a> = Id<ColourRgb_<'a>>;
pub struct ColourSpecification_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ColourSpecification<'a> = Id<ColourSpecification_<'a>>;
pub struct CommonDatum_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CommonDatum<'a> = Id<CommonDatum_<'a>>;
pub struct ComparisonEqual_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonEqual<'a> = Id<ComparisonEqual_<'a>>;
pub struct ComparisonExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonExpression<'a> = Id<ComparisonExpression_<'a>>;
pub struct ComparisonGreater_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonGreater<'a> = Id<ComparisonGreater_<'a>>;
pub struct ComparisonGreaterEqual_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonGreaterEqual<'a> = Id<ComparisonGreaterEqual_<'a>>;
pub struct ComparisonLess_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonLess<'a> = Id<ComparisonLess_<'a>>;
pub struct ComparisonLessEqual_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonLessEqual<'a> = Id<ComparisonLessEqual_<'a>>;
pub struct ComparisonNotEqual_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonNotEqual<'a> = Id<ComparisonNotEqual_<'a>>;
pub struct CompositeCurve_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeCurve<'a> = Id<CompositeCurve_<'a>>;
pub struct CompositeCurveOnSurface_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeCurveOnSurface<'a> = Id<CompositeCurveOnSurface_<'a>>;
pub struct CompositeCurveSegment_<'a> { // entity
    pub transition: TransitionCode<'a>,
    pub same_sense: bool,
    pub parent_curve: Curve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeCurveSegment<'a> = Id<CompositeCurveSegment_<'a>>;
pub struct CompositeHole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeHole<'a> = Id<CompositeHole_<'a>>;
pub struct CompositeShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeShapeAspect<'a> = Id<CompositeShapeAspect_<'a>>;
pub struct CompositeText_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeText<'a> = Id<CompositeText_<'a>>;
pub struct CompositeTextWithAssociatedCurves_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    pub associated_curves: Vec<Curve<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeTextWithAssociatedCurves<'a> = Id<CompositeTextWithAssociatedCurves_<'a>>;
pub struct CompositeTextWithBlankingBox_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    pub blanking: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeTextWithBlankingBox<'a> = Id<CompositeTextWithBlankingBox_<'a>>;
pub struct CompositeTextWithExtent_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    pub extent: PlanarExtent<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeTextWithExtent<'a> = Id<CompositeTextWithExtent_<'a>>;
pub struct CompoundFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompoundFeature<'a> = Id<CompoundFeature_<'a>>;
pub enum CompoundItemDefinition<'a> { // select
    ListRepresentationItem(Vec<RepresentationItem<'a>>),
    SetRepresentationItem(Vec<RepresentationItem<'a>>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CompoundItemDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Vec<RepresentationItem<'a>>>::parse, |r| CompoundItemDefinition::ListRepresentationItem(r)),
            map(<Vec<RepresentationItem<'a>>>::parse, |r| CompoundItemDefinition::SetRepresentationItem(r)),
        ))(s)
    }
}
pub struct CompoundRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub item_element: CompoundItemDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompoundRepresentationItem<'a> = Id<CompoundRepresentationItem_<'a>>;
pub struct CompoundShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompoundShapeRepresentation<'a> = Id<CompoundShapeRepresentation_<'a>>;
pub struct ConcatExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConcatExpression<'a> = Id<ConcatExpression_<'a>>;
pub struct ConcentricityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConcentricityTolerance<'a> = Id<ConcentricityTolerance_<'a>>;
pub struct ConceptFeatureOperator_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConceptFeatureOperator<'a> = Id<ConceptFeatureOperator_<'a>>;
pub struct ConceptFeatureRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_concept_feature: ProductConceptFeature<'a>,
    pub related_product_concept_feature: ProductConceptFeature<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConceptFeatureRelationship<'a> = Id<ConceptFeatureRelationship_<'a>>;
pub struct ConceptFeatureRelationshipWithCondition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_concept_feature: ProductConceptFeature<'a>,
    pub related_product_concept_feature: ProductConceptFeature<'a>,
    pub conditional_operator: ConceptFeatureOperator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConceptFeatureRelationshipWithCondition<'a> = Id<ConceptFeatureRelationshipWithCondition_<'a>>;
pub struct ConditionalConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub condition: ConceptFeatureRelationshipWithCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConditionalConceptFeature<'a> = Id<ConditionalConceptFeature_<'a>>;
pub struct ConfigurableItem_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_concept: ProductConcept<'a>,
    pub purpose: Option<Label<'a>>,
    pub item_concept_feature: Vec<ProductConceptFeatureAssociation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurableItem<'a> = Id<ConfigurableItem_<'a>>;
pub struct ConfigurationDefinition_<'a> { // entity
    pub pair_values: Vec<PairValue<'a>>,
    pub t_parameter: MotionParameterMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationDefinition<'a> = Id<ConfigurationDefinition_<'a>>;
pub struct ConfigurationDesign_<'a> { // entity
    pub configuration: ConfigurationItem<'a>,
    pub design: ConfigurationDesignItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationDesign<'a> = Id<ConfigurationDesign_<'a>>;
pub enum ConfigurationDesignItem<'a> { // select
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ConfigurationDesignItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ProductDefinition<'a>>::parse, |r| ConfigurationDesignItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| ConfigurationDesignItem::ProductDefinitionFormation(r)),
        ))(s)
    }
}
pub struct ConfigurationEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub usage: ProductDefinitionRelationship<'a>,
    pub configuration: ConfigurationDesign<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationEffectivity<'a> = Id<ConfigurationEffectivity_<'a>>;
pub struct ConfigurationInterpolation_<'a> { // entity
    pub previous_configuration_definition: ConfigurationDefinition<'a>,
    pub next_configuration_definition: ConfigurationDefinition<'a>,
    pub interpolation: InterpolationType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationInterpolation<'a> = Id<ConfigurationInterpolation_<'a>>;
pub struct ConfigurationItem_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_concept: ProductConcept<'a>,
    pub purpose: Option<Label<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationItem<'a> = Id<ConfigurationItem_<'a>>;
pub struct ConfiguredEffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    pub items: Vec<ConfiguredEffectivityItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfiguredEffectivityAssignment<'a> = Id<ConfiguredEffectivityAssignment_<'a>>;
pub struct ConfiguredEffectivityContextAssignment_<'a> { // entity
    pub assigned_effectivity_assignment: EffectivityAssignment<'a>,
    pub role: EffectivityContextRole<'a>,
    pub items: Vec<ConfiguredEffectivityContextItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfiguredEffectivityContextAssignment<'a> = Id<ConfiguredEffectivityContextAssignment_<'a>>;
pub enum ConfiguredEffectivityContextItem<'a> { // select
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ConfiguredEffectivityContextItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<ProductConceptFeatureAssociation<'a>>::parse, |r| ConfiguredEffectivityContextItem::ProductConceptFeatureAssociation(r))(s)
    }
}
pub enum ConfiguredEffectivityItem<'a> { // select
    ActionRelationship(ActionRelationship<'a>),
    ProcessPlan(ProcessPlan<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductProcessPlan(ProductProcessPlan<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ConfiguredEffectivityItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ActionRelationship<'a>>::parse, |r| ConfiguredEffectivityItem::ActionRelationship(r)),
            map(<ProcessPlan<'a>>::parse, |r| ConfiguredEffectivityItem::ProcessPlan(r)),
            map(<ProductDefinition<'a>>::parse, |r| ConfiguredEffectivityItem::ProductDefinition(r)),
            map(<ProductProcessPlan<'a>>::parse, |r| ConfiguredEffectivityItem::ProductProcessPlan(r)),
        ))(s)
    }
}
pub struct Conic_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Conic<'a> = Id<Conic_<'a>>;
pub struct ConicalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub radius: LengthMeasure<'a>,
    pub semi_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConicalSurface<'a> = Id<ConicalSurface_<'a>>;
pub struct ConnectedEdgeSet_<'a> { // entity
    pub name: Label<'a>,
    pub ces_edges: Vec<Edge<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConnectedEdgeSet<'a> = Id<ConnectedEdgeSet_<'a>>;
pub struct ConnectedFaceSet_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConnectedFaceSet<'a> = Id<ConnectedFaceSet_<'a>>;
pub struct ConnectedFaceSubSet_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    pub parent_face_set: ConnectedFaceSet<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConnectedFaceSubSet<'a> = Id<ConnectedFaceSubSet_<'a>>;
pub struct ConstructiveGeometryRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConstructiveGeometryRepresentation<'a> = Id<ConstructiveGeometryRepresentation_<'a>>;
pub struct ConstructiveGeometryRepresentationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConstructiveGeometryRepresentationRelationship<'a> = Id<ConstructiveGeometryRepresentationRelationship_<'a>>;
pub struct ContactRatioRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContactRatioRepresentation<'a> = Id<ContactRatioRepresentation_<'a>>;
pub struct ContextDependentInvisibility_<'a> { // entity
    pub invisible_items: Vec<InvisibleItem<'a>>,
    pub presentation_context: InvisibilityContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentInvisibility<'a> = Id<ContextDependentInvisibility_<'a>>;
pub struct ContextDependentMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ContextDependentMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> ContextDependentMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct ContextDependentOverRidingStyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub over_ridden_style: StyledItem<'a>,
    pub style_context: Vec<StyleContextSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentOverRidingStyledItem<'a> = Id<ContextDependentOverRidingStyledItem_<'a>>;
pub struct ContextDependentShapeRepresentation_<'a> { // entity
    pub representation_relation: ShapeRepresentationRelationship<'a>,
    pub represented_product_relation: ProductDefinitionShape<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentShapeRepresentation<'a> = Id<ContextDependentShapeRepresentation_<'a>>;
pub struct ContextDependentUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentUnit<'a> = Id<ContextDependentUnit_<'a>>;
pub struct Contract_<'a> { // entity
    pub name: Label<'a>,
    pub purpose: Text<'a>,
    pub kind: ContractType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Contract<'a> = Id<Contract_<'a>>;
pub struct ContractAssignment_<'a> { // entity
    pub assigned_contract: Contract<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContractAssignment<'a> = Id<ContractAssignment_<'a>>;
pub enum ContractItem<'a> { // select
    DrawingRevision(DrawingRevision<'a>),
    ExecutedAction(ExecutedAction<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ContractItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<DrawingRevision<'a>>::parse, |r| ContractItem::DrawingRevision(r)),
            map(<ExecutedAction<'a>>::parse, |r| ContractItem::ExecutedAction(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| ContractItem::ProductDefinitionFormation(r)),
        ))(s)
    }
}
pub struct ContractType_<'a> { // entity
    pub description: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContractType<'a> = Id<ContractType_<'a>>;
pub struct ConversionBasedUnit_<'a> { // entity
    pub name: Label<'a>,
    pub conversion_factor: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConversionBasedUnit<'a> = Id<ConversionBasedUnit_<'a>>;
pub struct CoordinatedUniversalTimeOffset_<'a> { // entity
    pub hour_offset: i64,
    pub minute_offset: Option<i64>,
    pub sense: AheadOrBehind<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CoordinatedUniversalTimeOffset<'a> = Id<CoordinatedUniversalTimeOffset_<'a>>;
pub struct CosFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CosFunction<'a> = Id<CosFunction_<'a>>;
pub struct CountMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CountMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> CountMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub enum CsgPrimitive<'a> { // select
    Sphere(Sphere<'a>),
    Block(Block<'a>),
    RightAngularWedge(RightAngularWedge<'a>),
    Torus(Torus<'a>),
    RightCircularCone(RightCircularCone<'a>),
    RightCircularCylinder(RightCircularCylinder<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CsgPrimitive<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Sphere<'a>>::parse, |r| CsgPrimitive::Sphere(r)),
            map(<Block<'a>>::parse, |r| CsgPrimitive::Block(r)),
            map(<RightAngularWedge<'a>>::parse, |r| CsgPrimitive::RightAngularWedge(r)),
            map(<Torus<'a>>::parse, |r| CsgPrimitive::Torus(r)),
            map(<RightCircularCone<'a>>::parse, |r| CsgPrimitive::RightCircularCone(r)),
            map(<RightCircularCylinder<'a>>::parse, |r| CsgPrimitive::RightCircularCylinder(r)),
        ))(s)
    }
}
pub enum CsgSelect<'a> { // select
    BooleanResult(BooleanResult<'a>),
    CsgPrimitive(CsgPrimitive<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CsgSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<BooleanResult<'a>>::parse, |r| CsgSelect::BooleanResult(r)),
            map(<CsgPrimitive<'a>>::parse, |r| CsgSelect::CsgPrimitive(r)),
        ))(s)
    }
}
pub struct CsgShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CsgShapeRepresentation<'a> = Id<CsgShapeRepresentation_<'a>>;
pub struct CsgSolid_<'a> { // entity
    pub name: Label<'a>,
    pub tree_root_expression: CsgSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CsgSolid<'a> = Id<CsgSolid_<'a>>;
pub struct Curve_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Curve<'a> = Id<Curve_<'a>>;
pub struct CurveBoundedSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub boundaries: Vec<BoundaryCurve<'a>>,
    pub implicit_outer: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveBoundedSurface<'a> = Id<CurveBoundedSurface_<'a>>;
pub struct CurveDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveDimension<'a> = Id<CurveDimension_<'a>>;
pub enum CurveFontOrScaledCurveFontSelect<'a> { // select
    CurveStyleFontSelect(CurveStyleFontSelect<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CurveFontOrScaledCurveFontSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<CurveStyleFontSelect<'a>>::parse, |r| CurveFontOrScaledCurveFontSelect::CurveStyleFontSelect(r))(s)
    }
}
pub enum CurveOnSurface<'a> { // select
    Pcurve(Pcurve<'a>),
    SurfaceCurve(SurfaceCurve<'a>),
    CompositeCurveOnSurface(CompositeCurveOnSurface<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CurveOnSurface<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Pcurve<'a>>::parse, |r| CurveOnSurface::Pcurve(r)),
            map(<SurfaceCurve<'a>>::parse, |r| CurveOnSurface::SurfaceCurve(r)),
            map(<CompositeCurveOnSurface<'a>>::parse, |r| CurveOnSurface::CompositeCurveOnSurface(r)),
        ))(s)
    }
}
pub enum CurveOrRender<'a> { // select
    CurveStyle(CurveStyle<'a>),
    CurveStyleRendering(CurveStyleRendering<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CurveOrRender<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<CurveStyle<'a>>::parse, |r| CurveOrRender::CurveStyle(r)),
            map(<CurveStyleRendering<'a>>::parse, |r| CurveOrRender::CurveStyleRendering(r)),
        ))(s)
    }
}
pub struct CurveReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_curve: Curve<'a>,
    pub transformation: CartesianTransformationOperator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveReplica<'a> = Id<CurveReplica_<'a>>;
pub struct CurveStyle_<'a> { // entity
    pub name: Label<'a>,
    pub curve_font: CurveFontOrScaledCurveFontSelect<'a>,
    pub curve_width: SizeSelect<'a>,
    pub curve_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyle<'a> = Id<CurveStyle_<'a>>;
pub struct CurveStyleFont_<'a> { // entity
    pub name: Label<'a>,
    pub pattern_list: Vec<CurveStyleFontPattern<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyleFont<'a> = Id<CurveStyleFont_<'a>>;
pub struct CurveStyleFontPattern_<'a> { // entity
    pub visible_segment_length: PositiveLengthMeasure<'a>,
    pub invisible_segment_length: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyleFontPattern<'a> = Id<CurveStyleFontPattern_<'a>>;
pub enum CurveStyleFontSelect<'a> { // select
    CurveStyleFont(CurveStyleFont<'a>),
    PreDefinedCurveFont(PreDefinedCurveFont<'a>),
    ExternallyDefinedCurveFont(ExternallyDefinedCurveFont<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CurveStyleFontSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<CurveStyleFont<'a>>::parse, |r| CurveStyleFontSelect::CurveStyleFont(r)),
            map(<PreDefinedCurveFont<'a>>::parse, |r| CurveStyleFontSelect::PreDefinedCurveFont(r)),
            map(<ExternallyDefinedCurveFont<'a>>::parse, |r| CurveStyleFontSelect::ExternallyDefinedCurveFont(r)),
        ))(s)
    }
}
pub struct CurveStyleRendering_<'a> { // entity
    pub rendering_method: ShadingCurveMethod<'a>,
    pub rendering_properties: SurfaceRenderingProperties<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyleRendering<'a> = Id<CurveStyleRendering_<'a>>;
pub struct CurveSweptSolidShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveSweptSolidShapeRepresentation<'a> = Id<CurveSweptSolidShapeRepresentation_<'a>>;

pub struct CurveToleranceDeviation<'a>(pub PositiveLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for CurveToleranceDeviation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("CURVE_TOLERANCE_DEVIATION("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> CurveToleranceDeviation<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(PositiveLengthMeasure::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct CurveToleranceParameter<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CurveToleranceParameter<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> CurveToleranceParameter<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct CylindricalPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalPair<'a> = Id<CylindricalPair_<'a>>;
pub struct CylindricalPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_translation: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation: TranslationalRangeMeasure<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalPairRange<'a> = Id<CylindricalPairRange_<'a>>;
pub struct CylindricalPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_translation: LengthMeasure<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalPairValue<'a> = Id<CylindricalPairValue_<'a>>;
pub struct CylindricalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalSurface<'a> = Id<CylindricalSurface_<'a>>;
pub struct CylindricityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricityTolerance<'a> = Id<CylindricityTolerance_<'a>>;
pub struct DataEnvironment_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub elements: Vec<PropertyDefinitionRepresentation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DataEnvironment<'a> = Id<DataEnvironment_<'a>>;
pub struct Date_<'a> { // entity
    pub year_component: YearNumber<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Date<'a> = Id<Date_<'a>>;
pub struct DateAndTime_<'a> { // entity
    pub date_component: Date<'a>,
    pub time_component: LocalTime<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateAndTime<'a> = Id<DateAndTime_<'a>>;
pub struct DateAndTimeAssignment_<'a> { // entity
    pub assigned_date_and_time: DateAndTime<'a>,
    pub role: DateTimeRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateAndTimeAssignment<'a> = Id<DateAndTimeAssignment_<'a>>;
pub enum DateAndTimeItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    ActionRequestSolution(ActionRequestSolution<'a>),
    AlternateProductRelationship(AlternateProductRelationship<'a>),
    AppliedActionAssignment(AppliedActionAssignment<'a>),
    AppliedClassificationAssignment(AppliedClassificationAssignment<'a>),
    AppliedOrganizationAssignment(AppliedOrganizationAssignment<'a>),
    AppliedPersonAndOrganizationAssignment(AppliedPersonAndOrganizationAssignment<'a>),
    ApprovalPersonOrganization(ApprovalPersonOrganization<'a>),
    ApprovalStatus(ApprovalStatus<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    Certification(Certification<'a>),
    Class(Class<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment<'a>),
    Contract(Contract<'a>),
    DocumentFile(DocumentFile<'a>),
    DraughtingModel(DraughtingModel<'a>),
    DrawingRevision(DrawingRevision<'a>),
    Effectivity(Effectivity<'a>),
    EventOccurrence(EventOccurrence<'a>),
    ExecutedAction(ExecutedAction<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    OrganizationRelationship(OrganizationRelationship<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PersonAndOrganization(PersonAndOrganization<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    RequirementForActionResource(RequirementForActionResource<'a>),
    ResourceProperty(ResourceProperty<'a>),
    SecurityClassification(SecurityClassification<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DateAndTimeItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| DateAndTimeItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| DateAndTimeItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| DateAndTimeItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| DateAndTimeItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| DateAndTimeItem::ActionRelationship(r)),
            map(<ActionRequestSolution<'a>>::parse, |r| DateAndTimeItem::ActionRequestSolution(r)),
            map(<AlternateProductRelationship<'a>>::parse, |r| DateAndTimeItem::AlternateProductRelationship(r)),
            map(<AppliedActionAssignment<'a>>::parse, |r| DateAndTimeItem::AppliedActionAssignment(r)),
            map(<AppliedClassificationAssignment<'a>>::parse, |r| DateAndTimeItem::AppliedClassificationAssignment(r)),
            map(<AppliedOrganizationAssignment<'a>>::parse, |r| DateAndTimeItem::AppliedOrganizationAssignment(r)),
            map(<AppliedPersonAndOrganizationAssignment<'a>>::parse, |r| DateAndTimeItem::AppliedPersonAndOrganizationAssignment(r)),
            map(<ApprovalPersonOrganization<'a>>::parse, |r| DateAndTimeItem::ApprovalPersonOrganization(r)),
            map(<ApprovalStatus<'a>>::parse, |r| DateAndTimeItem::ApprovalStatus(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| DateAndTimeItem::AssemblyComponentUsageSubstitute(r)),
            map(<Certification<'a>>::parse, |r| DateAndTimeItem::Certification(r)),
            map(<Class<'a>>::parse, |r| DateAndTimeItem::Class(r)),
            map(<ClassSystem<'a>>::parse, |r| DateAndTimeItem::ClassSystem(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| DateAndTimeItem::ConfigurationDesign(r)),
            map(<ConfigurationItem<'a>>::parse, |r| DateAndTimeItem::ConfigurationItem(r)),
        alt((
            map(<ConfiguredEffectivityAssignment<'a>>::parse, |r| DateAndTimeItem::ConfiguredEffectivityAssignment(r)),
            map(<Contract<'a>>::parse, |r| DateAndTimeItem::Contract(r)),
            map(<DocumentFile<'a>>::parse, |r| DateAndTimeItem::DocumentFile(r)),
            map(<DraughtingModel<'a>>::parse, |r| DateAndTimeItem::DraughtingModel(r)),
            map(<DrawingRevision<'a>>::parse, |r| DateAndTimeItem::DrawingRevision(r)),
            map(<Effectivity<'a>>::parse, |r| DateAndTimeItem::Effectivity(r)),
            map(<EventOccurrence<'a>>::parse, |r| DateAndTimeItem::EventOccurrence(r)),
            map(<ExecutedAction<'a>>::parse, |r| DateAndTimeItem::ExecutedAction(r)),
            map(<GeneralProperty<'a>>::parse, |r| DateAndTimeItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| DateAndTimeItem::MaterialDesignation(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| DateAndTimeItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<OrganizationRelationship<'a>>::parse, |r| DateAndTimeItem::OrganizationRelationship(r)),
            map(<OrganizationalProject<'a>>::parse, |r| DateAndTimeItem::OrganizationalProject(r)),
            map(<PersonAndOrganization<'a>>::parse, |r| DateAndTimeItem::PersonAndOrganization(r)),
            map(<PresentationArea<'a>>::parse, |r| DateAndTimeItem::PresentationArea(r)),
            map(<Product<'a>>::parse, |r| DateAndTimeItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| DateAndTimeItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| DateAndTimeItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| DateAndTimeItem::ProductConceptFeatureAssociation(r)),
        alt((
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| DateAndTimeItem::ProductConceptFeatureCategory(r)),
            map(<ProductConceptFeatureCategoryUsage<'a>>::parse, |r| DateAndTimeItem::ProductConceptFeatureCategoryUsage(r)),
            map(<ProductDefinition<'a>>::parse, |r| DateAndTimeItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| DateAndTimeItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| DateAndTimeItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| DateAndTimeItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| DateAndTimeItem::ProductDefinitionSubstitute(r)),
            map(<PropertyDefinition<'a>>::parse, |r| DateAndTimeItem::PropertyDefinition(r)),
            map(<RequirementForActionResource<'a>>::parse, |r| DateAndTimeItem::RequirementForActionResource(r)),
            map(<ResourceProperty<'a>>::parse, |r| DateAndTimeItem::ResourceProperty(r)),
            map(<SecurityClassification<'a>>::parse, |r| DateAndTimeItem::SecurityClassification(r)),
            map(<SecurityClassificationLevel<'a>>::parse, |r| DateAndTimeItem::SecurityClassificationLevel(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| DateAndTimeItem::ShapeRepresentation(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| DateAndTimeItem::VersionedActionRequest(r)),
        ))))))(s)
    }
}
pub struct DateAssignment_<'a> { // entity
    pub assigned_date: Date<'a>,
    pub role: DateRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateAssignment<'a> = Id<DateAssignment_<'a>>;
pub enum DateItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    ActionRequestSolution(ActionRequestSolution<'a>),
    AlternateProductRelationship(AlternateProductRelationship<'a>),
    AppliedActionAssignment(AppliedActionAssignment<'a>),
    AppliedClassificationAssignment(AppliedClassificationAssignment<'a>),
    AppliedOrganizationAssignment(AppliedOrganizationAssignment<'a>),
    AppliedPersonAndOrganizationAssignment(AppliedPersonAndOrganizationAssignment<'a>),
    ApprovalPersonOrganization(ApprovalPersonOrganization<'a>),
    ApprovalStatus(ApprovalStatus<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    Certification(Certification<'a>),
    Class(Class<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment<'a>),
    Contract(Contract<'a>),
    DocumentFile(DocumentFile<'a>),
    DraughtingModel(DraughtingModel<'a>),
    DrawingRevision(DrawingRevision<'a>),
    Effectivity(Effectivity<'a>),
    EventOccurrence(EventOccurrence<'a>),
    ExecutedAction(ExecutedAction<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    OrganizationRelationship(OrganizationRelationship<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PersonAndOrganization(PersonAndOrganization<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    RequirementForActionResource(RequirementForActionResource<'a>),
    ResourceProperty(ResourceProperty<'a>),
    SecurityClassification(SecurityClassification<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DateItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| DateItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| DateItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| DateItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| DateItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| DateItem::ActionRelationship(r)),
            map(<ActionRequestSolution<'a>>::parse, |r| DateItem::ActionRequestSolution(r)),
            map(<AlternateProductRelationship<'a>>::parse, |r| DateItem::AlternateProductRelationship(r)),
            map(<AppliedActionAssignment<'a>>::parse, |r| DateItem::AppliedActionAssignment(r)),
            map(<AppliedClassificationAssignment<'a>>::parse, |r| DateItem::AppliedClassificationAssignment(r)),
            map(<AppliedOrganizationAssignment<'a>>::parse, |r| DateItem::AppliedOrganizationAssignment(r)),
            map(<AppliedPersonAndOrganizationAssignment<'a>>::parse, |r| DateItem::AppliedPersonAndOrganizationAssignment(r)),
            map(<ApprovalPersonOrganization<'a>>::parse, |r| DateItem::ApprovalPersonOrganization(r)),
            map(<ApprovalStatus<'a>>::parse, |r| DateItem::ApprovalStatus(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| DateItem::AssemblyComponentUsageSubstitute(r)),
            map(<Certification<'a>>::parse, |r| DateItem::Certification(r)),
            map(<Class<'a>>::parse, |r| DateItem::Class(r)),
            map(<ClassSystem<'a>>::parse, |r| DateItem::ClassSystem(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| DateItem::ConfigurationDesign(r)),
            map(<ConfigurationItem<'a>>::parse, |r| DateItem::ConfigurationItem(r)),
        alt((
            map(<ConfiguredEffectivityAssignment<'a>>::parse, |r| DateItem::ConfiguredEffectivityAssignment(r)),
            map(<Contract<'a>>::parse, |r| DateItem::Contract(r)),
            map(<DocumentFile<'a>>::parse, |r| DateItem::DocumentFile(r)),
            map(<DraughtingModel<'a>>::parse, |r| DateItem::DraughtingModel(r)),
            map(<DrawingRevision<'a>>::parse, |r| DateItem::DrawingRevision(r)),
            map(<Effectivity<'a>>::parse, |r| DateItem::Effectivity(r)),
            map(<EventOccurrence<'a>>::parse, |r| DateItem::EventOccurrence(r)),
            map(<ExecutedAction<'a>>::parse, |r| DateItem::ExecutedAction(r)),
            map(<GeneralProperty<'a>>::parse, |r| DateItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| DateItem::MaterialDesignation(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| DateItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<OrganizationRelationship<'a>>::parse, |r| DateItem::OrganizationRelationship(r)),
            map(<OrganizationalProject<'a>>::parse, |r| DateItem::OrganizationalProject(r)),
            map(<PersonAndOrganization<'a>>::parse, |r| DateItem::PersonAndOrganization(r)),
            map(<PresentationArea<'a>>::parse, |r| DateItem::PresentationArea(r)),
            map(<Product<'a>>::parse, |r| DateItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| DateItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| DateItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| DateItem::ProductConceptFeatureAssociation(r)),
        alt((
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| DateItem::ProductConceptFeatureCategory(r)),
            map(<ProductConceptFeatureCategoryUsage<'a>>::parse, |r| DateItem::ProductConceptFeatureCategoryUsage(r)),
            map(<ProductDefinition<'a>>::parse, |r| DateItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| DateItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| DateItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| DateItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| DateItem::ProductDefinitionSubstitute(r)),
            map(<PropertyDefinition<'a>>::parse, |r| DateItem::PropertyDefinition(r)),
            map(<RequirementForActionResource<'a>>::parse, |r| DateItem::RequirementForActionResource(r)),
            map(<ResourceProperty<'a>>::parse, |r| DateItem::ResourceProperty(r)),
            map(<SecurityClassification<'a>>::parse, |r| DateItem::SecurityClassification(r)),
            map(<SecurityClassificationLevel<'a>>::parse, |r| DateItem::SecurityClassificationLevel(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| DateItem::ShapeRepresentation(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| DateItem::VersionedActionRequest(r)),
        ))))))(s)
    }
}
pub struct DateRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateRole<'a> = Id<DateRole_<'a>>;
pub enum DateTimeOrEventOccurrence<'a> { // select
    DateTimeSelect(DateTimeSelect<'a>),
    EventOccurrence(EventOccurrence<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DateTimeOrEventOccurrence<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<DateTimeSelect<'a>>::parse, |r| DateTimeOrEventOccurrence::DateTimeSelect(r)),
            map(<EventOccurrence<'a>>::parse, |r| DateTimeOrEventOccurrence::EventOccurrence(r)),
        ))(s)
    }
}
pub struct DateTimeRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateTimeRole<'a> = Id<DateTimeRole_<'a>>;
pub enum DateTimeSelect<'a> { // select
    Date(Date<'a>),
    DateAndTime(DateAndTime<'a>),
    LocalTime(LocalTime<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DateTimeSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Date<'a>>::parse, |r| DateTimeSelect::Date(r)),
            map(<DateAndTime<'a>>::parse, |r| DateTimeSelect::DateAndTime(r)),
            map(<LocalTime<'a>>::parse, |r| DateTimeSelect::LocalTime(r)),
        ))(s)
    }
}
pub struct DatedEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_end_date: Option<DateTimeOrEventOccurrence<'a>>,
    pub effectivity_start_date: DateTimeOrEventOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatedEffectivity<'a> = Id<DatedEffectivity_<'a>>;
pub struct Datum_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Datum<'a> = Id<Datum_<'a>>;
pub struct DatumFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumFeature<'a> = Id<DatumFeature_<'a>>;
pub struct DatumFeatureCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumFeatureCallout<'a> = Id<DatumFeatureCallout_<'a>>;
pub struct DatumReference_<'a> { // entity
    pub precedence: i64,
    pub referenced_datum: Datum<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumReference<'a> = Id<DatumReference_<'a>>;
pub struct DatumTarget_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    pub target_id: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumTarget<'a> = Id<DatumTarget_<'a>>;
pub struct DatumTargetCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumTargetCallout<'a> = Id<DatumTargetCallout_<'a>>;
pub struct DayInMonthNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DayInMonthNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> DayInMonthNumber<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct DefaultToleranceTable_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefaultToleranceTable<'a> = Id<DefaultToleranceTable_<'a>>;
pub struct DefaultToleranceTableCell_<'a> { // entity
    pub name: Label<'a>,
    pub item_element: CompoundItemDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefaultToleranceTableCell<'a> = Id<DefaultToleranceTableCell_<'a>>;
pub struct DefinedCharacterGlyph_<'a> { // entity
    pub name: Label<'a>,
    pub definition: DefinedGlyphSelect<'a>,
    pub placement: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinedCharacterGlyph<'a> = Id<DefinedCharacterGlyph_<'a>>;
pub struct DefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinedFunction<'a> = Id<DefinedFunction_<'a>>;
pub enum DefinedGlyphSelect<'a> { // select
    ExternallyDefinedCharacterGlyph(ExternallyDefinedCharacterGlyph<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DefinedGlyphSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<ExternallyDefinedCharacterGlyph<'a>>::parse, |r| DefinedGlyphSelect::ExternallyDefinedCharacterGlyph(r))(s)
    }
}
pub struct DefinedSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub definition: DefinedSymbolSelect<'a>,
    pub target: SymbolTarget<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinedSymbol<'a> = Id<DefinedSymbol_<'a>>;
pub enum DefinedSymbolSelect<'a> { // select
    PreDefinedSymbol(PreDefinedSymbol<'a>),
    ExternallyDefinedSymbol(ExternallyDefinedSymbol<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DefinedSymbolSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PreDefinedSymbol<'a>>::parse, |r| DefinedSymbolSelect::PreDefinedSymbol(r)),
            map(<ExternallyDefinedSymbol<'a>>::parse, |r| DefinedSymbolSelect::ExternallyDefinedSymbol(r)),
        ))(s)
    }
}
pub struct DefinitionalRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinitionalRepresentation<'a> = Id<DefinitionalRepresentation_<'a>>;
pub struct DegeneratePcurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DegeneratePcurve<'a> = Id<DegeneratePcurve_<'a>>;
pub struct DegenerateToroidalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub major_radius: PositiveLengthMeasure<'a>,
    pub minor_radius: PositiveLengthMeasure<'a>,
    pub select_outer: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DegenerateToroidalSurface<'a> = Id<DegenerateToroidalSurface_<'a>>;
pub enum DerivedPropertySelect<'a> { // select
    PropertyDefinition(PropertyDefinition<'a>),
    ActionProperty(ActionProperty<'a>),
    ResourceProperty(ResourceProperty<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DerivedPropertySelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PropertyDefinition<'a>>::parse, |r| DerivedPropertySelect::PropertyDefinition(r)),
            map(<ActionProperty<'a>>::parse, |r| DerivedPropertySelect::ActionProperty(r)),
            map(<ResourceProperty<'a>>::parse, |r| DerivedPropertySelect::ResourceProperty(r)),
        ))(s)
    }
}
pub struct DerivedShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedShapeAspect<'a> = Id<DerivedShapeAspect_<'a>>;
pub struct DerivedUnit_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedUnit<'a> = Id<DerivedUnit_<'a>>;
pub struct DerivedUnitElement_<'a> { // entity
    pub unit: NamedUnit<'a>,
    pub exponent: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedUnitElement<'a> = Id<DerivedUnitElement_<'a>>;
pub struct DerivedUnitVariable_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedUnitVariable<'a> = Id<DerivedUnitVariable_<'a>>;
pub struct DescriptionAttribute_<'a> { // entity
    pub attribute_value: Text<'a>,
    pub described_item: DescriptionAttributeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DescriptionAttribute<'a> = Id<DescriptionAttribute_<'a>>;
pub enum DescriptionAttributeSelect<'a> { // select
    ActionRequestSolution(ActionRequestSolution<'a>),
    ApplicationContext(ApplicationContext<'a>),
    ApprovalRole(ApprovalRole<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    DateRole(DateRole<'a>),
    DateTimeRole(DateTimeRole<'a>),
    ContextDependentShapeRepresentation(ContextDependentShapeRepresentation<'a>),
    Effectivity(Effectivity<'a>),
    ExternalSource(ExternalSource<'a>),
    OrganizationRole(OrganizationRole<'a>),
    PersonAndOrganizationRole(PersonAndOrganizationRole<'a>),
    PersonAndOrganization(PersonAndOrganization<'a>),
    PropertyDefinitionRepresentation(PropertyDefinitionRepresentation<'a>),
    Representation(Representation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DescriptionAttributeSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ActionRequestSolution<'a>>::parse, |r| DescriptionAttributeSelect::ActionRequestSolution(r)),
            map(<ApplicationContext<'a>>::parse, |r| DescriptionAttributeSelect::ApplicationContext(r)),
            map(<ApprovalRole<'a>>::parse, |r| DescriptionAttributeSelect::ApprovalRole(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| DescriptionAttributeSelect::ConfigurationDesign(r)),
            map(<DateRole<'a>>::parse, |r| DescriptionAttributeSelect::DateRole(r)),
            map(<DateTimeRole<'a>>::parse, |r| DescriptionAttributeSelect::DateTimeRole(r)),
            map(<ContextDependentShapeRepresentation<'a>>::parse, |r| DescriptionAttributeSelect::ContextDependentShapeRepresentation(r)),
            map(<Effectivity<'a>>::parse, |r| DescriptionAttributeSelect::Effectivity(r)),
            map(<ExternalSource<'a>>::parse, |r| DescriptionAttributeSelect::ExternalSource(r)),
            map(<OrganizationRole<'a>>::parse, |r| DescriptionAttributeSelect::OrganizationRole(r)),
            map(<PersonAndOrganizationRole<'a>>::parse, |r| DescriptionAttributeSelect::PersonAndOrganizationRole(r)),
            map(<PersonAndOrganization<'a>>::parse, |r| DescriptionAttributeSelect::PersonAndOrganization(r)),
            map(<PropertyDefinitionRepresentation<'a>>::parse, |r| DescriptionAttributeSelect::PropertyDefinitionRepresentation(r)),
            map(<Representation<'a>>::parse, |r| DescriptionAttributeSelect::Representation(r)),
        ))(s)
    }
}
pub struct DescriptiveMeasure<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DescriptiveMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> DescriptiveMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct DescriptiveRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DescriptiveRepresentationItem<'a> = Id<DescriptiveRepresentationItem_<'a>>;
pub struct DiameterDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DiameterDimension<'a> = Id<DiameterDimension_<'a>>;
pub struct DimensionCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCallout<'a> = Id<DimensionCallout_<'a>>;
pub struct DimensionCalloutComponentRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCalloutComponentRelationship<'a> = Id<DimensionCalloutComponentRelationship_<'a>>;
pub struct DimensionCalloutRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCalloutRelationship<'a> = Id<DimensionCalloutRelationship_<'a>>;
pub struct DimensionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DimensionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> DimensionCount<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct DimensionCurve_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCurve<'a> = Id<DimensionCurve_<'a>>;
pub struct DimensionCurveDirectedCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCurveDirectedCallout<'a> = Id<DimensionCurveDirectedCallout_<'a>>;
pub struct DimensionCurveTerminator_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub annotated_curve: AnnotationCurveOccurrence<'a>,
    pub role: DimensionExtentUsage<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCurveTerminator<'a> = Id<DimensionCurveTerminator_<'a>>;
pub enum DimensionExtentUsage<'a> { // enum
    Origin,
    Target,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for DimensionExtentUsage<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use DimensionExtentUsage::*;
        alt((
            map(tag(".ORIGIN."), |_| Origin),
            map(tag(".TARGET."), |_| Target),
        ))(s)
    }
}
pub struct DimensionPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionPair<'a> = Id<DimensionPair_<'a>>;
pub struct DimensionRelatedToleranceZoneElement_<'a> { // entity
    pub related_dimension: DimensionalLocation<'a>,
    pub related_element: ToleranceZoneDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionRelatedToleranceZoneElement<'a> = Id<DimensionRelatedToleranceZoneElement_<'a>>;
pub struct DimensionTextAssociativity_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionTextAssociativity<'a> = Id<DimensionTextAssociativity_<'a>>;
pub enum DimensionalCharacteristic<'a> { // select
    DimensionalLocation(DimensionalLocation<'a>),
    DimensionalSize(DimensionalSize<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DimensionalCharacteristic<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<DimensionalLocation<'a>>::parse, |r| DimensionalCharacteristic::DimensionalLocation(r)),
            map(<DimensionalSize<'a>>::parse, |r| DimensionalCharacteristic::DimensionalSize(r)),
        ))(s)
    }
}
pub struct DimensionalCharacteristicRepresentation_<'a> { // entity
    pub dimension: DimensionalCharacteristic<'a>,
    pub representation: ShapeDimensionRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalCharacteristicRepresentation<'a> = Id<DimensionalCharacteristicRepresentation_<'a>>;
pub struct DimensionalExponents_<'a> { // entity
    pub length_exponent: f64,
    pub mass_exponent: f64,
    pub time_exponent: f64,
    pub electric_current_exponent: f64,
    pub thermodynamic_temperature_exponent: f64,
    pub amount_of_substance_exponent: f64,
    pub luminous_intensity_exponent: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalExponents<'a> = Id<DimensionalExponents_<'a>>;
pub struct DimensionalLocation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalLocation<'a> = Id<DimensionalLocation_<'a>>;
pub struct DimensionalLocationWithPath_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    pub path: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalLocationWithPath<'a> = Id<DimensionalLocationWithPath_<'a>>;
pub struct DimensionalSize_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalSize<'a> = Id<DimensionalSize_<'a>>;
pub struct DimensionalSizeWithPath_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    pub path: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalSizeWithPath<'a> = Id<DimensionalSizeWithPath_<'a>>;
pub struct DirectedAction_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub directive: ActionDirective<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectedAction<'a> = Id<DirectedAction_<'a>>;
pub struct DirectedAngle_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectedAngle<'a> = Id<DirectedAngle_<'a>>;
pub struct DirectedDimensionalLocation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectedDimensionalLocation<'a> = Id<DirectedDimensionalLocation_<'a>>;
pub struct Direction_<'a> { // entity
    pub name: Label<'a>,
    pub direction_ratios: Vec<f64>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Direction<'a> = Id<Direction_<'a>>;
pub enum DirectionCountSelect<'a> { // select
    UDirectionCount(UDirectionCount<'a>),
    VDirectionCount(VDirectionCount<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DirectionCountSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<UDirectionCount<'a>>::parse, |r| DirectionCountSelect::UDirectionCount(r)),
            map(<VDirectionCount<'a>>::parse, |r| DirectionCountSelect::VDirectionCount(r)),
        ))(s)
    }
}
pub struct DirectionShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectionShapeRepresentation<'a> = Id<DirectionShapeRepresentation_<'a>>;
pub struct DivExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DivExpression<'a> = Id<DivExpression_<'a>>;
pub struct Document_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub kind: DocumentType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Document<'a> = Id<Document_<'a>>;
#[allow(non_snake_case)]
pub struct DocumentFile_<'a> { // entity
    pub id: Identifier<'a>,
    pub document__name: Label<'a>,
    pub document__description: Option<Text<'a>>,
    pub kind: DocumentType<'a>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentFile<'a> = Id<DocumentFile_<'a>>;
pub struct DocumentProductAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_document: Document<'a>,
    pub related_product: ProductOrFormationOrDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentProductAssociation<'a> = Id<DocumentProductAssociation_<'a>>;
pub struct DocumentProductEquivalence_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_document: Document<'a>,
    pub related_product: ProductOrFormationOrDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentProductEquivalence<'a> = Id<DocumentProductEquivalence_<'a>>;
pub struct DocumentReference_<'a> { // entity
    pub assigned_document: Document<'a>,
    pub source: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentReference<'a> = Id<DocumentReference_<'a>>;
pub enum DocumentReferenceItem<'a> { // select
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionRelationship(ActionRelationship<'a>),
    AppliedActionAssignment(AppliedActionAssignment<'a>),
    Approval(Approval<'a>),
    Certification(Certification<'a>),
    Class(Class<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    Contract(Contract<'a>),
    DescriptiveRepresentationItem(DescriptiveRepresentationItem<'a>),
    ExecutedAction(ExecutedAction<'a>),
    ExternallyDefinedDimensionDefinition(ExternallyDefinedDimensionDefinition<'a>),
    FeatureDefinition(FeatureDefinition<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    Organization(Organization<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    Person(Person<'a>),
    PresentationArea(PresentationArea<'a>),
    ProcessPlan(ProcessPlan<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionProcess(ProductDefinitionProcess<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    ProductRelatedProductCategory(ProductRelatedProductCategory<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    Representation(Representation<'a>),
    ResourceRequirementType(ResourceRequirementType<'a>),
    Retention(Retention<'a>),
    SecurityClassification(SecurityClassification<'a>),
    ShapeAspect(ShapeAspect<'a>),
    ShapeAspectRelationship(ShapeAspectRelationship<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DocumentReferenceItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ActionDirective<'a>>::parse, |r| DocumentReferenceItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| DocumentReferenceItem::ActionMethod(r)),
            map(<ActionRelationship<'a>>::parse, |r| DocumentReferenceItem::ActionRelationship(r)),
            map(<AppliedActionAssignment<'a>>::parse, |r| DocumentReferenceItem::AppliedActionAssignment(r)),
            map(<Approval<'a>>::parse, |r| DocumentReferenceItem::Approval(r)),
            map(<Certification<'a>>::parse, |r| DocumentReferenceItem::Certification(r)),
            map(<Class<'a>>::parse, |r| DocumentReferenceItem::Class(r)),
            map(<ClassSystem<'a>>::parse, |r| DocumentReferenceItem::ClassSystem(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| DocumentReferenceItem::ConfigurationDesign(r)),
            map(<ConfigurationItem<'a>>::parse, |r| DocumentReferenceItem::ConfigurationItem(r)),
            map(<Contract<'a>>::parse, |r| DocumentReferenceItem::Contract(r)),
            map(<DescriptiveRepresentationItem<'a>>::parse, |r| DocumentReferenceItem::DescriptiveRepresentationItem(r)),
            map(<ExecutedAction<'a>>::parse, |r| DocumentReferenceItem::ExecutedAction(r)),
            map(<ExternallyDefinedDimensionDefinition<'a>>::parse, |r| DocumentReferenceItem::ExternallyDefinedDimensionDefinition(r)),
            map(<FeatureDefinition<'a>>::parse, |r| DocumentReferenceItem::FeatureDefinition(r)),
            map(<GeneralProperty<'a>>::parse, |r| DocumentReferenceItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| DocumentReferenceItem::MaterialDesignation(r)),
            map(<Organization<'a>>::parse, |r| DocumentReferenceItem::Organization(r)),
            map(<OrganizationalProject<'a>>::parse, |r| DocumentReferenceItem::OrganizationalProject(r)),
        alt((
            map(<Person<'a>>::parse, |r| DocumentReferenceItem::Person(r)),
            map(<PresentationArea<'a>>::parse, |r| DocumentReferenceItem::PresentationArea(r)),
            map(<ProcessPlan<'a>>::parse, |r| DocumentReferenceItem::ProcessPlan(r)),
            map(<Product<'a>>::parse, |r| DocumentReferenceItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| DocumentReferenceItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| DocumentReferenceItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| DocumentReferenceItem::ProductConceptFeatureCategory(r)),
            map(<ProductDefinition<'a>>::parse, |r| DocumentReferenceItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| DocumentReferenceItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| DocumentReferenceItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionProcess<'a>>::parse, |r| DocumentReferenceItem::ProductDefinitionProcess(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| DocumentReferenceItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| DocumentReferenceItem::ProductDefinitionSubstitute(r)),
            map(<ProductRelatedProductCategory<'a>>::parse, |r| DocumentReferenceItem::ProductRelatedProductCategory(r)),
            map(<PropertyDefinition<'a>>::parse, |r| DocumentReferenceItem::PropertyDefinition(r)),
            map(<Representation<'a>>::parse, |r| DocumentReferenceItem::Representation(r)),
            map(<ResourceRequirementType<'a>>::parse, |r| DocumentReferenceItem::ResourceRequirementType(r)),
            map(<Retention<'a>>::parse, |r| DocumentReferenceItem::Retention(r)),
            map(<SecurityClassification<'a>>::parse, |r| DocumentReferenceItem::SecurityClassification(r)),
        alt((
            map(<ShapeAspect<'a>>::parse, |r| DocumentReferenceItem::ShapeAspect(r)),
            map(<ShapeAspectRelationship<'a>>::parse, |r| DocumentReferenceItem::ShapeAspectRelationship(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| DocumentReferenceItem::VersionedActionRequest(r)),
        ))))))(s)
    }
}
pub struct DocumentRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_document: Document<'a>,
    pub related_document: Document<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentRelationship<'a> = Id<DocumentRelationship_<'a>>;
pub struct DocumentRepresentationType_<'a> { // entity
    pub name: Label<'a>,
    pub represented_document: Document<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentRepresentationType<'a> = Id<DocumentRepresentationType_<'a>>;
pub struct DocumentType_<'a> { // entity
    pub product_data_type: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentType<'a> = Id<DocumentType_<'a>>;
pub struct DocumentUsageConstraint_<'a> { // entity
    pub source: Document<'a>,
    pub subject_element: Label<'a>,
    pub subject_element_value: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentUsageConstraint<'a> = Id<DocumentUsageConstraint_<'a>>;
pub struct DocumentUsageConstraintAssignment_<'a> { // entity
    pub assigned_document_usage: DocumentUsageConstraint<'a>,
    pub role: DocumentUsageRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentUsageConstraintAssignment<'a> = Id<DocumentUsageConstraintAssignment_<'a>>;
pub struct DocumentUsageRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentUsageRole<'a> = Id<DocumentUsageRole_<'a>>;
pub struct DraughtingAnnotationOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingAnnotationOccurrence<'a> = Id<DraughtingAnnotationOccurrence_<'a>>;
pub struct DraughtingCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingCallout<'a> = Id<DraughtingCallout_<'a>>;
pub enum DraughtingCalloutElement<'a> { // select
    AnnotationTextOccurrence(AnnotationTextOccurrence<'a>),
    AnnotationSymbolOccurrence(AnnotationSymbolOccurrence<'a>),
    AnnotationCurveOccurrence(AnnotationCurveOccurrence<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DraughtingCalloutElement<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<AnnotationTextOccurrence<'a>>::parse, |r| DraughtingCalloutElement::AnnotationTextOccurrence(r)),
            map(<AnnotationSymbolOccurrence<'a>>::parse, |r| DraughtingCalloutElement::AnnotationSymbolOccurrence(r)),
            map(<AnnotationCurveOccurrence<'a>>::parse, |r| DraughtingCalloutElement::AnnotationCurveOccurrence(r)),
        ))(s)
    }
}
pub struct DraughtingCalloutRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingCalloutRelationship<'a> = Id<DraughtingCalloutRelationship_<'a>>;
pub struct DraughtingElements_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingElements<'a> = Id<DraughtingElements_<'a>>;
pub struct DraughtingModel_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingModel<'a> = Id<DraughtingModel_<'a>>;
pub struct DraughtingModelItemAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub identified_item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingModelItemAssociation<'a> = Id<DraughtingModelItemAssociation_<'a>>;
pub enum DraughtingModelItemAssociationSelect<'a> { // select
    AnnotationOccurrence(AnnotationOccurrence<'a>),
    DraughtingCallout(DraughtingCallout<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DraughtingModelItemAssociationSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<AnnotationOccurrence<'a>>::parse, |r| DraughtingModelItemAssociationSelect::AnnotationOccurrence(r)),
            map(<DraughtingCallout<'a>>::parse, |r| DraughtingModelItemAssociationSelect::DraughtingCallout(r)),
        ))(s)
    }
}
pub struct DraughtingPreDefinedColour_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingPreDefinedColour<'a> = Id<DraughtingPreDefinedColour_<'a>>;
pub struct DraughtingPreDefinedCurveFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingPreDefinedCurveFont<'a> = Id<DraughtingPreDefinedCurveFont_<'a>>;
pub struct DraughtingPreDefinedTextFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingPreDefinedTextFont<'a> = Id<DraughtingPreDefinedTextFont_<'a>>;
pub struct DraughtingSpecificationReference_<'a> { // entity
    pub assigned_document: Document<'a>,
    pub source: Label<'a>,
    pub specified_items: Vec<SpecifiedItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingSpecificationReference<'a> = Id<DraughtingSpecificationReference_<'a>>;
pub struct DraughtingSubfigureRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingSubfigureRepresentation<'a> = Id<DraughtingSubfigureRepresentation_<'a>>;
pub struct DraughtingSymbolRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingSymbolRepresentation<'a> = Id<DraughtingSymbolRepresentation_<'a>>;
pub struct DraughtingTextLiteralWithDelineation_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub delineation: TextDelineation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingTextLiteralWithDelineation<'a> = Id<DraughtingTextLiteralWithDelineation_<'a>>;
pub struct DraughtingTitle_<'a> { // entity
    pub items: Vec<DraughtingTitledItem<'a>>,
    pub language: Label<'a>,
    pub contents: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingTitle<'a> = Id<DraughtingTitle_<'a>>;
pub enum DraughtingTitledItem<'a> { // select
    DrawingRevision(DrawingRevision<'a>),
    DrawingSheetRevision(DrawingSheetRevision<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DraughtingTitledItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<DrawingRevision<'a>>::parse, |r| DraughtingTitledItem::DrawingRevision(r)),
            map(<DrawingSheetRevision<'a>>::parse, |r| DraughtingTitledItem::DrawingSheetRevision(r)),
        ))(s)
    }
}
pub struct DrawingDefinition_<'a> { // entity
    pub drawing_number: Identifier<'a>,
    pub drawing_type: Option<Label<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingDefinition<'a> = Id<DrawingDefinition_<'a>>;
pub struct DrawingRevision_<'a> { // entity
    pub revision_identifier: Identifier<'a>,
    pub drawing_identifier: DrawingDefinition<'a>,
    pub intended_scale: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingRevision<'a> = Id<DrawingRevision_<'a>>;
pub struct DrawingRevisionSequence_<'a> { // entity
    pub predecessor: DrawingRevision<'a>,
    pub successor: DrawingRevision<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingRevisionSequence<'a> = Id<DrawingRevisionSequence_<'a>>;
pub struct DrawingSheetLayout_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingSheetLayout<'a> = Id<DrawingSheetLayout_<'a>>;
pub struct DrawingSheetRevision_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    pub revision_identifier: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingSheetRevision<'a> = Id<DrawingSheetRevision_<'a>>;
pub struct DrawingSheetRevisionUsage_<'a> { // entity
    pub area: PresentationArea<'a>,
    pub in_set: PresentationSet<'a>,
    pub sheet_number: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingSheetRevisionUsage<'a> = Id<DrawingSheetRevisionUsage_<'a>>;
pub struct Edge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_start: Vertex<'a>,
    pub edge_end: Vertex<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Edge<'a> = Id<Edge_<'a>>;
pub struct EdgeBasedWireframeModel_<'a> { // entity
    pub name: Label<'a>,
    pub ebwm_boundary: Vec<ConnectedEdgeSet<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeBasedWireframeModel<'a> = Id<EdgeBasedWireframeModel_<'a>>;
pub struct EdgeBasedWireframeShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeBasedWireframeShapeRepresentation<'a> = Id<EdgeBasedWireframeShapeRepresentation_<'a>>;
pub struct EdgeCurve_<'a> { // entity
    pub name: Label<'a>,
    pub edge_start: Vertex<'a>,
    pub edge_end: Vertex<'a>,
    pub edge_geometry: Curve<'a>,
    pub same_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeCurve<'a> = Id<EdgeCurve_<'a>>;
pub struct EdgeLoop_<'a> { // entity
    pub name: Label<'a>,
    pub edge_list: Vec<OrientedEdge<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeLoop<'a> = Id<EdgeLoop_<'a>>;
pub struct EdgeRound_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeRound<'a> = Id<EdgeRound_<'a>>;
pub struct Effectivity_<'a> { // entity
    pub id: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Effectivity<'a> = Id<Effectivity_<'a>>;
pub struct EffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityAssignment<'a> = Id<EffectivityAssignment_<'a>>;
pub struct EffectivityContextAssignment_<'a> { // entity
    pub assigned_effectivity_assignment: EffectivityAssignment<'a>,
    pub role: EffectivityContextRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityContextAssignment<'a> = Id<EffectivityContextAssignment_<'a>>;
pub struct EffectivityContextRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityContextRole<'a> = Id<EffectivityContextRole_<'a>>;
pub enum EffectivityItem<'a> { // select
    Action(Action<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionMethodRelationship(ActionMethodRelationship<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    Class(Class<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment<'a>),
    DocumentFile(DocumentFile<'a>),
    DraughtingModel(DraughtingModel<'a>),
    DrawingRevision(DrawingRevision<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    RequirementForActionResource(RequirementForActionResource<'a>),
    ResourceProperty(ResourceProperty<'a>),
    SecurityClassification(SecurityClassification<'a>),
    ShapeAspect(ShapeAspect<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for EffectivityItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| EffectivityItem::Action(r)),
            map(<ActionMethod<'a>>::parse, |r| EffectivityItem::ActionMethod(r)),
            map(<ActionMethodRelationship<'a>>::parse, |r| EffectivityItem::ActionMethodRelationship(r)),
            map(<ActionProperty<'a>>::parse, |r| EffectivityItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| EffectivityItem::ActionRelationship(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| EffectivityItem::AssemblyComponentUsageSubstitute(r)),
            map(<Class<'a>>::parse, |r| EffectivityItem::Class(r)),
            map(<ClassSystem<'a>>::parse, |r| EffectivityItem::ClassSystem(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| EffectivityItem::ConfigurationDesign(r)),
            map(<ConfigurationItem<'a>>::parse, |r| EffectivityItem::ConfigurationItem(r)),
            map(<ConfiguredEffectivityAssignment<'a>>::parse, |r| EffectivityItem::ConfiguredEffectivityAssignment(r)),
            map(<DocumentFile<'a>>::parse, |r| EffectivityItem::DocumentFile(r)),
            map(<DraughtingModel<'a>>::parse, |r| EffectivityItem::DraughtingModel(r)),
            map(<DrawingRevision<'a>>::parse, |r| EffectivityItem::DrawingRevision(r)),
            map(<GeneralProperty<'a>>::parse, |r| EffectivityItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| EffectivityItem::MaterialDesignation(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| EffectivityItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<PresentationArea<'a>>::parse, |r| EffectivityItem::PresentationArea(r)),
            map(<Product<'a>>::parse, |r| EffectivityItem::Product(r)),
        alt((
            map(<ProductConcept<'a>>::parse, |r| EffectivityItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| EffectivityItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| EffectivityItem::ProductConceptFeatureAssociation(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| EffectivityItem::ProductConceptFeatureCategory(r)),
            map(<ProductConceptFeatureCategoryUsage<'a>>::parse, |r| EffectivityItem::ProductConceptFeatureCategoryUsage(r)),
            map(<ProductDefinition<'a>>::parse, |r| EffectivityItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| EffectivityItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| EffectivityItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| EffectivityItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| EffectivityItem::ProductDefinitionSubstitute(r)),
            map(<PropertyDefinition<'a>>::parse, |r| EffectivityItem::PropertyDefinition(r)),
            map(<RequirementForActionResource<'a>>::parse, |r| EffectivityItem::RequirementForActionResource(r)),
            map(<ResourceProperty<'a>>::parse, |r| EffectivityItem::ResourceProperty(r)),
            map(<SecurityClassification<'a>>::parse, |r| EffectivityItem::SecurityClassification(r)),
            map(<ShapeAspect<'a>>::parse, |r| EffectivityItem::ShapeAspect(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| EffectivityItem::ShapeRepresentation(r)),
        ))))(s)
    }
}
pub struct EffectivityRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub related_effectivity: Effectivity<'a>,
    pub relating_effectivity: Effectivity<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityRelationship<'a> = Id<EffectivityRelationship_<'a>>;
pub struct ElectricCurrentMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ElectricCurrentMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> ElectricCurrentMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct ElectricCurrentMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElectricCurrentMeasureWithUnit<'a> = Id<ElectricCurrentMeasureWithUnit_<'a>>;
pub struct ElectricCurrentUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElectricCurrentUnit<'a> = Id<ElectricCurrentUnit_<'a>>;
pub struct ElementDelivery_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElementDelivery<'a> = Id<ElementDelivery_<'a>>;
pub struct ElementarySurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElementarySurface<'a> = Id<ElementarySurface_<'a>>;
pub struct Ellipse_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub semi_axis_1: PositiveLengthMeasure<'a>,
    pub semi_axis_2: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Ellipse<'a> = Id<Ellipse_<'a>>;
pub struct Environment_<'a> { // entity
    pub syntactic_representation: GenericVariable<'a>,
    pub semantics: VariableSemantics<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Environment<'a> = Id<Environment_<'a>>;
pub struct EqualsExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EqualsExpression<'a> = Id<EqualsExpression_<'a>>;
pub struct EvaluatedDegeneratePcurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    pub equivalent_point: CartesianPoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EvaluatedDegeneratePcurve<'a> = Id<EvaluatedDegeneratePcurve_<'a>>;
pub struct EventOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrence<'a> = Id<EventOccurrence_<'a>>;
pub struct EventOccurrenceAssignment_<'a> { // entity
    pub assigned_event_occurrence: EventOccurrence<'a>,
    pub role: EventOccurrenceRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceAssignment<'a> = Id<EventOccurrenceAssignment_<'a>>;
pub struct EventOccurrenceContextAssignment_<'a> { // entity
    pub assigned_event_occurrence_assignment: EventOccurrenceAssignment<'a>,
    pub role: EventOccurrenceContextRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceContextAssignment<'a> = Id<EventOccurrenceContextAssignment_<'a>>;
pub struct EventOccurrenceContextRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceContextRole<'a> = Id<EventOccurrenceContextRole_<'a>>;
pub enum EventOccurrenceItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    ActionRequestSolution(ActionRequestSolution<'a>),
    AlternateProductRelationship(AlternateProductRelationship<'a>),
    AppliedActionAssignment(AppliedActionAssignment<'a>),
    AppliedClassificationAssignment(AppliedClassificationAssignment<'a>),
    AppliedPersonAndOrganizationAssignment(AppliedPersonAndOrganizationAssignment<'a>),
    ApprovalStatus(ApprovalStatus<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    Certification(Certification<'a>),
    Class(Class<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationEffectivity(ConfigurationEffectivity<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment<'a>),
    Contract(Contract<'a>),
    DocumentFile(DocumentFile<'a>),
    DraughtingModel(DraughtingModel<'a>),
    DrawingRevision(DrawingRevision<'a>),
    ExecutedAction(ExecutedAction<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    OrganizationRelationship(OrganizationRelationship<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PersonAndOrganization(PersonAndOrganization<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    RequirementForActionResource(RequirementForActionResource<'a>),
    ResourceProperty(ResourceProperty<'a>),
    SecurityClassification(SecurityClassification<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for EventOccurrenceItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| EventOccurrenceItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| EventOccurrenceItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| EventOccurrenceItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| EventOccurrenceItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| EventOccurrenceItem::ActionRelationship(r)),
            map(<ActionRequestSolution<'a>>::parse, |r| EventOccurrenceItem::ActionRequestSolution(r)),
            map(<AlternateProductRelationship<'a>>::parse, |r| EventOccurrenceItem::AlternateProductRelationship(r)),
            map(<AppliedActionAssignment<'a>>::parse, |r| EventOccurrenceItem::AppliedActionAssignment(r)),
            map(<AppliedClassificationAssignment<'a>>::parse, |r| EventOccurrenceItem::AppliedClassificationAssignment(r)),
            map(<AppliedPersonAndOrganizationAssignment<'a>>::parse, |r| EventOccurrenceItem::AppliedPersonAndOrganizationAssignment(r)),
            map(<ApprovalStatus<'a>>::parse, |r| EventOccurrenceItem::ApprovalStatus(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| EventOccurrenceItem::AssemblyComponentUsageSubstitute(r)),
            map(<Certification<'a>>::parse, |r| EventOccurrenceItem::Certification(r)),
            map(<Class<'a>>::parse, |r| EventOccurrenceItem::Class(r)),
            map(<ClassSystem<'a>>::parse, |r| EventOccurrenceItem::ClassSystem(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| EventOccurrenceItem::ConfigurationDesign(r)),
            map(<ConfigurationEffectivity<'a>>::parse, |r| EventOccurrenceItem::ConfigurationEffectivity(r)),
            map(<ConfigurationItem<'a>>::parse, |r| EventOccurrenceItem::ConfigurationItem(r)),
            map(<ConfiguredEffectivityAssignment<'a>>::parse, |r| EventOccurrenceItem::ConfiguredEffectivityAssignment(r)),
        alt((
            map(<Contract<'a>>::parse, |r| EventOccurrenceItem::Contract(r)),
            map(<DocumentFile<'a>>::parse, |r| EventOccurrenceItem::DocumentFile(r)),
            map(<DraughtingModel<'a>>::parse, |r| EventOccurrenceItem::DraughtingModel(r)),
            map(<DrawingRevision<'a>>::parse, |r| EventOccurrenceItem::DrawingRevision(r)),
            map(<ExecutedAction<'a>>::parse, |r| EventOccurrenceItem::ExecutedAction(r)),
            map(<GeneralProperty<'a>>::parse, |r| EventOccurrenceItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| EventOccurrenceItem::MaterialDesignation(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| EventOccurrenceItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<OrganizationRelationship<'a>>::parse, |r| EventOccurrenceItem::OrganizationRelationship(r)),
            map(<OrganizationalProject<'a>>::parse, |r| EventOccurrenceItem::OrganizationalProject(r)),
            map(<PersonAndOrganization<'a>>::parse, |r| EventOccurrenceItem::PersonAndOrganization(r)),
            map(<PresentationArea<'a>>::parse, |r| EventOccurrenceItem::PresentationArea(r)),
            map(<Product<'a>>::parse, |r| EventOccurrenceItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| EventOccurrenceItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| EventOccurrenceItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| EventOccurrenceItem::ProductConceptFeatureAssociation(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| EventOccurrenceItem::ProductConceptFeatureCategory(r)),
            map(<ProductConceptFeatureCategoryUsage<'a>>::parse, |r| EventOccurrenceItem::ProductConceptFeatureCategoryUsage(r)),
            map(<ProductDefinition<'a>>::parse, |r| EventOccurrenceItem::ProductDefinition(r)),
        alt((
            map(<ProductDefinitionFormation<'a>>::parse, |r| EventOccurrenceItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| EventOccurrenceItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| EventOccurrenceItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| EventOccurrenceItem::ProductDefinitionSubstitute(r)),
            map(<PropertyDefinition<'a>>::parse, |r| EventOccurrenceItem::PropertyDefinition(r)),
            map(<RequirementForActionResource<'a>>::parse, |r| EventOccurrenceItem::RequirementForActionResource(r)),
            map(<ResourceProperty<'a>>::parse, |r| EventOccurrenceItem::ResourceProperty(r)),
            map(<SecurityClassification<'a>>::parse, |r| EventOccurrenceItem::SecurityClassification(r)),
            map(<SecurityClassificationLevel<'a>>::parse, |r| EventOccurrenceItem::SecurityClassificationLevel(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| EventOccurrenceItem::ShapeRepresentation(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| EventOccurrenceItem::VersionedActionRequest(r)),
        ))))))(s)
    }
}
pub struct EventOccurrenceRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceRole<'a> = Id<EventOccurrenceRole_<'a>>;
pub struct ExclusiveProductConceptFeatureCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExclusiveProductConceptFeatureCategory<'a> = Id<ExclusiveProductConceptFeatureCategory_<'a>>;
pub struct ExecutedAction_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExecutedAction<'a> = Id<ExecutedAction_<'a>>;
pub struct ExpFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExpFunction<'a> = Id<ExpFunction_<'a>>;
pub struct Expression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Expression<'a> = Id<Expression_<'a>>;
pub struct ExpressionConversionBasedUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExpressionConversionBasedUnit<'a> = Id<ExpressionConversionBasedUnit_<'a>>;
pub struct Extension_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Extension<'a> = Id<Extension_<'a>>;
pub struct ExternalIdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternalIdentificationAssignment<'a> = Id<ExternalIdentificationAssignment_<'a>>;
pub enum ExternalIdentificationItem<'a> { // select
    DocumentFile(DocumentFile<'a>),
    ExternallyDefinedClass(ExternallyDefinedClass<'a>),
    ExternallyDefinedGeneralProperty(ExternallyDefinedGeneralProperty<'a>),
    ProductDefinition(ProductDefinition<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ExternalIdentificationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<DocumentFile<'a>>::parse, |r| ExternalIdentificationItem::DocumentFile(r)),
            map(<ExternallyDefinedClass<'a>>::parse, |r| ExternalIdentificationItem::ExternallyDefinedClass(r)),
            map(<ExternallyDefinedGeneralProperty<'a>>::parse, |r| ExternalIdentificationItem::ExternallyDefinedGeneralProperty(r)),
            map(<ProductDefinition<'a>>::parse, |r| ExternalIdentificationItem::ProductDefinition(r)),
        ))(s)
    }
}
pub struct ExternalSource_<'a> { // entity
    pub source_id: SourceItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternalSource<'a> = Id<ExternalSource_<'a>>;
pub struct ExternallyDefinedCharacterGlyph_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedCharacterGlyph<'a> = Id<ExternallyDefinedCharacterGlyph_<'a>>;
pub struct ExternallyDefinedClass_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedClass<'a> = Id<ExternallyDefinedClass_<'a>>;
pub struct ExternallyDefinedCurveFont_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedCurveFont<'a> = Id<ExternallyDefinedCurveFont_<'a>>;
pub struct ExternallyDefinedDimensionDefinition_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedDimensionDefinition<'a> = Id<ExternallyDefinedDimensionDefinition_<'a>>;
pub struct ExternallyDefinedFeatureDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedFeatureDefinition<'a> = Id<ExternallyDefinedFeatureDefinition_<'a>>;
pub struct ExternallyDefinedGeneralProperty_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedGeneralProperty<'a> = Id<ExternallyDefinedGeneralProperty_<'a>>;
pub struct ExternallyDefinedHatchStyle_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedHatchStyle<'a> = Id<ExternallyDefinedHatchStyle_<'a>>;
pub struct ExternallyDefinedItem_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedItem<'a> = Id<ExternallyDefinedItem_<'a>>;
pub struct ExternallyDefinedItemRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_item: ExternallyDefinedItem<'a>,
    pub related_item: ExternallyDefinedItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedItemRelationship<'a> = Id<ExternallyDefinedItemRelationship_<'a>>;
pub struct ExternallyDefinedStyle_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedStyle<'a> = Id<ExternallyDefinedStyle_<'a>>;
pub struct ExternallyDefinedSymbol_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedSymbol<'a> = Id<ExternallyDefinedSymbol_<'a>>;
pub struct ExternallyDefinedTextFont_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedTextFont<'a> = Id<ExternallyDefinedTextFont_<'a>>;
pub struct ExternallyDefinedTileStyle_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedTileStyle<'a> = Id<ExternallyDefinedTileStyle_<'a>>;
pub struct ExtrudedAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub extruded_direction: Direction<'a>,
    pub depth: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExtrudedAreaSolid<'a> = Id<ExtrudedAreaSolid_<'a>>;
pub struct ExtrudedFaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_face: FaceSurface<'a>,
    pub extruded_direction: Direction<'a>,
    pub depth: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExtrudedFaceSolid<'a> = Id<ExtrudedFaceSolid_<'a>>;
pub struct Face_<'a> { // entity
    pub name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Face<'a> = Id<Face_<'a>>;
pub struct FaceBasedSurfaceModel_<'a> { // entity
    pub name: Label<'a>,
    pub fbsm_faces: Vec<ConnectedFaceSet<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceBasedSurfaceModel<'a> = Id<FaceBasedSurfaceModel_<'a>>;
pub struct FaceBound_<'a> { // entity
    pub name: Label<'a>,
    pub bound: Loop<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceBound<'a> = Id<FaceBound_<'a>>;
pub struct FaceOuterBound_<'a> { // entity
    pub name: Label<'a>,
    pub bound: Loop<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceOuterBound<'a> = Id<FaceOuterBound_<'a>>;
pub struct FaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceShapeRepresentation<'a> = Id<FaceShapeRepresentation_<'a>>;
pub struct FaceSurface_<'a> { // entity
    pub name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    pub face_geometry: Surface<'a>,
    pub same_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceSurface<'a> = Id<FaceSurface_<'a>>;
pub struct FacetedBrep_<'a> { // entity
    pub name: Label<'a>,
    pub outer: ClosedShell<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FacetedBrep<'a> = Id<FacetedBrep_<'a>>;
pub struct FacetedBrepShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FacetedBrepShapeRepresentation<'a> = Id<FacetedBrepShapeRepresentation_<'a>>;
pub struct FeatureComponentDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureComponentDefinition<'a> = Id<FeatureComponentDefinition_<'a>>;
pub struct FeatureComponentRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureComponentRelationship<'a> = Id<FeatureComponentRelationship_<'a>>;
pub struct FeatureDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureDefinition<'a> = Id<FeatureDefinition_<'a>>;
pub struct FeatureInPanel_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureInPanel<'a> = Id<FeatureInPanel_<'a>>;
pub struct FeaturePattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeaturePattern<'a> = Id<FeaturePattern_<'a>>;
pub struct FeaturedShape_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeaturedShape<'a> = Id<FeaturedShape_<'a>>;
pub struct FillAreaStyle_<'a> { // entity
    pub name: Label<'a>,
    pub fill_styles: Vec<FillStyleSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyle<'a> = Id<FillAreaStyle_<'a>>;
pub struct FillAreaStyleColour_<'a> { // entity
    pub name: Label<'a>,
    pub fill_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleColour<'a> = Id<FillAreaStyleColour_<'a>>;
pub struct FillAreaStyleHatching_<'a> { // entity
    pub name: Label<'a>,
    pub hatch_line_appearance: CurveStyle<'a>,
    pub start_of_next_hatch_line: OneDirectionRepeatFactor<'a>,
    pub point_of_reference_hatch_line: CartesianPoint<'a>,
    pub pattern_start: CartesianPoint<'a>,
    pub hatch_line_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleHatching<'a> = Id<FillAreaStyleHatching_<'a>>;
pub enum FillAreaStyleTileShapeSelect<'a> { // select
    FillAreaStyleTileSymbolWithStyle(FillAreaStyleTileSymbolWithStyle<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for FillAreaStyleTileShapeSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<FillAreaStyleTileSymbolWithStyle<'a>>::parse, |r| FillAreaStyleTileShapeSelect::FillAreaStyleTileSymbolWithStyle(r))(s)
    }
}
pub struct FillAreaStyleTileSymbolWithStyle_<'a> { // entity
    pub name: Label<'a>,
    pub symbol: AnnotationSymbolOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleTileSymbolWithStyle<'a> = Id<FillAreaStyleTileSymbolWithStyle_<'a>>;
pub struct FillAreaStyleTiles_<'a> { // entity
    pub name: Label<'a>,
    pub tiling_pattern: TwoDirectionRepeatFactor<'a>,
    pub tiles: Vec<FillAreaStyleTileShapeSelect<'a>>,
    pub tiling_scale: PositiveRatioMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleTiles<'a> = Id<FillAreaStyleTiles_<'a>>;
pub enum FillStyleSelect<'a> { // select
    FillAreaStyleColour(FillAreaStyleColour<'a>),
    ExternallyDefinedTileStyle(ExternallyDefinedTileStyle<'a>),
    FillAreaStyleTiles(FillAreaStyleTiles<'a>),
    ExternallyDefinedHatchStyle(ExternallyDefinedHatchStyle<'a>),
    FillAreaStyleHatching(FillAreaStyleHatching<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for FillStyleSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<FillAreaStyleColour<'a>>::parse, |r| FillStyleSelect::FillAreaStyleColour(r)),
            map(<ExternallyDefinedTileStyle<'a>>::parse, |r| FillStyleSelect::ExternallyDefinedTileStyle(r)),
            map(<FillAreaStyleTiles<'a>>::parse, |r| FillStyleSelect::FillAreaStyleTiles(r)),
            map(<ExternallyDefinedHatchStyle<'a>>::parse, |r| FillStyleSelect::ExternallyDefinedHatchStyle(r)),
            map(<FillAreaStyleHatching<'a>>::parse, |r| FillStyleSelect::FillAreaStyleHatching(r)),
        ))(s)
    }
}
pub struct Fillet_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Fillet<'a> = Id<Fillet_<'a>>;
pub struct FlatnessTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FlatnessTolerance<'a> = Id<FlatnessTolerance_<'a>>;
pub enum FontSelect<'a> { // select
    PreDefinedTextFont(PreDefinedTextFont<'a>),
    ExternallyDefinedTextFont(ExternallyDefinedTextFont<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for FontSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PreDefinedTextFont<'a>>::parse, |r| FontSelect::PreDefinedTextFont(r)),
            map(<ExternallyDefinedTextFont<'a>>::parse, |r| FontSelect::ExternallyDefinedTextFont(r)),
        ))(s)
    }
}
pub struct FormatFunction_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FormatFunction<'a> = Id<FormatFunction_<'a>>;
pub struct FoundedItem_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FoundedItem<'a> = Id<FoundedItem_<'a>>;
pub enum FoundedItemSelect<'a> { // select
    FoundedItem(FoundedItem<'a>),
    RepresentationItem(RepresentationItem<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for FoundedItemSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<FoundedItem<'a>>::parse, |r| FoundedItemSelect::FoundedItem(r)),
            map(<RepresentationItem<'a>>::parse, |r| FoundedItemSelect::RepresentationItem(r)),
        ))(s)
    }
}
pub struct FoundedKinematicPath_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FoundedKinematicPath<'a> = Id<FoundedKinematicPath_<'a>>;
pub struct FullyConstrainedPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FullyConstrainedPair<'a> = Id<FullyConstrainedPair_<'a>>;
pub struct FunctionallyDefinedTransformation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FunctionallyDefinedTransformation<'a> = Id<FunctionallyDefinedTransformation_<'a>>;
pub struct GearPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub radius_first_link: LengthMeasure<'a>,
    pub radius_second_link: LengthMeasure<'a>,
    pub bevel: PlaneAngleMeasure<'a>,
    pub helical_angle: PlaneAngleMeasure<'a>,
    pub gear_ratio: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GearPair<'a> = Id<GearPair_<'a>>;
pub struct GearPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation_1: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation_1: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GearPairRange<'a> = Id<GearPairRange_<'a>>;
pub struct GearPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation_1: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GearPairValue<'a> = Id<GearPairValue_<'a>>;
pub struct GeneralFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralFeature<'a> = Id<GeneralFeature_<'a>>;
pub struct GeneralMaterialProperty_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralMaterialProperty<'a> = Id<GeneralMaterialProperty_<'a>>;
pub struct GeneralProperty_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralProperty<'a> = Id<GeneralProperty_<'a>>;
pub struct GeneralPropertyAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub base_definition: GeneralProperty<'a>,
    pub derived_definition: DerivedPropertySelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralPropertyAssociation<'a> = Id<GeneralPropertyAssociation_<'a>>;
pub struct GeneralPropertyRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_property: GeneralProperty<'a>,
    pub related_property: GeneralProperty<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralPropertyRelationship<'a> = Id<GeneralPropertyRelationship_<'a>>;
pub struct GenericCharacterGlyphSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericCharacterGlyphSymbol<'a> = Id<GenericCharacterGlyphSymbol_<'a>>;
pub struct GenericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericExpression<'a> = Id<GenericExpression_<'a>>;
pub struct GenericLiteral_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericLiteral<'a> = Id<GenericLiteral_<'a>>;
pub struct GenericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericVariable<'a> = Id<GenericVariable_<'a>>;
pub struct GeometricAlignment_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricAlignment<'a> = Id<GeometricAlignment_<'a>>;
pub struct GeometricCurveSet_<'a> { // entity
    pub name: Label<'a>,
    pub elements: Vec<GeometricSetSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricCurveSet<'a> = Id<GeometricCurveSet_<'a>>;
pub struct GeometricIntersection_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricIntersection<'a> = Id<GeometricIntersection_<'a>>;
pub struct GeometricItemSpecificUsage_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub identified_item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricItemSpecificUsage<'a> = Id<GeometricItemSpecificUsage_<'a>>;
pub struct GeometricRepresentationContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    pub coordinate_space_dimension: DimensionCount<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricRepresentationContext<'a> = Id<GeometricRepresentationContext_<'a>>;
pub struct GeometricRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricRepresentationItem<'a> = Id<GeometricRepresentationItem_<'a>>;
pub struct GeometricSet_<'a> { // entity
    pub name: Label<'a>,
    pub elements: Vec<GeometricSetSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricSet<'a> = Id<GeometricSet_<'a>>;
pub enum GeometricSetSelect<'a> { // select
    Point(Point<'a>),
    Curve(Curve<'a>),
    Surface(Surface<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for GeometricSetSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Point<'a>>::parse, |r| GeometricSetSelect::Point(r)),
            map(<Curve<'a>>::parse, |r| GeometricSetSelect::Curve(r)),
            map(<Surface<'a>>::parse, |r| GeometricSetSelect::Surface(r)),
        ))(s)
    }
}
pub struct GeometricTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricTolerance<'a> = Id<GeometricTolerance_<'a>>;
pub struct GeometricToleranceRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_geometric_tolerance: GeometricTolerance<'a>,
    pub related_geometric_tolerance: GeometricTolerance<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricToleranceRelationship<'a> = Id<GeometricToleranceRelationship_<'a>>;
pub struct GeometricToleranceWithDatumReference_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricToleranceWithDatumReference<'a> = Id<GeometricToleranceWithDatumReference_<'a>>;
pub struct GeometricToleranceWithDefinedUnit_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub unit_size: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricToleranceWithDefinedUnit<'a> = Id<GeometricToleranceWithDefinedUnit_<'a>>;
pub struct GeometricalToleranceCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricalToleranceCallout<'a> = Id<GeometricalToleranceCallout_<'a>>;
pub struct GeometricallyBounded2dWireframeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricallyBounded2dWireframeRepresentation<'a> = Id<GeometricallyBounded2dWireframeRepresentation_<'a>>;
pub struct GeometricallyBoundedSurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricallyBoundedSurfaceShapeRepresentation<'a> = Id<GeometricallyBoundedSurfaceShapeRepresentation_<'a>>;
pub struct GeometricallyBoundedWireframeShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricallyBoundedWireframeShapeRepresentation<'a> = Id<GeometricallyBoundedWireframeShapeRepresentation_<'a>>;
pub struct GlobalUncertaintyAssignedContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    pub uncertainty: Vec<UncertaintyMeasureWithUnit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GlobalUncertaintyAssignedContext<'a> = Id<GlobalUncertaintyAssignedContext_<'a>>;
pub struct GlobalUnitAssignedContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    pub units: Vec<Unit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GlobalUnitAssignedContext<'a> = Id<GlobalUnitAssignedContext_<'a>>;
pub struct Group_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Group<'a> = Id<Group_<'a>>;
pub struct GroupAssignment_<'a> { // entity
    pub assigned_group: Group<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GroupAssignment<'a> = Id<GroupAssignment_<'a>>;
pub enum GroupItem<'a> { // select
    GeometricRepresentationItem(GeometricRepresentationItem<'a>),
    MappedItem(MappedItem<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ShapeAspect(ShapeAspect<'a>),
    StyledItem(StyledItem<'a>),
    TopologicalRepresentationItem(TopologicalRepresentationItem<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for GroupItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<GeometricRepresentationItem<'a>>::parse, |r| GroupItem::GeometricRepresentationItem(r)),
            map(<MappedItem<'a>>::parse, |r| GroupItem::MappedItem(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| GroupItem::ProductConceptFeature(r)),
            map(<ShapeAspect<'a>>::parse, |r| GroupItem::ShapeAspect(r)),
            map(<StyledItem<'a>>::parse, |r| GroupItem::StyledItem(r)),
            map(<TopologicalRepresentationItem<'a>>::parse, |r| GroupItem::TopologicalRepresentationItem(r)),
        ))(s)
    }
}
pub struct GroupRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_group: Group<'a>,
    pub related_group: Group<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GroupRelationship<'a> = Id<GroupRelationship_<'a>>;
pub struct HalfSpaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub base_surface: Surface<'a>,
    pub agreement_flag: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HalfSpaceSolid<'a> = Id<HalfSpaceSolid_<'a>>;
pub struct HardnessRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HardnessRepresentation<'a> = Id<HardnessRepresentation_<'a>>;
pub struct HiddenElementOverRidingStyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub over_ridden_style: StyledItem<'a>,
    pub style_context: Vec<StyleContextSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HiddenElementOverRidingStyledItem<'a> = Id<HiddenElementOverRidingStyledItem_<'a>>;
pub struct HoleBottom_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HoleBottom<'a> = Id<HoleBottom_<'a>>;
pub struct HoleInPanel_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HoleInPanel<'a> = Id<HoleInPanel_<'a>>;
pub struct HomokineticPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub input_skew_angle: Option<PlaneAngleMeasure<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HomokineticPair<'a> = Id<HomokineticPair_<'a>>;
pub struct HourInDay<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for HourInDay<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> HourInDay<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct Hyperbola_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub semi_axis: PositiveLengthMeasure<'a>,
    pub semi_imag_axis: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Hyperbola<'a> = Id<Hyperbola_<'a>>;
pub struct IdAttribute_<'a> { // entity
    pub attribute_value: Identifier<'a>,
    pub identified_item: IdAttributeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IdAttribute<'a> = Id<IdAttribute_<'a>>;
pub enum IdAttributeSelect<'a> { // select
    Action(Action<'a>),
    Address(Address<'a>),
    ProductCategory(ProductCategory<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    ShapeAspect(ShapeAspect<'a>),
    ShapeAspectRelationship(ShapeAspectRelationship<'a>),
    ApplicationContext(ApplicationContext<'a>),
    Group(Group<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    Representation(Representation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for IdAttributeSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| IdAttributeSelect::Action(r)),
            map(<Address<'a>>::parse, |r| IdAttributeSelect::Address(r)),
            map(<ProductCategory<'a>>::parse, |r| IdAttributeSelect::ProductCategory(r)),
            map(<PropertyDefinition<'a>>::parse, |r| IdAttributeSelect::PropertyDefinition(r)),
            map(<ShapeAspect<'a>>::parse, |r| IdAttributeSelect::ShapeAspect(r)),
            map(<ShapeAspectRelationship<'a>>::parse, |r| IdAttributeSelect::ShapeAspectRelationship(r)),
            map(<ApplicationContext<'a>>::parse, |r| IdAttributeSelect::ApplicationContext(r)),
            map(<Group<'a>>::parse, |r| IdAttributeSelect::Group(r)),
            map(<OrganizationalProject<'a>>::parse, |r| IdAttributeSelect::OrganizationalProject(r)),
            map(<Representation<'a>>::parse, |r| IdAttributeSelect::Representation(r)),
        ))(s)
    }
}
pub struct IdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IdentificationAssignment<'a> = Id<IdentificationAssignment_<'a>>;
pub enum IdentificationItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    AppliedIdentificationAssignment(AppliedIdentificationAssignment<'a>),
    ApprovalStatus(ApprovalStatus<'a>),
    Class(Class<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    DimensionalSize(DimensionalSize<'a>),
    DocumentFile(DocumentFile<'a>),
    DocumentType(DocumentType<'a>),
    DraughtingModel(DraughtingModel<'a>),
    Effectivity(Effectivity<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MeasureRepresentationItem(MeasureRepresentationItem<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    Organization(Organization<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PersonAndOrganization(PersonAndOrganization<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    PropertyDefinitionRelationship(PropertyDefinitionRelationship<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel<'a>),
    ShapeAspectRelationship(ShapeAspectRelationship<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for IdentificationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| IdentificationItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| IdentificationItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| IdentificationItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| IdentificationItem::ActionProperty(r)),
            map(<AppliedIdentificationAssignment<'a>>::parse, |r| IdentificationItem::AppliedIdentificationAssignment(r)),
            map(<ApprovalStatus<'a>>::parse, |r| IdentificationItem::ApprovalStatus(r)),
            map(<Class<'a>>::parse, |r| IdentificationItem::Class(r)),
            map(<ClassSystem<'a>>::parse, |r| IdentificationItem::ClassSystem(r)),
            map(<ConfigurationItem<'a>>::parse, |r| IdentificationItem::ConfigurationItem(r)),
            map(<DimensionalSize<'a>>::parse, |r| IdentificationItem::DimensionalSize(r)),
            map(<DocumentFile<'a>>::parse, |r| IdentificationItem::DocumentFile(r)),
            map(<DocumentType<'a>>::parse, |r| IdentificationItem::DocumentType(r)),
            map(<DraughtingModel<'a>>::parse, |r| IdentificationItem::DraughtingModel(r)),
            map(<Effectivity<'a>>::parse, |r| IdentificationItem::Effectivity(r)),
            map(<GeneralProperty<'a>>::parse, |r| IdentificationItem::GeneralProperty(r)),
            map(<MeasureRepresentationItem<'a>>::parse, |r| IdentificationItem::MeasureRepresentationItem(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| IdentificationItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<Organization<'a>>::parse, |r| IdentificationItem::Organization(r)),
            map(<OrganizationalProject<'a>>::parse, |r| IdentificationItem::OrganizationalProject(r)),
        alt((
            map(<PersonAndOrganization<'a>>::parse, |r| IdentificationItem::PersonAndOrganization(r)),
            map(<PresentationArea<'a>>::parse, |r| IdentificationItem::PresentationArea(r)),
            map(<Product<'a>>::parse, |r| IdentificationItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| IdentificationItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| IdentificationItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| IdentificationItem::ProductConceptFeatureCategory(r)),
            map(<ProductDefinition<'a>>::parse, |r| IdentificationItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| IdentificationItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| IdentificationItem::ProductDefinitionRelationship(r)),
            map(<PropertyDefinition<'a>>::parse, |r| IdentificationItem::PropertyDefinition(r)),
            map(<PropertyDefinitionRelationship<'a>>::parse, |r| IdentificationItem::PropertyDefinitionRelationship(r)),
            map(<SecurityClassificationLevel<'a>>::parse, |r| IdentificationItem::SecurityClassificationLevel(r)),
            map(<ShapeAspectRelationship<'a>>::parse, |r| IdentificationItem::ShapeAspectRelationship(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| IdentificationItem::ShapeRepresentation(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| IdentificationItem::VersionedActionRequest(r)),
        ))))(s)
    }
}
pub struct IdentificationRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IdentificationRole<'a> = Id<IdentificationRole_<'a>>;
pub struct Identifier<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Identifier<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> Identifier<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct InclusionProductConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub condition: ConceptFeatureRelationshipWithCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InclusionProductConceptFeature<'a> = Id<InclusionProductConceptFeature_<'a>>;
pub struct IndexExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IndexExpression<'a> = Id<IndexExpression_<'a>>;
pub struct InitialState_<'a> { // entity
    pub applies_to_mechanism: Mechanism<'a>,
    pub pair_values: Vec<PairValue<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InitialState<'a> = Id<InitialState_<'a>>;
#[allow(non_snake_case)]
pub struct InstancedFeature_<'a> { // entity
    pub shape_aspect__name: Label<'a>,
    pub shape_aspect__description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InstancedFeature<'a> = Id<InstancedFeature_<'a>>;
pub struct IntLiteral_<'a> { // entity
    pub the_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntLiteral<'a> = Id<IntLiteral_<'a>>;
pub struct IntNumericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntNumericVariable<'a> = Id<IntNumericVariable_<'a>>;
pub struct IntValueFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntValueFunction<'a> = Id<IntValueFunction_<'a>>;
pub struct IntegerDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntegerDefinedFunction<'a> = Id<IntegerDefinedFunction_<'a>>;
pub struct InterpolatedConfigurationSequence_<'a> { // entity
    pub interpolation: Vec<ConfigurationInterpolation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InterpolatedConfigurationSequence<'a> = Id<InterpolatedConfigurationSequence_<'a>>;
pub enum InterpolationType<'a> { // enum
    Undefined,
    Synchronous,
    Linear,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for InterpolationType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use InterpolationType::*;
        alt((
            map(tag(".UNDEFINED."), |_| Undefined),
            map(tag(".SYNCHRONOUS."), |_| Synchronous),
            map(tag(".LINEAR."), |_| Linear),
        ))(s)
    }
}
pub struct IntersectionCurve_<'a> { // entity
    pub name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: Vec<PcurveOrSurface<'a>>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntersectionCurve<'a> = Id<IntersectionCurve_<'a>>;
pub struct IntervalExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntervalExpression<'a> = Id<IntervalExpression_<'a>>;
pub struct Invisibility_<'a> { // entity
    pub invisible_items: Vec<InvisibleItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Invisibility<'a> = Id<Invisibility_<'a>>;
pub enum InvisibilityContext<'a> { // select
    PresentationRepresentation(PresentationRepresentation<'a>),
    PresentationSet(PresentationSet<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for InvisibilityContext<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PresentationRepresentation<'a>>::parse, |r| InvisibilityContext::PresentationRepresentation(r)),
            map(<PresentationSet<'a>>::parse, |r| InvisibilityContext::PresentationSet(r)),
        ))(s)
    }
}
pub enum InvisibleItem<'a> { // select
    DraughtingCallout(DraughtingCallout<'a>),
    PresentationLayerAssignment(PresentationLayerAssignment<'a>),
    Representation(Representation<'a>),
    StyledItem(StyledItem<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for InvisibleItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<DraughtingCallout<'a>>::parse, |r| InvisibleItem::DraughtingCallout(r)),
            map(<PresentationLayerAssignment<'a>>::parse, |r| InvisibleItem::PresentationLayerAssignment(r)),
            map(<Representation<'a>>::parse, |r| InvisibleItem::Representation(r)),
            map(<StyledItem<'a>>::parse, |r| InvisibleItem::StyledItem(r)),
        ))(s)
    }
}
pub struct ItemDefinedTransformation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ItemDefinedTransformation<'a> = Id<ItemDefinedTransformation_<'a>>;
pub struct ItemIdentifiedRepresentationUsage_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub identified_item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ItemIdentifiedRepresentationUsage<'a> = Id<ItemIdentifiedRepresentationUsage_<'a>>;
pub struct Joggle_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Joggle<'a> = Id<Joggle_<'a>>;
pub struct JoggleTermination_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type JoggleTermination<'a> = Id<JoggleTermination_<'a>>;
pub struct KinematicAnalysisConsistency_<'a> { // entity
    pub control: KinematicControl<'a>,
    pub result: KinematicAnalysisResult<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicAnalysisConsistency<'a> = Id<KinematicAnalysisConsistency_<'a>>;
pub enum KinematicAnalysisDefinition<'a> { // select
    InterpolatedConfigurationSequence(InterpolatedConfigurationSequence<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for KinematicAnalysisDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<InterpolatedConfigurationSequence<'a>>::parse, |r| KinematicAnalysisDefinition::InterpolatedConfigurationSequence(r))(s)
    }
}
pub struct KinematicAnalysisResult_<'a> { // entity
    pub analysed_mechanism: Mechanism<'a>,
    pub contained_kinematic_results: Vec<KinematicResult<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicAnalysisResult<'a> = Id<KinematicAnalysisResult_<'a>>;
pub struct KinematicControl_<'a> { // entity
    pub controlled_mechanism: Mechanism<'a>,
    pub contained_kinematic_programs: Vec<KinematicAnalysisDefinition<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicControl<'a> = Id<KinematicControl_<'a>>;
pub enum KinematicFrameBackground<'a> { // select
    Point(Point<'a>),
    Curve(Curve<'a>),
    Surface(Surface<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for KinematicFrameBackground<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Point<'a>>::parse, |r| KinematicFrameBackground::Point(r)),
            map(<Curve<'a>>::parse, |r| KinematicFrameBackground::Curve(r)),
            map(<Surface<'a>>::parse, |r| KinematicFrameBackground::Surface(r)),
        ))(s)
    }
}
pub struct KinematicFrameBackgroundRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicFrameBackgroundRepresentation<'a> = Id<KinematicFrameBackgroundRepresentation_<'a>>;
pub struct KinematicFrameBackgroundRepresentationAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub transformation_operator: Transformation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicFrameBackgroundRepresentationAssociation<'a> = Id<KinematicFrameBackgroundRepresentationAssociation_<'a>>;
#[allow(non_snake_case)]
pub struct KinematicFrameBasedTransformation_<'a> { // entity
    pub name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transformator: RigidPlacement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicFrameBasedTransformation<'a> = Id<KinematicFrameBasedTransformation_<'a>>;
pub struct KinematicGroundRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicGroundRepresentation<'a> = Id<KinematicGroundRepresentation_<'a>>;
pub struct KinematicJoint_<'a> { // entity
    pub first_link: KinematicLink<'a>,
    pub second_link: KinematicLink<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicJoint<'a> = Id<KinematicJoint_<'a>>;
pub struct KinematicLink_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLink<'a> = Id<KinematicLink_<'a>>;
pub struct KinematicLinkRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLinkRepresentation<'a> = Id<KinematicLinkRepresentation_<'a>>;
pub struct KinematicLinkRepresentationAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLinkRepresentationAssociation<'a> = Id<KinematicLinkRepresentationAssociation_<'a>>;
pub struct KinematicLinkRepresentationRelation_<'a> { // entity
    pub topological_aspects: KinematicLink<'a>,
    pub geometric_aspects: KinematicLinkRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLinkRepresentationRelation<'a> = Id<KinematicLinkRepresentationRelation_<'a>>;
pub struct KinematicPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPair<'a> = Id<KinematicPair_<'a>>;
pub struct KinematicPath_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPath<'a> = Id<KinematicPath_<'a>>;
pub struct KinematicPropertyDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    pub ground_definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPropertyDefinition<'a> = Id<KinematicPropertyDefinition_<'a>>;
pub struct KinematicPropertyRepresentationRelation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPropertyRepresentationRelation<'a> = Id<KinematicPropertyRepresentationRelation_<'a>>;
pub enum KinematicResult<'a> { // select
    InterpolatedConfigurationSequence(InterpolatedConfigurationSequence<'a>),
    ResultingPath(ResultingPath<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for KinematicResult<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<InterpolatedConfigurationSequence<'a>>::parse, |r| KinematicResult::InterpolatedConfigurationSequence(r)),
            map(<ResultingPath<'a>>::parse, |r| KinematicResult::ResultingPath(r)),
        ))(s)
    }
}
pub struct KinematicStructure_<'a> { // entity
    pub joints: Vec<KinematicJoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicStructure<'a> = Id<KinematicStructure_<'a>>;
pub enum KnotType<'a> { // enum
    UniformKnots,
    QuasiUniformKnots,
    PiecewiseBezierKnots,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for KnotType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use KnotType::*;
        alt((
            map(tag(".UNIFORM_KNOTS."), |_| UniformKnots),
            map(tag(".QUASI_UNIFORM_KNOTS."), |_| QuasiUniformKnots),
            map(tag(".PIECEWISE_BEZIER_KNOTS."), |_| PiecewiseBezierKnots),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
pub struct KnownSource_<'a> { // entity
    pub source_id: SourceItem<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KnownSource<'a> = Id<KnownSource_<'a>>;
pub struct Label<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Label<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> Label<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct Language_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Language<'a> = Id<Language_<'a>>;
pub struct LanguageAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub role: ClassificationRole<'a>,
    pub items: Vec<LanguageItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LanguageAssignment<'a> = Id<LanguageAssignment_<'a>>;
pub enum LanguageItem<'a> { // select
    Representation(Representation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for LanguageItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<Representation<'a>>::parse, |r| LanguageItem::Representation(r))(s)
    }
}
pub enum LayeredItem<'a> { // select
    PresentationRepresentation(PresentationRepresentation<'a>),
    RepresentationItem(RepresentationItem<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for LayeredItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PresentationRepresentation<'a>>::parse, |r| LayeredItem::PresentationRepresentation(r)),
            map(<RepresentationItem<'a>>::parse, |r| LayeredItem::RepresentationItem(r)),
        ))(s)
    }
}
pub struct LeaderCurve_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderCurve<'a> = Id<LeaderCurve_<'a>>;
pub struct LeaderDirectedCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderDirectedCallout<'a> = Id<LeaderDirectedCallout_<'a>>;
pub struct LeaderDirectedDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderDirectedDimension<'a> = Id<LeaderDirectedDimension_<'a>>;
pub struct LeaderTerminator_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub annotated_curve: AnnotationCurveOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderTerminator<'a> = Id<LeaderTerminator_<'a>>;
pub struct LengthFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LengthFunction<'a> = Id<LengthFunction_<'a>>;
pub struct LengthMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for LengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> LengthMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct LengthMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LengthMeasureWithUnit<'a> = Id<LengthMeasureWithUnit_<'a>>;
pub struct LengthUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LengthUnit<'a> = Id<LengthUnit_<'a>>;
pub struct LightSource_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSource<'a> = Id<LightSource_<'a>>;
pub struct LightSourceAmbient_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourceAmbient<'a> = Id<LightSourceAmbient_<'a>>;
pub struct LightSourceDirectional_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    pub orientation: Direction<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourceDirectional<'a> = Id<LightSourceDirectional_<'a>>;
pub struct LightSourcePositional_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    pub position: CartesianPoint<'a>,
    pub constant_attenuation: f64,
    pub distance_attenuation: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourcePositional<'a> = Id<LightSourcePositional_<'a>>;
pub struct LightSourceSpot_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    pub position: CartesianPoint<'a>,
    pub orientation: Direction<'a>,
    pub concentration_exponent: f64,
    pub constant_attenuation: f64,
    pub distance_attenuation: f64,
    pub spread_angle: PositivePlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourceSpot<'a> = Id<LightSourceSpot_<'a>>;
pub struct LikeExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LikeExpression<'a> = Id<LikeExpression_<'a>>;
pub enum LimitCondition<'a> { // enum
    MaximumMaterialCondition,
    LeastMaterialCondition,
    RegardlessOfFeatureSize,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for LimitCondition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use LimitCondition::*;
        alt((
            map(tag(".MAXIMUM_MATERIAL_CONDITION."), |_| MaximumMaterialCondition),
            map(tag(".LEAST_MATERIAL_CONDITION."), |_| LeastMaterialCondition),
            map(tag(".REGARDLESS_OF_FEATURE_SIZE."), |_| RegardlessOfFeatureSize),
        ))(s)
    }
}
pub struct LimitsAndFits_<'a> { // entity
    pub form_variance: Label<'a>,
    pub zone_variance: Label<'a>,
    pub grade: Label<'a>,
    pub source: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LimitsAndFits<'a> = Id<LimitsAndFits_<'a>>;
pub struct Line_<'a> { // entity
    pub name: Label<'a>,
    pub pnt: CartesianPoint<'a>,
    pub dir: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Line<'a> = Id<Line_<'a>>;
pub struct LineProfileTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LineProfileTolerance<'a> = Id<LineProfileTolerance_<'a>>;
pub struct LinearDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LinearDimension<'a> = Id<LinearDimension_<'a>>;
pub struct ListOfReversibleTopologyItem<'a>(pub Vec<ReversibleTopologyItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for ListOfReversibleTopologyItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<ReversibleTopologyItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct ListRepresentationItem<'a>(pub Vec<RepresentationItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for ListRepresentationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<RepresentationItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct LiteralNumber_<'a> { // entity
    pub the_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LiteralNumber<'a> = Id<LiteralNumber_<'a>>;
pub struct LocalTime_<'a> { // entity
    pub hour_component: HourInDay<'a>,
    pub minute_component: Option<MinuteInHour<'a>>,
    pub second_component: Option<SecondInMinute<'a>>,
    pub zone: CoordinatedUniversalTimeOffset<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LocalTime<'a> = Id<LocalTime_<'a>>;
pub struct LocationShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LocationShapeRepresentation<'a> = Id<LocationShapeRepresentation_<'a>>;
pub struct Locator_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Locator<'a> = Id<Locator_<'a>>;
pub struct Log10Function_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Log10Function<'a> = Id<Log10Function_<'a>>;
pub struct Log2Function_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Log2Function<'a> = Id<Log2Function_<'a>>;
pub struct LogFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LogFunction<'a> = Id<LogFunction_<'a>>;
pub struct Loop_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Loop<'a> = Id<Loop_<'a>>;
pub struct LotEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_lot_id: Identifier<'a>,
    pub effectivity_lot_size: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LotEffectivity<'a> = Id<LotEffectivity_<'a>>;
pub struct LuminousIntensityMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for LuminousIntensityMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> LuminousIntensityMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct LuminousIntensityMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LuminousIntensityMeasureWithUnit<'a> = Id<LuminousIntensityMeasureWithUnit_<'a>>;
pub struct LuminousIntensityUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LuminousIntensityUnit<'a> = Id<LuminousIntensityUnit_<'a>>;
pub struct MakeFromUsageOption_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub ranking: i64,
    pub ranking_rationale: Text<'a>,
    pub quantity: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MakeFromUsageOption<'a> = Id<MakeFromUsageOption_<'a>>;
pub struct ManifoldSolidBrep_<'a> { // entity
    pub name: Label<'a>,
    pub outer: ClosedShell<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ManifoldSolidBrep<'a> = Id<ManifoldSolidBrep_<'a>>;
pub struct ManifoldSubsurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ManifoldSubsurfaceShapeRepresentation<'a> = Id<ManifoldSubsurfaceShapeRepresentation_<'a>>;
pub struct ManifoldSurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ManifoldSurfaceShapeRepresentation<'a> = Id<ManifoldSurfaceShapeRepresentation_<'a>>;
pub struct MappedItem_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MappedItem<'a> = Id<MappedItem_<'a>>;
pub enum MarkerSelect<'a> { // select
    MarkerType(MarkerType<'a>),
    PreDefinedMarker(PreDefinedMarker<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MarkerSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<MarkerType<'a>>::parse, |r| MarkerSelect::MarkerType(r)),
            map(<PreDefinedMarker<'a>>::parse, |r| MarkerSelect::PreDefinedMarker(r)),
        ))(s)
    }
}
pub enum MarkerType<'a> { // enum
    Dot,
    X,
    Plus,
    Asterisk,
    Ring,
    Square,
    Triangle,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for MarkerType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use MarkerType::*;
        alt((
            map(tag(".DOT."), |_| Dot),
            map(tag(".X."), |_| X),
            map(tag(".PLUS."), |_| Plus),
            map(tag(".ASTERISK."), |_| Asterisk),
            map(tag(".RING."), |_| Ring),
            map(tag(".SQUARE."), |_| Square),
            map(tag(".TRIANGLE."), |_| Triangle),
        ))(s)
    }
}
pub struct MassMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MassMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> MassMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct MassMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MassMeasureWithUnit<'a> = Id<MassMeasureWithUnit_<'a>>;
pub struct MassUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MassUnit<'a> = Id<MassUnit_<'a>>;
pub struct MaterialDesignation_<'a> { // entity
    pub name: Label<'a>,
    pub definitions: Vec<CharacterizedDefinition<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialDesignation<'a> = Id<MaterialDesignation_<'a>>;
pub struct MaterialDesignationCharacterization_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub designation: MaterialDesignation<'a>,
    pub property: CharacterizedMaterialProperty<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialDesignationCharacterization<'a> = Id<MaterialDesignationCharacterization_<'a>>;
pub struct MaterialProperty_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialProperty<'a> = Id<MaterialProperty_<'a>>;
pub struct MaterialPropertyRepresentation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub dependent_environment: DataEnvironment<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialPropertyRepresentation<'a> = Id<MaterialPropertyRepresentation_<'a>>;
pub struct MaximumFunction_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaximumFunction<'a> = Id<MaximumFunction_<'a>>;
pub struct MeasureQualification_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub qualified_measure: MeasureWithUnit<'a>,
    pub qualifiers: Vec<ValueQualifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MeasureQualification<'a> = Id<MeasureQualification_<'a>>;
pub struct MeasureRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MeasureRepresentationItem<'a> = Id<MeasureRepresentationItem_<'a>>;
pub enum MeasureValue<'a> { // select
    AmountOfSubstanceMeasure(AmountOfSubstanceMeasure<'a>),
    AreaMeasure(AreaMeasure<'a>),
    CelsiusTemperatureMeasure(CelsiusTemperatureMeasure<'a>),
    ContextDependentMeasure(ContextDependentMeasure<'a>),
    CountMeasure(CountMeasure<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    ElectricCurrentMeasure(ElectricCurrentMeasure<'a>),
    LengthMeasure(LengthMeasure<'a>),
    LuminousIntensityMeasure(LuminousIntensityMeasure<'a>),
    MassMeasure(MassMeasure<'a>),
    NumericMeasure(NumericMeasure<'a>),
    NonNegativeLengthMeasure(NonNegativeLengthMeasure<'a>),
    ParameterValue(ParameterValue<'a>),
    PlaneAngleMeasure(PlaneAngleMeasure<'a>),
    PositiveLengthMeasure(PositiveLengthMeasure<'a>),
    PositivePlaneAngleMeasure(PositivePlaneAngleMeasure<'a>),
    PositiveRatioMeasure(PositiveRatioMeasure<'a>),
    RatioMeasure(RatioMeasure<'a>),
    SolidAngleMeasure(SolidAngleMeasure<'a>),
    ThermodynamicTemperatureMeasure(ThermodynamicTemperatureMeasure<'a>),
    TimeMeasure(TimeMeasure<'a>),
    VolumeMeasure(VolumeMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MeasureValue<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<AmountOfSubstanceMeasure<'a>>::parse, |r| MeasureValue::AmountOfSubstanceMeasure(r)),
            map(<AreaMeasure<'a>>::parse, |r| MeasureValue::AreaMeasure(r)),
            map(<CelsiusTemperatureMeasure<'a>>::parse, |r| MeasureValue::CelsiusTemperatureMeasure(r)),
            map(<ContextDependentMeasure<'a>>::parse, |r| MeasureValue::ContextDependentMeasure(r)),
            map(<CountMeasure<'a>>::parse, |r| MeasureValue::CountMeasure(r)),
            map(<DescriptiveMeasure<'a>>::parse, |r| MeasureValue::DescriptiveMeasure(r)),
            map(<ElectricCurrentMeasure<'a>>::parse, |r| MeasureValue::ElectricCurrentMeasure(r)),
            map(<LengthMeasure<'a>>::parse, |r| MeasureValue::LengthMeasure(r)),
            map(<LuminousIntensityMeasure<'a>>::parse, |r| MeasureValue::LuminousIntensityMeasure(r)),
            map(<MassMeasure<'a>>::parse, |r| MeasureValue::MassMeasure(r)),
            map(<NumericMeasure<'a>>::parse, |r| MeasureValue::NumericMeasure(r)),
            map(<NonNegativeLengthMeasure<'a>>::parse, |r| MeasureValue::NonNegativeLengthMeasure(r)),
            map(<ParameterValue<'a>>::parse, |r| MeasureValue::ParameterValue(r)),
            map(<PlaneAngleMeasure<'a>>::parse, |r| MeasureValue::PlaneAngleMeasure(r)),
            map(<PositiveLengthMeasure<'a>>::parse, |r| MeasureValue::PositiveLengthMeasure(r)),
            map(<PositivePlaneAngleMeasure<'a>>::parse, |r| MeasureValue::PositivePlaneAngleMeasure(r)),
            map(<PositiveRatioMeasure<'a>>::parse, |r| MeasureValue::PositiveRatioMeasure(r)),
            map(<RatioMeasure<'a>>::parse, |r| MeasureValue::RatioMeasure(r)),
            map(<SolidAngleMeasure<'a>>::parse, |r| MeasureValue::SolidAngleMeasure(r)),
        alt((
            map(<ThermodynamicTemperatureMeasure<'a>>::parse, |r| MeasureValue::ThermodynamicTemperatureMeasure(r)),
            map(<TimeMeasure<'a>>::parse, |r| MeasureValue::TimeMeasure(r)),
            map(<VolumeMeasure<'a>>::parse, |r| MeasureValue::VolumeMeasure(r)),
        ))))(s)
    }
}
pub struct MeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MeasureWithUnit<'a> = Id<MeasureWithUnit_<'a>>;
pub struct MechanicalDesignGeometricPresentationArea_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MechanicalDesignGeometricPresentationArea<'a> = Id<MechanicalDesignGeometricPresentationArea_<'a>>;
pub struct MechanicalDesignGeometricPresentationRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MechanicalDesignGeometricPresentationRepresentation<'a> = Id<MechanicalDesignGeometricPresentationRepresentation_<'a>>;
pub struct Mechanism_<'a> { // entity
    pub structure_definition: KinematicStructure<'a>,
    pub base: KinematicLink<'a>,
    pub containing_property: KinematicPropertyDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Mechanism<'a> = Id<Mechanism_<'a>>;
pub struct MechanismBasePlacement_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub transformation_operator: Transformation<'a>,
    pub base_of_mechanism: Mechanism<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MechanismBasePlacement<'a> = Id<MechanismBasePlacement_<'a>>;
pub struct MinimumFunction_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MinimumFunction<'a> = Id<MinimumFunction_<'a>>;
pub struct MinusExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MinusExpression<'a> = Id<MinusExpression_<'a>>;
pub struct MinusFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MinusFunction<'a> = Id<MinusFunction_<'a>>;
pub struct MinuteInHour<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MinuteInHour<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> MinuteInHour<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct ModExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ModExpression<'a> = Id<ModExpression_<'a>>;
pub struct ModifiedGeometricTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub modifier: LimitCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ModifiedGeometricTolerance<'a> = Id<ModifiedGeometricTolerance_<'a>>;
pub struct ModifiedPattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ModifiedPattern<'a> = Id<ModifiedPattern_<'a>>;
pub struct MomentsOfInertiaRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MomentsOfInertiaRepresentation<'a> = Id<MomentsOfInertiaRepresentation_<'a>>;
pub struct MonthInYearNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MonthInYearNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> MonthInYearNumber<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct MotionLinkRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub related_frame: RigidPlacement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MotionLinkRelationship<'a> = Id<MotionLinkRelationship_<'a>>;
pub enum MotionParameterMeasure<'a> { // select
    ParameterValue(ParameterValue<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MotionParameterMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ParameterValue<'a>>::parse, |r| MotionParameterMeasure::ParameterValue(r)),
            map(<MeasureWithUnit<'a>>::parse, |r| MotionParameterMeasure::MeasureWithUnit(r)),
        ))(s)
    }
}
pub struct MultExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultExpression<'a> = Id<MultExpression_<'a>>;
pub struct MultiLanguageAttributeAssignment_<'a> { // entity
    pub attribute_name: Label<'a>,
    pub attribute_value: AttributeType<'a>,
    pub role: AttributeValueRole<'a>,
    pub items: Vec<MultiLanguageAttributeItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultiLanguageAttributeAssignment<'a> = Id<MultiLanguageAttributeAssignment_<'a>>;
pub enum MultiLanguageAttributeItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    AlternateProductRelationship(AlternateProductRelationship<'a>),
    ApplicationContext(ApplicationContext<'a>),
    ApprovalRelationship(ApprovalRelationship<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    Certification(Certification<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    Contract(Contract<'a>),
    DataEnvironment(DataEnvironment<'a>),
    DateRole(DateRole<'a>),
    DateTimeRole(DateTimeRole<'a>),
    DescriptiveRepresentationItem(DescriptiveRepresentationItem<'a>),
    DocumentRelationship(DocumentRelationship<'a>),
    DraughtingTitle(DraughtingTitle<'a>),
    Effectivity(Effectivity<'a>),
    EffectivityRelationship(EffectivityRelationship<'a>),
    EventOccurrence(EventOccurrence<'a>),
    ExternalSource(ExternalSource<'a>),
    GeneralProperty(GeneralProperty<'a>),
    GeneralPropertyRelationship(GeneralPropertyRelationship<'a>),
    GeometricRepresentationItem(GeometricRepresentationItem<'a>),
    GeometricTolerance(GeometricTolerance<'a>),
    Group(Group<'a>),
    GroupRelationship(GroupRelationship<'a>),
    IdentificationRole(IdentificationRole<'a>),
    KinematicPair(KinematicPair<'a>),
    MappedItem(MappedItem<'a>),
    NameAssignment(NameAssignment<'a>),
    OrganizationRelationship(OrganizationRelationship<'a>),
    OrganizationRole(OrganizationRole<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    OrganizationalProjectRelationship(OrganizationalProjectRelationship<'a>),
    PairActuator(PairActuator<'a>),
    PersonAndOrganizationRole(PersonAndOrganizationRole<'a>),
    PresentationLayerAssignment(PresentationLayerAssignment<'a>),
    ProcessProductAssociation(ProcessProductAssociation<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptRelationship(ProductConceptRelationship<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    ProductRelatedProductCategory(ProductRelatedProductCategory<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    PropertyDefinitionRelationship(PropertyDefinitionRelationship<'a>),
    Representation(Representation<'a>),
    RepresentationRelationship(RepresentationRelationship<'a>),
    RequirementForActionResource(RequirementForActionResource<'a>),
    ResourceProperty(ResourceProperty<'a>),
    ResourceRequirementType(ResourceRequirementType<'a>),
    SecurityClassification(SecurityClassification<'a>),
    ShapeAspect(ShapeAspect<'a>),
    ShapeAspectRelationship(ShapeAspectRelationship<'a>),
    StyledItem(StyledItem<'a>),
    TimeIntervalRole(TimeIntervalRole<'a>),
    TopologicalRepresentationItem(TopologicalRepresentationItem<'a>),
    UncertaintyMeasureWithUnit(UncertaintyMeasureWithUnit<'a>),
    UncertaintyQualifier(UncertaintyQualifier<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    VersionedActionRequestRelationship(VersionedActionRequestRelationship<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MultiLanguageAttributeItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| MultiLanguageAttributeItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| MultiLanguageAttributeItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| MultiLanguageAttributeItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| MultiLanguageAttributeItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::ActionRelationship(r)),
            map(<AlternateProductRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::AlternateProductRelationship(r)),
            map(<ApplicationContext<'a>>::parse, |r| MultiLanguageAttributeItem::ApplicationContext(r)),
            map(<ApprovalRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::ApprovalRelationship(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| MultiLanguageAttributeItem::AssemblyComponentUsageSubstitute(r)),
            map(<Certification<'a>>::parse, |r| MultiLanguageAttributeItem::Certification(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| MultiLanguageAttributeItem::ConfigurationDesign(r)),
            map(<ConfigurationItem<'a>>::parse, |r| MultiLanguageAttributeItem::ConfigurationItem(r)),
            map(<Contract<'a>>::parse, |r| MultiLanguageAttributeItem::Contract(r)),
            map(<DataEnvironment<'a>>::parse, |r| MultiLanguageAttributeItem::DataEnvironment(r)),
            map(<DateRole<'a>>::parse, |r| MultiLanguageAttributeItem::DateRole(r)),
            map(<DateTimeRole<'a>>::parse, |r| MultiLanguageAttributeItem::DateTimeRole(r)),
            map(<DescriptiveRepresentationItem<'a>>::parse, |r| MultiLanguageAttributeItem::DescriptiveRepresentationItem(r)),
            map(<DocumentRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::DocumentRelationship(r)),
            map(<DraughtingTitle<'a>>::parse, |r| MultiLanguageAttributeItem::DraughtingTitle(r)),
        alt((
            map(<Effectivity<'a>>::parse, |r| MultiLanguageAttributeItem::Effectivity(r)),
            map(<EffectivityRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::EffectivityRelationship(r)),
            map(<EventOccurrence<'a>>::parse, |r| MultiLanguageAttributeItem::EventOccurrence(r)),
            map(<ExternalSource<'a>>::parse, |r| MultiLanguageAttributeItem::ExternalSource(r)),
            map(<GeneralProperty<'a>>::parse, |r| MultiLanguageAttributeItem::GeneralProperty(r)),
            map(<GeneralPropertyRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::GeneralPropertyRelationship(r)),
            map(<GeometricRepresentationItem<'a>>::parse, |r| MultiLanguageAttributeItem::GeometricRepresentationItem(r)),
            map(<GeometricTolerance<'a>>::parse, |r| MultiLanguageAttributeItem::GeometricTolerance(r)),
            map(<Group<'a>>::parse, |r| MultiLanguageAttributeItem::Group(r)),
            map(<GroupRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::GroupRelationship(r)),
            map(<IdentificationRole<'a>>::parse, |r| MultiLanguageAttributeItem::IdentificationRole(r)),
            map(<KinematicPair<'a>>::parse, |r| MultiLanguageAttributeItem::KinematicPair(r)),
            map(<MappedItem<'a>>::parse, |r| MultiLanguageAttributeItem::MappedItem(r)),
            map(<NameAssignment<'a>>::parse, |r| MultiLanguageAttributeItem::NameAssignment(r)),
            map(<OrganizationRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::OrganizationRelationship(r)),
            map(<OrganizationRole<'a>>::parse, |r| MultiLanguageAttributeItem::OrganizationRole(r)),
            map(<OrganizationalProject<'a>>::parse, |r| MultiLanguageAttributeItem::OrganizationalProject(r)),
            map(<OrganizationalProjectRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::OrganizationalProjectRelationship(r)),
            map(<PairActuator<'a>>::parse, |r| MultiLanguageAttributeItem::PairActuator(r)),
        alt((
            map(<PersonAndOrganizationRole<'a>>::parse, |r| MultiLanguageAttributeItem::PersonAndOrganizationRole(r)),
            map(<PresentationLayerAssignment<'a>>::parse, |r| MultiLanguageAttributeItem::PresentationLayerAssignment(r)),
            map(<ProcessProductAssociation<'a>>::parse, |r| MultiLanguageAttributeItem::ProcessProductAssociation(r)),
            map(<Product<'a>>::parse, |r| MultiLanguageAttributeItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| MultiLanguageAttributeItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| MultiLanguageAttributeItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| MultiLanguageAttributeItem::ProductConceptFeatureAssociation(r)),
            map(<ProductConceptRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::ProductConceptRelationship(r)),
            map(<ProductDefinition<'a>>::parse, |r| MultiLanguageAttributeItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| MultiLanguageAttributeItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| MultiLanguageAttributeItem::ProductDefinitionSubstitute(r)),
            map(<ProductRelatedProductCategory<'a>>::parse, |r| MultiLanguageAttributeItem::ProductRelatedProductCategory(r)),
            map(<PropertyDefinition<'a>>::parse, |r| MultiLanguageAttributeItem::PropertyDefinition(r)),
            map(<PropertyDefinitionRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::PropertyDefinitionRelationship(r)),
            map(<Representation<'a>>::parse, |r| MultiLanguageAttributeItem::Representation(r)),
            map(<RepresentationRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::RepresentationRelationship(r)),
            map(<RequirementForActionResource<'a>>::parse, |r| MultiLanguageAttributeItem::RequirementForActionResource(r)),
        alt((
            map(<ResourceProperty<'a>>::parse, |r| MultiLanguageAttributeItem::ResourceProperty(r)),
            map(<ResourceRequirementType<'a>>::parse, |r| MultiLanguageAttributeItem::ResourceRequirementType(r)),
            map(<SecurityClassification<'a>>::parse, |r| MultiLanguageAttributeItem::SecurityClassification(r)),
            map(<ShapeAspect<'a>>::parse, |r| MultiLanguageAttributeItem::ShapeAspect(r)),
            map(<ShapeAspectRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::ShapeAspectRelationship(r)),
            map(<StyledItem<'a>>::parse, |r| MultiLanguageAttributeItem::StyledItem(r)),
            map(<TimeIntervalRole<'a>>::parse, |r| MultiLanguageAttributeItem::TimeIntervalRole(r)),
            map(<TopologicalRepresentationItem<'a>>::parse, |r| MultiLanguageAttributeItem::TopologicalRepresentationItem(r)),
            map(<UncertaintyMeasureWithUnit<'a>>::parse, |r| MultiLanguageAttributeItem::UncertaintyMeasureWithUnit(r)),
            map(<UncertaintyQualifier<'a>>::parse, |r| MultiLanguageAttributeItem::UncertaintyQualifier(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| MultiLanguageAttributeItem::VersionedActionRequest(r)),
            map(<VersionedActionRequestRelationship<'a>>::parse, |r| MultiLanguageAttributeItem::VersionedActionRequestRelationship(r)),
        ))))))))(s)
    }
}
pub struct MultipleArityBooleanExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityBooleanExpression<'a> = Id<MultipleArityBooleanExpression_<'a>>;
pub struct MultipleArityFunctionCall_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityFunctionCall<'a> = Id<MultipleArityFunctionCall_<'a>>;
pub struct MultipleArityGenericExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityGenericExpression<'a> = Id<MultipleArityGenericExpression_<'a>>;
pub struct MultipleArityNumericExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityNumericExpression<'a> = Id<MultipleArityNumericExpression_<'a>>;
pub struct NameAssignment_<'a> { // entity
    pub assigned_name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NameAssignment<'a> = Id<NameAssignment_<'a>>;
pub struct NameAttribute_<'a> { // entity
    pub attribute_value: Label<'a>,
    pub named_item: NameAttributeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NameAttribute<'a> = Id<NameAttribute_<'a>>;
pub enum NameAttributeSelect<'a> { // select
    ActionRequestSolution(ActionRequestSolution<'a>),
    Address(Address<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ContextDependentShapeRepresentation(ContextDependentShapeRepresentation<'a>),
    DerivedUnit(DerivedUnit<'a>),
    Effectivity(Effectivity<'a>),
    PersonAndOrganization(PersonAndOrganization<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    PropertyDefinitionRepresentation(PropertyDefinitionRepresentation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for NameAttributeSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ActionRequestSolution<'a>>::parse, |r| NameAttributeSelect::ActionRequestSolution(r)),
            map(<Address<'a>>::parse, |r| NameAttributeSelect::Address(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| NameAttributeSelect::ConfigurationDesign(r)),
            map(<ContextDependentShapeRepresentation<'a>>::parse, |r| NameAttributeSelect::ContextDependentShapeRepresentation(r)),
            map(<DerivedUnit<'a>>::parse, |r| NameAttributeSelect::DerivedUnit(r)),
            map(<Effectivity<'a>>::parse, |r| NameAttributeSelect::Effectivity(r)),
            map(<PersonAndOrganization<'a>>::parse, |r| NameAttributeSelect::PersonAndOrganization(r)),
            map(<ProductDefinition<'a>>::parse, |r| NameAttributeSelect::ProductDefinition(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| NameAttributeSelect::ProductDefinitionSubstitute(r)),
            map(<PropertyDefinitionRepresentation<'a>>::parse, |r| NameAttributeSelect::PropertyDefinitionRepresentation(r)),
        ))(s)
    }
}
pub enum NameItem<'a> { // select
    KinematicJoint(KinematicJoint<'a>),
    KinematicLink(KinematicLink<'a>),
    KinematicStructure(KinematicStructure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for NameItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<KinematicJoint<'a>>::parse, |r| NameItem::KinematicJoint(r)),
            map(<KinematicLink<'a>>::parse, |r| NameItem::KinematicLink(r)),
            map(<KinematicStructure<'a>>::parse, |r| NameItem::KinematicStructure(r)),
        ))(s)
    }
}
pub struct NamedUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NamedUnit<'a> = Id<NamedUnit_<'a>>;
pub struct NamedUnitVariable_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NamedUnitVariable<'a> = Id<NamedUnitVariable_<'a>>;
pub struct NextAssemblyUsageOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NextAssemblyUsageOccurrence<'a> = Id<NextAssemblyUsageOccurrence_<'a>>;
pub struct NgonClosedProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NgonClosedProfile<'a> = Id<NgonClosedProfile_<'a>>;
pub struct NonManifoldSurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NonManifoldSurfaceShapeRepresentation<'a> = Id<NonManifoldSurfaceShapeRepresentation_<'a>>;

pub struct NonNegativeLengthMeasure<'a>(pub LengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for NonNegativeLengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("NON_NEGATIVE_LENGTH_MEASURE("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> NonNegativeLengthMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(LengthMeasure::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct NotExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NotExpression<'a> = Id<NotExpression_<'a>>;
pub enum NullStyle<'a> { // enum
    Null,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for NullStyle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use NullStyle::*;
        map(tag(".NULL."), |_| Null)(s)
    }
}
pub struct NumericDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NumericDefinedFunction<'a> = Id<NumericDefinedFunction_<'a>>;
pub struct NumericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NumericExpression<'a> = Id<NumericExpression_<'a>>;
pub struct NumericMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for NumericMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> NumericMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct NumericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NumericVariable<'a> = Id<NumericVariable_<'a>>;
pub struct ObjectRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ObjectRole<'a> = Id<ObjectRole_<'a>>;
pub struct OddFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OddFunction<'a> = Id<OddFunction_<'a>>;
pub struct OffsetCurve2d_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub distance: LengthMeasure<'a>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OffsetCurve2d<'a> = Id<OffsetCurve2d_<'a>>;
pub struct OffsetCurve3d_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub distance: LengthMeasure<'a>,
    pub self_intersect: Option<bool>,
    pub ref_direction: Direction<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OffsetCurve3d<'a> = Id<OffsetCurve3d_<'a>>;
pub struct OffsetSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub distance: LengthMeasure<'a>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OffsetSurface<'a> = Id<OffsetSurface_<'a>>;
pub struct OneDirectionRepeatFactor_<'a> { // entity
    pub name: Label<'a>,
    pub repeat_factor: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OneDirectionRepeatFactor<'a> = Id<OneDirectionRepeatFactor_<'a>>;
pub struct OpenPathProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OpenPathProfile<'a> = Id<OpenPathProfile_<'a>>;
pub struct OpenShell_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OpenShell<'a> = Id<OpenShell_<'a>>;
pub struct OrExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrExpression<'a> = Id<OrExpression_<'a>>;
pub struct OrdinateDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrdinateDimension<'a> = Id<OrdinateDimension_<'a>>;
pub struct Organization_<'a> { // entity
    pub id: Option<Identifier<'a>>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Organization<'a> = Id<Organization_<'a>>;
pub struct OrganizationAssignment_<'a> { // entity
    pub assigned_organization: Organization<'a>,
    pub role: OrganizationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationAssignment<'a> = Id<OrganizationAssignment_<'a>>;
pub enum OrganizationItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    ActionRequestSolution(ActionRequestSolution<'a>),
    AlternateProductRelationship(AlternateProductRelationship<'a>),
    AppliedActionAssignment(AppliedActionAssignment<'a>),
    AppliedClassificationAssignment(AppliedClassificationAssignment<'a>),
    AppliedIdentificationAssignment(AppliedIdentificationAssignment<'a>),
    AppliedOrganizationAssignment(AppliedOrganizationAssignment<'a>),
    AppliedPersonAndOrganizationAssignment(AppliedPersonAndOrganizationAssignment<'a>),
    Approval(Approval<'a>),
    ApprovalStatus(ApprovalStatus<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    Certification(Certification<'a>),
    Class(Class<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationEffectivity(ConfigurationEffectivity<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment<'a>),
    Contract(Contract<'a>),
    DocumentFile(DocumentFile<'a>),
    DocumentType(DocumentType<'a>),
    DraughtingModel(DraughtingModel<'a>),
    DrawingRevision(DrawingRevision<'a>),
    Effectivity(Effectivity<'a>),
    EventOccurrence(EventOccurrence<'a>),
    ExecutedAction(ExecutedAction<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    Organization(Organization<'a>),
    OrganizationRelationship(OrganizationRelationship<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PersonAndOrganization(PersonAndOrganization<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    RequirementForActionResource(RequirementForActionResource<'a>),
    ResourceProperty(ResourceProperty<'a>),
    SecurityClassification(SecurityClassification<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for OrganizationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| OrganizationItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| OrganizationItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| OrganizationItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| OrganizationItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| OrganizationItem::ActionRelationship(r)),
            map(<ActionRequestSolution<'a>>::parse, |r| OrganizationItem::ActionRequestSolution(r)),
            map(<AlternateProductRelationship<'a>>::parse, |r| OrganizationItem::AlternateProductRelationship(r)),
            map(<AppliedActionAssignment<'a>>::parse, |r| OrganizationItem::AppliedActionAssignment(r)),
            map(<AppliedClassificationAssignment<'a>>::parse, |r| OrganizationItem::AppliedClassificationAssignment(r)),
            map(<AppliedIdentificationAssignment<'a>>::parse, |r| OrganizationItem::AppliedIdentificationAssignment(r)),
            map(<AppliedOrganizationAssignment<'a>>::parse, |r| OrganizationItem::AppliedOrganizationAssignment(r)),
            map(<AppliedPersonAndOrganizationAssignment<'a>>::parse, |r| OrganizationItem::AppliedPersonAndOrganizationAssignment(r)),
            map(<Approval<'a>>::parse, |r| OrganizationItem::Approval(r)),
            map(<ApprovalStatus<'a>>::parse, |r| OrganizationItem::ApprovalStatus(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| OrganizationItem::AssemblyComponentUsageSubstitute(r)),
            map(<Certification<'a>>::parse, |r| OrganizationItem::Certification(r)),
            map(<Class<'a>>::parse, |r| OrganizationItem::Class(r)),
            map(<ClassSystem<'a>>::parse, |r| OrganizationItem::ClassSystem(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| OrganizationItem::ConfigurationDesign(r)),
        alt((
            map(<ConfigurationEffectivity<'a>>::parse, |r| OrganizationItem::ConfigurationEffectivity(r)),
            map(<ConfigurationItem<'a>>::parse, |r| OrganizationItem::ConfigurationItem(r)),
            map(<ConfiguredEffectivityAssignment<'a>>::parse, |r| OrganizationItem::ConfiguredEffectivityAssignment(r)),
            map(<Contract<'a>>::parse, |r| OrganizationItem::Contract(r)),
            map(<DocumentFile<'a>>::parse, |r| OrganizationItem::DocumentFile(r)),
            map(<DocumentType<'a>>::parse, |r| OrganizationItem::DocumentType(r)),
            map(<DraughtingModel<'a>>::parse, |r| OrganizationItem::DraughtingModel(r)),
            map(<DrawingRevision<'a>>::parse, |r| OrganizationItem::DrawingRevision(r)),
            map(<Effectivity<'a>>::parse, |r| OrganizationItem::Effectivity(r)),
            map(<EventOccurrence<'a>>::parse, |r| OrganizationItem::EventOccurrence(r)),
            map(<ExecutedAction<'a>>::parse, |r| OrganizationItem::ExecutedAction(r)),
            map(<GeneralProperty<'a>>::parse, |r| OrganizationItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| OrganizationItem::MaterialDesignation(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| OrganizationItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<Organization<'a>>::parse, |r| OrganizationItem::Organization(r)),
            map(<OrganizationRelationship<'a>>::parse, |r| OrganizationItem::OrganizationRelationship(r)),
            map(<OrganizationalProject<'a>>::parse, |r| OrganizationItem::OrganizationalProject(r)),
            map(<PersonAndOrganization<'a>>::parse, |r| OrganizationItem::PersonAndOrganization(r)),
            map(<PresentationArea<'a>>::parse, |r| OrganizationItem::PresentationArea(r)),
        alt((
            map(<Product<'a>>::parse, |r| OrganizationItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| OrganizationItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| OrganizationItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| OrganizationItem::ProductConceptFeatureAssociation(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| OrganizationItem::ProductConceptFeatureCategory(r)),
            map(<ProductConceptFeatureCategoryUsage<'a>>::parse, |r| OrganizationItem::ProductConceptFeatureCategoryUsage(r)),
            map(<ProductDefinition<'a>>::parse, |r| OrganizationItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| OrganizationItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| OrganizationItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| OrganizationItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| OrganizationItem::ProductDefinitionSubstitute(r)),
            map(<PropertyDefinition<'a>>::parse, |r| OrganizationItem::PropertyDefinition(r)),
            map(<RequirementForActionResource<'a>>::parse, |r| OrganizationItem::RequirementForActionResource(r)),
            map(<ResourceProperty<'a>>::parse, |r| OrganizationItem::ResourceProperty(r)),
            map(<SecurityClassification<'a>>::parse, |r| OrganizationItem::SecurityClassification(r)),
            map(<SecurityClassificationLevel<'a>>::parse, |r| OrganizationItem::SecurityClassificationLevel(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| OrganizationItem::ShapeRepresentation(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| OrganizationItem::VersionedActionRequest(r)),
        ))))))(s)
    }
}
pub struct OrganizationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_organization: Organization<'a>,
    pub related_organization: Organization<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationRelationship<'a> = Id<OrganizationRelationship_<'a>>;
pub struct OrganizationRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationRole<'a> = Id<OrganizationRole_<'a>>;
pub struct OrganizationalAddress_<'a> { // entity
    pub internal_location: Option<Label<'a>>,
    pub street_number: Option<Label<'a>>,
    pub street: Option<Label<'a>>,
    pub postal_box: Option<Label<'a>>,
    pub town: Option<Label<'a>>,
    pub region: Option<Label<'a>>,
    pub postal_code: Option<Label<'a>>,
    pub country: Option<Label<'a>>,
    pub facsimile_number: Option<Label<'a>>,
    pub telephone_number: Option<Label<'a>>,
    pub electronic_mail_address: Option<Label<'a>>,
    pub telex_number: Option<Label<'a>>,
    pub organizations: Vec<Organization<'a>>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalAddress<'a> = Id<OrganizationalAddress_<'a>>;
pub struct OrganizationalProject_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub responsible_organizations: Vec<Organization<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProject<'a> = Id<OrganizationalProject_<'a>>;
pub struct OrganizationalProjectAssignment_<'a> { // entity
    pub assigned_organizational_project: OrganizationalProject<'a>,
    pub role: OrganizationalProjectRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProjectAssignment<'a> = Id<OrganizationalProjectAssignment_<'a>>;
pub enum OrganizationalProjectItem<'a> { // select
    AssemblyComponentUsage(AssemblyComponentUsage<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    ExecutedAction(ExecutedAction<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for OrganizationalProjectItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<AssemblyComponentUsage<'a>>::parse, |r| OrganizationalProjectItem::AssemblyComponentUsage(r)),
            map(<ConfigurationItem<'a>>::parse, |r| OrganizationalProjectItem::ConfigurationItem(r)),
            map(<ExecutedAction<'a>>::parse, |r| OrganizationalProjectItem::ExecutedAction(r)),
            map(<Product<'a>>::parse, |r| OrganizationalProjectItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| OrganizationalProjectItem::ProductConcept(r)),
            map(<ProductDefinition<'a>>::parse, |r| OrganizationalProjectItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| OrganizationalProjectItem::ProductDefinitionFormation(r)),
        ))(s)
    }
}
pub struct OrganizationalProjectRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_organizational_project: OrganizationalProject<'a>,
    pub related_organizational_project: OrganizationalProject<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProjectRelationship<'a> = Id<OrganizationalProjectRelationship_<'a>>;
pub struct OrganizationalProjectRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProjectRole<'a> = Id<OrganizationalProjectRole_<'a>>;
pub struct OrientedClosedShell_<'a> { // entity
    pub name: Label<'a>,
    pub closed_shell_element: ClosedShell<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedClosedShell<'a> = Id<OrientedClosedShell_<'a>>;
pub struct OrientedEdge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_element: Edge<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedEdge<'a> = Id<OrientedEdge_<'a>>;
pub struct OrientedFace_<'a> { // entity
    pub name: Label<'a>,
    pub face_element: Face<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedFace<'a> = Id<OrientedFace_<'a>>;
pub struct OrientedOpenShell_<'a> { // entity
    pub name: Label<'a>,
    pub open_shell_element: OpenShell<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedOpenShell<'a> = Id<OrientedOpenShell_<'a>>;
pub struct OrientedPath_<'a> { // entity
    pub name: Label<'a>,
    pub path_element: Path<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedPath<'a> = Id<OrientedPath_<'a>>;
pub struct OrientedSurface_<'a> { // entity
    pub name: Label<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedSurface<'a> = Id<OrientedSurface_<'a>>;
pub struct OuterBoundaryCurve_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OuterBoundaryCurve<'a> = Id<OuterBoundaryCurve_<'a>>;
pub struct OverRidingStyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub over_ridden_style: StyledItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OverRidingStyledItem<'a> = Id<OverRidingStyledItem_<'a>>;
pub struct PackageProductConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PackageProductConceptFeature<'a> = Id<PackageProductConceptFeature_<'a>>;
pub struct PairActuator_<'a> { // entity
    pub actuated_pair: KinematicPair<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PairActuator<'a> = Id<PairActuator_<'a>>;
pub struct PairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PairValue<'a> = Id<PairValue_<'a>>;
pub struct Parabola_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub focal_dist: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Parabola<'a> = Id<Parabola_<'a>>;
pub struct ParallelOffset_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    pub offset: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ParallelOffset<'a> = Id<ParallelOffset_<'a>>;
pub struct ParallelismTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ParallelismTolerance<'a> = Id<ParallelismTolerance_<'a>>;
pub struct ParameterValue<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ParameterValue<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> ParameterValue<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct ParametricRepresentationContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ParametricRepresentationContext<'a> = Id<ParametricRepresentationContext_<'a>>;
pub struct PartialCircularProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PartialCircularProfile<'a> = Id<PartialCircularProfile_<'a>>;
pub struct Path_<'a> { // entity
    pub name: Label<'a>,
    pub edge_list: Vec<OrientedEdge<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Path<'a> = Id<Path_<'a>>;
pub struct PathFeatureComponent_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PathFeatureComponent<'a> = Id<PathFeatureComponent_<'a>>;
pub struct PathShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PathShapeRepresentation<'a> = Id<PathShapeRepresentation_<'a>>;
pub struct PatternOffsetMembership_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PatternOffsetMembership<'a> = Id<PatternOffsetMembership_<'a>>;
pub struct PatternOmitMembership_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PatternOmitMembership<'a> = Id<PatternOmitMembership_<'a>>;
pub struct Pcurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Pcurve<'a> = Id<Pcurve_<'a>>;
pub enum PcurveOrSurface<'a> { // select
    Pcurve(Pcurve<'a>),
    Surface(Surface<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PcurveOrSurface<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Pcurve<'a>>::parse, |r| PcurveOrSurface::Pcurve(r)),
            map(<Surface<'a>>::parse, |r| PcurveOrSurface::Surface(r)),
        ))(s)
    }
}
pub struct PerpendicularTo_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PerpendicularTo<'a> = Id<PerpendicularTo_<'a>>;
pub struct PerpendicularityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PerpendicularityTolerance<'a> = Id<PerpendicularityTolerance_<'a>>;
pub struct Person_<'a> { // entity
    pub id: Identifier<'a>,
    pub last_name: Option<Label<'a>>,
    pub first_name: Option<Label<'a>>,
    pub middle_names: Option<Vec<Label<'a>>>,
    pub prefix_titles: Option<Vec<Label<'a>>>,
    pub suffix_titles: Option<Vec<Label<'a>>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Person<'a> = Id<Person_<'a>>;
pub struct PersonAndOrganization_<'a> { // entity
    pub the_person: Person<'a>,
    pub the_organization: Organization<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganization<'a> = Id<PersonAndOrganization_<'a>>;
#[allow(non_snake_case)]
pub struct PersonAndOrganizationAddress_<'a> { // entity
    pub internal_location: Option<Label<'a>>,
    pub street_number: Option<Label<'a>>,
    pub street: Option<Label<'a>>,
    pub postal_box: Option<Label<'a>>,
    pub town: Option<Label<'a>>,
    pub region: Option<Label<'a>>,
    pub postal_code: Option<Label<'a>>,
    pub country: Option<Label<'a>>,
    pub facsimile_number: Option<Label<'a>>,
    pub telephone_number: Option<Label<'a>>,
    pub electronic_mail_address: Option<Label<'a>>,
    pub telex_number: Option<Label<'a>>,
    pub organizations: Vec<Organization<'a>>,
    pub organizational_address__description: Option<Text<'a>>,
    pub people: Vec<Person<'a>>,
    pub personal_address__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganizationAddress<'a> = Id<PersonAndOrganizationAddress_<'a>>;
pub struct PersonAndOrganizationAssignment_<'a> { // entity
    pub assigned_person_and_organization: PersonAndOrganization<'a>,
    pub role: PersonAndOrganizationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganizationAssignment<'a> = Id<PersonAndOrganizationAssignment_<'a>>;
pub enum PersonAndOrganizationItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    ActionRequestSolution(ActionRequestSolution<'a>),
    AlternateProductRelationship(AlternateProductRelationship<'a>),
    AppliedActionAssignment(AppliedActionAssignment<'a>),
    AppliedClassificationAssignment(AppliedClassificationAssignment<'a>),
    AppliedOrganizationAssignment(AppliedOrganizationAssignment<'a>),
    AppliedPersonAndOrganizationAssignment(AppliedPersonAndOrganizationAssignment<'a>),
    ApprovalStatus(ApprovalStatus<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    Certification(Certification<'a>),
    Class(Class<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationEffectivity(ConfigurationEffectivity<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment<'a>),
    Contract(Contract<'a>),
    DocumentFile(DocumentFile<'a>),
    DocumentType(DocumentType<'a>),
    DraughtingModel(DraughtingModel<'a>),
    DrawingRevision(DrawingRevision<'a>),
    EventOccurrence(EventOccurrence<'a>),
    ExecutedAction(ExecutedAction<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    Organization(Organization<'a>),
    OrganizationRelationship(OrganizationRelationship<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PersonAndOrganization(PersonAndOrganization<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    RequirementForActionResource(RequirementForActionResource<'a>),
    ResourceProperty(ResourceProperty<'a>),
    SecurityClassification(SecurityClassification<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PersonAndOrganizationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| PersonAndOrganizationItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| PersonAndOrganizationItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| PersonAndOrganizationItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| PersonAndOrganizationItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| PersonAndOrganizationItem::ActionRelationship(r)),
            map(<ActionRequestSolution<'a>>::parse, |r| PersonAndOrganizationItem::ActionRequestSolution(r)),
            map(<AlternateProductRelationship<'a>>::parse, |r| PersonAndOrganizationItem::AlternateProductRelationship(r)),
            map(<AppliedActionAssignment<'a>>::parse, |r| PersonAndOrganizationItem::AppliedActionAssignment(r)),
            map(<AppliedClassificationAssignment<'a>>::parse, |r| PersonAndOrganizationItem::AppliedClassificationAssignment(r)),
            map(<AppliedOrganizationAssignment<'a>>::parse, |r| PersonAndOrganizationItem::AppliedOrganizationAssignment(r)),
            map(<AppliedPersonAndOrganizationAssignment<'a>>::parse, |r| PersonAndOrganizationItem::AppliedPersonAndOrganizationAssignment(r)),
            map(<ApprovalStatus<'a>>::parse, |r| PersonAndOrganizationItem::ApprovalStatus(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| PersonAndOrganizationItem::AssemblyComponentUsageSubstitute(r)),
            map(<Certification<'a>>::parse, |r| PersonAndOrganizationItem::Certification(r)),
            map(<Class<'a>>::parse, |r| PersonAndOrganizationItem::Class(r)),
            map(<ClassSystem<'a>>::parse, |r| PersonAndOrganizationItem::ClassSystem(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| PersonAndOrganizationItem::ConfigurationDesign(r)),
            map(<ConfigurationEffectivity<'a>>::parse, |r| PersonAndOrganizationItem::ConfigurationEffectivity(r)),
            map(<ConfigurationItem<'a>>::parse, |r| PersonAndOrganizationItem::ConfigurationItem(r)),
        alt((
            map(<ConfiguredEffectivityAssignment<'a>>::parse, |r| PersonAndOrganizationItem::ConfiguredEffectivityAssignment(r)),
            map(<Contract<'a>>::parse, |r| PersonAndOrganizationItem::Contract(r)),
            map(<DocumentFile<'a>>::parse, |r| PersonAndOrganizationItem::DocumentFile(r)),
            map(<DocumentType<'a>>::parse, |r| PersonAndOrganizationItem::DocumentType(r)),
            map(<DraughtingModel<'a>>::parse, |r| PersonAndOrganizationItem::DraughtingModel(r)),
            map(<DrawingRevision<'a>>::parse, |r| PersonAndOrganizationItem::DrawingRevision(r)),
            map(<EventOccurrence<'a>>::parse, |r| PersonAndOrganizationItem::EventOccurrence(r)),
            map(<ExecutedAction<'a>>::parse, |r| PersonAndOrganizationItem::ExecutedAction(r)),
            map(<GeneralProperty<'a>>::parse, |r| PersonAndOrganizationItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| PersonAndOrganizationItem::MaterialDesignation(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| PersonAndOrganizationItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<Organization<'a>>::parse, |r| PersonAndOrganizationItem::Organization(r)),
            map(<OrganizationRelationship<'a>>::parse, |r| PersonAndOrganizationItem::OrganizationRelationship(r)),
            map(<OrganizationalProject<'a>>::parse, |r| PersonAndOrganizationItem::OrganizationalProject(r)),
            map(<PersonAndOrganization<'a>>::parse, |r| PersonAndOrganizationItem::PersonAndOrganization(r)),
            map(<PresentationArea<'a>>::parse, |r| PersonAndOrganizationItem::PresentationArea(r)),
            map(<Product<'a>>::parse, |r| PersonAndOrganizationItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| PersonAndOrganizationItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| PersonAndOrganizationItem::ProductConceptFeature(r)),
        alt((
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| PersonAndOrganizationItem::ProductConceptFeatureAssociation(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| PersonAndOrganizationItem::ProductConceptFeatureCategory(r)),
            map(<ProductConceptFeatureCategoryUsage<'a>>::parse, |r| PersonAndOrganizationItem::ProductConceptFeatureCategoryUsage(r)),
            map(<ProductDefinition<'a>>::parse, |r| PersonAndOrganizationItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| PersonAndOrganizationItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| PersonAndOrganizationItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| PersonAndOrganizationItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| PersonAndOrganizationItem::ProductDefinitionSubstitute(r)),
            map(<PropertyDefinition<'a>>::parse, |r| PersonAndOrganizationItem::PropertyDefinition(r)),
            map(<RequirementForActionResource<'a>>::parse, |r| PersonAndOrganizationItem::RequirementForActionResource(r)),
            map(<ResourceProperty<'a>>::parse, |r| PersonAndOrganizationItem::ResourceProperty(r)),
            map(<SecurityClassification<'a>>::parse, |r| PersonAndOrganizationItem::SecurityClassification(r)),
            map(<SecurityClassificationLevel<'a>>::parse, |r| PersonAndOrganizationItem::SecurityClassificationLevel(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| PersonAndOrganizationItem::ShapeRepresentation(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| PersonAndOrganizationItem::VersionedActionRequest(r)),
        ))))))(s)
    }
}
pub struct PersonAndOrganizationRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganizationRole<'a> = Id<PersonAndOrganizationRole_<'a>>;
pub enum PersonOrganizationSelect<'a> { // select
    Person(Person<'a>),
    Organization(Organization<'a>),
    PersonAndOrganization(PersonAndOrganization<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PersonOrganizationSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Person<'a>>::parse, |r| PersonOrganizationSelect::Person(r)),
            map(<Organization<'a>>::parse, |r| PersonOrganizationSelect::Organization(r)),
            map(<PersonAndOrganization<'a>>::parse, |r| PersonOrganizationSelect::PersonAndOrganization(r)),
        ))(s)
    }
}
pub struct PersonalAddress_<'a> { // entity
    pub internal_location: Option<Label<'a>>,
    pub street_number: Option<Label<'a>>,
    pub street: Option<Label<'a>>,
    pub postal_box: Option<Label<'a>>,
    pub town: Option<Label<'a>>,
    pub region: Option<Label<'a>>,
    pub postal_code: Option<Label<'a>>,
    pub country: Option<Label<'a>>,
    pub facsimile_number: Option<Label<'a>>,
    pub telephone_number: Option<Label<'a>>,
    pub electronic_mail_address: Option<Label<'a>>,
    pub telex_number: Option<Label<'a>>,
    pub people: Vec<Person<'a>>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonalAddress<'a> = Id<PersonalAddress_<'a>>;
pub struct PhysicallyModelledProductDefinition_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    pub documentation_ids: Vec<Document<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PhysicallyModelledProductDefinition<'a> = Id<PhysicallyModelledProductDefinition_<'a>>;
pub struct PlacedDatumTargetFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    pub target_id: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlacedDatumTargetFeature<'a> = Id<PlacedDatumTargetFeature_<'a>>;
pub struct PlacedFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlacedFeature<'a> = Id<PlacedFeature_<'a>>;
pub struct Placement_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Placement<'a> = Id<Placement_<'a>>;
pub struct PlanarBox_<'a> { // entity
    pub name: Label<'a>,
    pub size_in_x: LengthMeasure<'a>,
    pub size_in_y: LengthMeasure<'a>,
    pub placement: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarBox<'a> = Id<PlanarBox_<'a>>;
pub struct PlanarCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub curve_1: Curve<'a>,
    pub curve_2: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarCurvePair<'a> = Id<PlanarCurvePair_<'a>>;
pub struct PlanarCurvePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_curve_1: TrimmedCurve<'a>,
    pub range_on_curve_2: TrimmedCurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarCurvePairRange<'a> = Id<PlanarCurvePairRange_<'a>>;
pub struct PlanarExtent_<'a> { // entity
    pub name: Label<'a>,
    pub size_in_x: LengthMeasure<'a>,
    pub size_in_y: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarExtent<'a> = Id<PlanarExtent_<'a>>;
pub struct PlanarPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarPair<'a> = Id<PlanarPair_<'a>>;
pub struct PlanarPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub lower_limit_actual_translation_x: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation_x: TranslationalRangeMeasure<'a>,
    pub lower_limit_actual_translation_y: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation_y: TranslationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarPairRange<'a> = Id<PlanarPairRange_<'a>>;
pub struct PlanarPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    pub actual_translation_x: LengthMeasure<'a>,
    pub actual_translation_y: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarPairValue<'a> = Id<PlanarPairValue_<'a>>;
pub struct PlanarShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarShapeRepresentation<'a> = Id<PlanarShapeRepresentation_<'a>>;
pub struct Plane_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Plane<'a> = Id<Plane_<'a>>;
pub struct PlaneAngleMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for PlaneAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> PlaneAngleMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct PlaneAngleMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlaneAngleMeasureWithUnit<'a> = Id<PlaneAngleMeasureWithUnit_<'a>>;
pub struct PlaneAngleUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlaneAngleUnit<'a> = Id<PlaneAngleUnit_<'a>>;
pub enum PlaneOrPlanarBox<'a> { // select
    Plane(Plane<'a>),
    PlanarBox(PlanarBox<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PlaneOrPlanarBox<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Plane<'a>>::parse, |r| PlaneOrPlanarBox::Plane(r)),
            map(<PlanarBox<'a>>::parse, |r| PlaneOrPlanarBox::PlanarBox(r)),
        ))(s)
    }
}
pub struct PlusExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlusExpression<'a> = Id<PlusExpression_<'a>>;
pub struct PlusMinusTolerance_<'a> { // entity
    pub range: ToleranceMethodDefinition<'a>,
    pub toleranced_dimension: DimensionalCharacteristic<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlusMinusTolerance<'a> = Id<PlusMinusTolerance_<'a>>;
pub struct Pocket_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Pocket<'a> = Id<Pocket_<'a>>;
pub struct PocketBottom_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PocketBottom<'a> = Id<PocketBottom_<'a>>;
pub struct Point_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Point<'a> = Id<Point_<'a>>;
pub struct PointOnCurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub point_parameter: ParameterValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnCurve<'a> = Id<PointOnCurve_<'a>>;
pub struct PointOnPlanarCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pair_curve: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnPlanarCurvePair<'a> = Id<PointOnPlanarCurvePair_<'a>>;
pub struct PointOnPlanarCurvePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_pair_curve: TrimmedCurve<'a>,
    pub lower_limit_yaw: RotationalRangeMeasure<'a>,
    pub upper_limit_yaw: RotationalRangeMeasure<'a>,
    pub lower_limit_pitch: RotationalRangeMeasure<'a>,
    pub upper_limit_pitch: RotationalRangeMeasure<'a>,
    pub lower_limit_roll: RotationalRangeMeasure<'a>,
    pub upper_limit_roll: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnPlanarCurvePairRange<'a> = Id<PointOnPlanarCurvePairRange_<'a>>;
pub struct PointOnPlanarCurvePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_curve: PointOnCurve<'a>,
    pub input_orientation: SpatialRotation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnPlanarCurvePairValue<'a> = Id<PointOnPlanarCurvePairValue_<'a>>;
pub struct PointOnSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub point_parameter_u: ParameterValue<'a>,
    pub point_parameter_v: ParameterValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurface<'a> = Id<PointOnSurface_<'a>>;
pub struct PointOnSurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pair_surface: Surface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurfacePair<'a> = Id<PointOnSurfacePair_<'a>>;
pub struct PointOnSurfacePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_pair_surface: RectangularTrimmedSurface<'a>,
    pub lower_limit_yaw: RotationalRangeMeasure<'a>,
    pub upper_limit_yaw: RotationalRangeMeasure<'a>,
    pub lower_limit_pitch: RotationalRangeMeasure<'a>,
    pub upper_limit_pitch: RotationalRangeMeasure<'a>,
    pub lower_limit_roll: RotationalRangeMeasure<'a>,
    pub upper_limit_roll: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurfacePairRange<'a> = Id<PointOnSurfacePairRange_<'a>>;
pub struct PointOnSurfacePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_surface: PointOnSurface<'a>,
    pub input_orientation: SpatialRotation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurfacePairValue<'a> = Id<PointOnSurfacePairValue_<'a>>;
pub struct PointPlacementShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointPlacementShapeRepresentation<'a> = Id<PointPlacementShapeRepresentation_<'a>>;
pub struct PointReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_pt: Point<'a>,
    pub transformation: CartesianTransformationOperator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointReplica<'a> = Id<PointReplica_<'a>>;
pub struct PointStyle_<'a> { // entity
    pub name: Label<'a>,
    pub marker: MarkerSelect<'a>,
    pub marker_size: SizeSelect<'a>,
    pub marker_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointStyle<'a> = Id<PointStyle_<'a>>;
pub struct PolyLoop_<'a> { // entity
    pub name: Label<'a>,
    pub polygon: Vec<CartesianPoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PolyLoop<'a> = Id<PolyLoop_<'a>>;
pub struct Polyline_<'a> { // entity
    pub name: Label<'a>,
    pub points: Vec<CartesianPoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Polyline<'a> = Id<Polyline_<'a>>;
pub struct PositionTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PositionTolerance<'a> = Id<PositionTolerance_<'a>>;

pub struct PositiveLengthMeasure<'a>(pub NonNegativeLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositiveLengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("POSITIVE_LENGTH_MEASURE("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> PositiveLengthMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(NonNegativeLengthMeasure::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}

pub struct PositivePlaneAngleMeasure<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositivePlaneAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("POSITIVE_PLANE_ANGLE_MEASURE("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> PositivePlaneAngleMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}

pub struct PositiveRatioMeasure<'a>(pub RatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositiveRatioMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("POSITIVE_RATIO_MEASURE("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> PositiveRatioMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(RatioMeasure::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct PowerExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PowerExpression<'a> = Id<PowerExpression_<'a>>;
pub struct PreDefinedColour_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedColour<'a> = Id<PreDefinedColour_<'a>>;
pub struct PreDefinedCurveFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedCurveFont<'a> = Id<PreDefinedCurveFont_<'a>>;
pub struct PreDefinedDimensionSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedDimensionSymbol<'a> = Id<PreDefinedDimensionSymbol_<'a>>;
pub struct PreDefinedGeometricalToleranceSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedGeometricalToleranceSymbol<'a> = Id<PreDefinedGeometricalToleranceSymbol_<'a>>;
pub struct PreDefinedItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedItem<'a> = Id<PreDefinedItem_<'a>>;
pub struct PreDefinedMarker_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedMarker<'a> = Id<PreDefinedMarker_<'a>>;
pub struct PreDefinedPointMarkerSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedPointMarkerSymbol<'a> = Id<PreDefinedPointMarkerSymbol_<'a>>;
pub struct PreDefinedPresentationStyle_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedPresentationStyle<'a> = Id<PreDefinedPresentationStyle_<'a>>;
pub struct PreDefinedSurfaceConditionSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedSurfaceConditionSymbol<'a> = Id<PreDefinedSurfaceConditionSymbol_<'a>>;
pub struct PreDefinedSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedSymbol<'a> = Id<PreDefinedSymbol_<'a>>;
pub struct PreDefinedTerminatorSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedTerminatorSymbol<'a> = Id<PreDefinedTerminatorSymbol_<'a>>;
pub struct PreDefinedTextFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedTextFont<'a> = Id<PreDefinedTextFont_<'a>>;
pub struct PrecisionQualifier_<'a> { // entity
    pub precision_value: i64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrecisionQualifier<'a> = Id<PrecisionQualifier_<'a>>;
pub enum PreferredSurfaceCurveRepresentation<'a> { // enum
    Curve3d,
    PcurveS1,
    PcurveS2,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for PreferredSurfaceCurveRepresentation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use PreferredSurfaceCurveRepresentation::*;
        alt((
            map(tag(".CURVE_3D."), |_| Curve3d),
            map(tag(".PCURVE_S1."), |_| PcurveS1),
            map(tag(".PCURVE_S2."), |_| PcurveS2),
        ))(s)
    }
}
pub struct PresentableText<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for PresentableText<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> PresentableText<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct PresentationArea_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationArea<'a> = Id<PresentationArea_<'a>>;
pub struct PresentationLayerAssignment_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub assigned_items: Vec<LayeredItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationLayerAssignment<'a> = Id<PresentationLayerAssignment_<'a>>;
pub struct PresentationRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationRepresentation<'a> = Id<PresentationRepresentation_<'a>>;
pub enum PresentationRepresentationSelect<'a> { // select
    PresentationRepresentation(PresentationRepresentation<'a>),
    PresentationSet(PresentationSet<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PresentationRepresentationSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PresentationRepresentation<'a>>::parse, |r| PresentationRepresentationSelect::PresentationRepresentation(r)),
            map(<PresentationSet<'a>>::parse, |r| PresentationRepresentationSelect::PresentationSet(r)),
        ))(s)
    }
}
pub struct PresentationSet_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationSet<'a> = Id<PresentationSet_<'a>>;
pub struct PresentationSize_<'a> { // entity
    pub unit: PresentationSizeAssignmentSelect<'a>,
    pub size: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationSize<'a> = Id<PresentationSize_<'a>>;
pub enum PresentationSizeAssignmentSelect<'a> { // select
    PresentationView(PresentationView<'a>),
    PresentationArea(PresentationArea<'a>),
    AreaInSet(AreaInSet<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PresentationSizeAssignmentSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PresentationView<'a>>::parse, |r| PresentationSizeAssignmentSelect::PresentationView(r)),
            map(<PresentationArea<'a>>::parse, |r| PresentationSizeAssignmentSelect::PresentationArea(r)),
            map(<AreaInSet<'a>>::parse, |r| PresentationSizeAssignmentSelect::AreaInSet(r)),
        ))(s)
    }
}
pub struct PresentationStyleAssignment_<'a> { // entity
    pub styles: Vec<PresentationStyleSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationStyleAssignment<'a> = Id<PresentationStyleAssignment_<'a>>;
pub struct PresentationStyleByContext_<'a> { // entity
    pub styles: Vec<PresentationStyleSelect<'a>>,
    pub style_context: StyleContextSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationStyleByContext<'a> = Id<PresentationStyleByContext_<'a>>;
pub enum PresentationStyleSelect<'a> { // select
    PreDefinedPresentationStyle(PreDefinedPresentationStyle<'a>),
    PointStyle(PointStyle<'a>),
    CurveStyle(CurveStyle<'a>),
    SurfaceStyleUsage(SurfaceStyleUsage<'a>),
    SymbolStyle(SymbolStyle<'a>),
    FillAreaStyle(FillAreaStyle<'a>),
    TextStyle(TextStyle<'a>),
    ApproximationTolerance(ApproximationTolerance<'a>),
    ExternallyDefinedStyle(ExternallyDefinedStyle<'a>),
    NullStyle(NullStyle<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PresentationStyleSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PreDefinedPresentationStyle<'a>>::parse, |r| PresentationStyleSelect::PreDefinedPresentationStyle(r)),
            map(<PointStyle<'a>>::parse, |r| PresentationStyleSelect::PointStyle(r)),
            map(<CurveStyle<'a>>::parse, |r| PresentationStyleSelect::CurveStyle(r)),
            map(<SurfaceStyleUsage<'a>>::parse, |r| PresentationStyleSelect::SurfaceStyleUsage(r)),
            map(<SymbolStyle<'a>>::parse, |r| PresentationStyleSelect::SymbolStyle(r)),
            map(<FillAreaStyle<'a>>::parse, |r| PresentationStyleSelect::FillAreaStyle(r)),
            map(<TextStyle<'a>>::parse, |r| PresentationStyleSelect::TextStyle(r)),
            map(<ApproximationTolerance<'a>>::parse, |r| PresentationStyleSelect::ApproximationTolerance(r)),
            map(<ExternallyDefinedStyle<'a>>::parse, |r| PresentationStyleSelect::ExternallyDefinedStyle(r)),
            map(<NullStyle<'a>>::parse, |r| PresentationStyleSelect::NullStyle(r)),
        ))(s)
    }
}
pub struct PresentationView_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationView<'a> = Id<PresentationView_<'a>>;
pub struct PresentedItem_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentedItem<'a> = Id<PresentedItem_<'a>>;
pub struct PresentedItemRepresentation_<'a> { // entity
    pub presentation: PresentationRepresentationSelect<'a>,
    pub item: PresentedItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentedItemRepresentation<'a> = Id<PresentedItemRepresentation_<'a>>;
pub enum PresentedItemSelect<'a> { // select
    Action(Action<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionRelationship(ActionRelationship<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PresentedItemSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| PresentedItemSelect::Action(r)),
            map(<ActionMethod<'a>>::parse, |r| PresentedItemSelect::ActionMethod(r)),
            map(<ActionRelationship<'a>>::parse, |r| PresentedItemSelect::ActionRelationship(r)),
            map(<ProductConcept<'a>>::parse, |r| PresentedItemSelect::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| PresentedItemSelect::ProductConceptFeature(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| PresentedItemSelect::ProductConceptFeatureCategory(r)),
            map(<ProductDefinition<'a>>::parse, |r| PresentedItemSelect::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| PresentedItemSelect::ProductDefinitionFormation(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| PresentedItemSelect::ProductDefinitionRelationship(r)),
        ))(s)
    }
}
pub struct PrismaticPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrismaticPair<'a> = Id<PrismaticPair_<'a>>;
pub struct PrismaticPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_translation: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation: TranslationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrismaticPairRange<'a> = Id<PrismaticPairRange_<'a>>;
pub struct PrismaticPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_translation: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrismaticPairValue<'a> = Id<PrismaticPairValue_<'a>>;
pub struct ProcessOperation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub consequence: Text<'a>,
    pub purpose: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessOperation<'a> = Id<ProcessOperation_<'a>>;
pub struct ProcessPlan_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessPlan<'a> = Id<ProcessPlan_<'a>>;
pub struct ProcessProductAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub defined_product: CharacterizedProductDefinition<'a>,
    pub process: ProductDefinitionProcess<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessProductAssociation<'a> = Id<ProcessProductAssociation_<'a>>;
pub struct ProcessPropertyAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub process: PropertyProcess<'a>,
    pub property_or_shape: PropertyOrShapeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessPropertyAssociation<'a> = Id<ProcessPropertyAssociation_<'a>>;
pub struct Product_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub frame_of_reference: Vec<ProductContext<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Product<'a> = Id<Product_<'a>>;
pub struct ProductCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductCategory<'a> = Id<ProductCategory_<'a>>;
pub struct ProductCategoryRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub category: ProductCategory<'a>,
    pub sub_category: ProductCategory<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductCategoryRelationship<'a> = Id<ProductCategoryRelationship_<'a>>;
#[allow(non_snake_case)]
pub struct ProductClass_<'a> { // entity
    pub id: Identifier<'a>,
    pub product_concept__name: Label<'a>,
    pub product_concept__description: Option<Text<'a>>,
    pub market_context: ProductConceptContext<'a>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductClass<'a> = Id<ProductClass_<'a>>;
pub struct ProductConcept_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub market_context: ProductConceptContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConcept<'a> = Id<ProductConcept_<'a>>;
pub struct ProductConceptContext_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    pub market_segment_type: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptContext<'a> = Id<ProductConceptContext_<'a>>;
pub struct ProductConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeature<'a> = Id<ProductConceptFeature_<'a>>;
pub struct ProductConceptFeatureAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub concept: ProductConcept<'a>,
    pub feature: ProductConceptFeature<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeatureAssociation<'a> = Id<ProductConceptFeatureAssociation_<'a>>;
pub struct ProductConceptFeatureCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeatureCategory<'a> = Id<ProductConceptFeatureCategory_<'a>>;
pub struct ProductConceptFeatureCategoryUsage_<'a> { // entity
    pub assigned_group: Group<'a>,
    pub items: Vec<CategoryUsageItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeatureCategoryUsage<'a> = Id<ProductConceptFeatureCategoryUsage_<'a>>;
pub struct ProductConceptRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_concept: ProductConcept<'a>,
    pub related_product_concept: ProductConcept<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptRelationship<'a> = Id<ProductConceptRelationship_<'a>>;
pub struct ProductContext_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    pub discipline_type: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductContext<'a> = Id<ProductContext_<'a>>;
pub struct ProductDefinition_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinition<'a> = Id<ProductDefinition_<'a>>;
pub struct ProductDefinitionContext_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    pub life_cycle_stage: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionContext<'a> = Id<ProductDefinitionContext_<'a>>;
pub struct ProductDefinitionContextAssociation_<'a> { // entity
    pub definition: ProductDefinition<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    pub role: ProductDefinitionContextRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionContextAssociation<'a> = Id<ProductDefinitionContextAssociation_<'a>>;
pub struct ProductDefinitionContextRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionContextRole<'a> = Id<ProductDefinitionContextRole_<'a>>;
pub struct ProductDefinitionEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub usage: ProductDefinitionRelationship<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionEffectivity<'a> = Id<ProductDefinitionEffectivity_<'a>>;
pub struct ProductDefinitionFormation_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub of_product: Product<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionFormation<'a> = Id<ProductDefinitionFormation_<'a>>;
pub struct ProductDefinitionFormationRelationship_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition_formation: ProductDefinitionFormation<'a>,
    pub related_product_definition_formation: ProductDefinitionFormation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionFormationRelationship<'a> = Id<ProductDefinitionFormationRelationship_<'a>>;
pub struct ProductDefinitionFormationWithSpecifiedSource_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub of_product: Product<'a>,
    pub make_or_buy: Source<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionFormationWithSpecifiedSource<'a> = Id<ProductDefinitionFormationWithSpecifiedSource_<'a>>;
pub struct ProductDefinitionOccurrenceRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub occurrence: ProductDefinition<'a>,
    pub occurrence_usage: AssemblyComponentUsage<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionOccurrenceRelationship<'a> = Id<ProductDefinitionOccurrenceRelationship_<'a>>;
pub struct ProductDefinitionProcess_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionProcess<'a> = Id<ProductDefinitionProcess_<'a>>;
pub struct ProductDefinitionRelationship_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionRelationship<'a> = Id<ProductDefinitionRelationship_<'a>>;
#[allow(non_snake_case)]
pub struct ProductDefinitionResource_<'a> { // entity
    pub name: Label<'a>,
    pub action_resource__description: Option<Text<'a>>,
    pub usage: Vec<SupportedItem<'a>>,
    pub kind: ActionResourceType<'a>,
    pub id: Identifier<'a>,
    pub product_definition__description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionResource<'a> = Id<ProductDefinitionResource_<'a>>;
pub struct ProductDefinitionShape_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionShape<'a> = Id<ProductDefinitionShape_<'a>>;
pub struct ProductDefinitionSubstitute_<'a> { // entity
    pub description: Option<Text<'a>>,
    pub context_relationship: ProductDefinitionRelationship<'a>,
    pub substitute_definition: ProductDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionSubstitute<'a> = Id<ProductDefinitionSubstitute_<'a>>;
pub struct ProductDefinitionUsage_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionUsage<'a> = Id<ProductDefinitionUsage_<'a>>;
pub struct ProductDefinitionWithAssociatedDocuments_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    pub documentation_ids: Vec<Document<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionWithAssociatedDocuments<'a> = Id<ProductDefinitionWithAssociatedDocuments_<'a>>;
#[allow(non_snake_case)]
pub struct ProductIdentification_<'a> { // entity
    pub id: Identifier<'a>,
    pub configuration_item__name: Label<'a>,
    pub configuration_item__description: Option<Text<'a>>,
    pub item_concept: ProductConcept<'a>,
    pub purpose: Option<Label<'a>>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductIdentification<'a> = Id<ProductIdentification_<'a>>;
pub enum ProductOrFormationOrDefinition<'a> { // select
    Product(Product<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinition(ProductDefinition<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ProductOrFormationOrDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Product<'a>>::parse, |r| ProductOrFormationOrDefinition::Product(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| ProductOrFormationOrDefinition::ProductDefinitionFormation(r)),
            map(<ProductDefinition<'a>>::parse, |r| ProductOrFormationOrDefinition::ProductDefinition(r)),
        ))(s)
    }
}
pub enum ProductOrPresentationSpace<'a> { // enum
    ProductShapeSpace,
    PresentationAreaSpace,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ProductOrPresentationSpace<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ProductOrPresentationSpace::*;
        alt((
            map(tag(".PRODUCT_SHAPE_SPACE."), |_| ProductShapeSpace),
            map(tag(".PRESENTATION_AREA_SPACE."), |_| PresentationAreaSpace),
        ))(s)
    }
}
pub struct ProductProcessPlan_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductProcessPlan<'a> = Id<ProductProcessPlan_<'a>>;
pub struct ProductRelatedProductCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub products: Vec<Product<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductRelatedProductCategory<'a> = Id<ProductRelatedProductCategory_<'a>>;
#[allow(non_snake_case)]
pub struct ProductSpecification_<'a> { // entity
    pub id: Identifier<'a>,
    pub configuration_item__name: Label<'a>,
    pub configuration_item__description: Option<Text<'a>>,
    pub item_concept: ProductConcept<'a>,
    pub purpose: Option<Label<'a>>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    pub item_concept_feature: Vec<ProductConceptFeatureAssociation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductSpecification<'a> = Id<ProductSpecification_<'a>>;
pub struct ProjectedZoneDefinition_<'a> { // entity
    pub zone: ToleranceZone<'a>,
    pub boundaries: Vec<ShapeAspect<'a>>,
    pub projection_end: ShapeAspect<'a>,
    pub projected_length: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProjectedZoneDefinition<'a> = Id<ProjectedZoneDefinition_<'a>>;
pub struct ProjectionCurve_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProjectionCurve<'a> = Id<ProjectionCurve_<'a>>;
pub struct ProjectionDirectedCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProjectionDirectedCallout<'a> = Id<ProjectionDirectedCallout_<'a>>;
pub struct PromissoryUsageOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PromissoryUsageOccurrence<'a> = Id<PromissoryUsageOccurrence_<'a>>;
pub struct PropertyDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyDefinition<'a> = Id<PropertyDefinition_<'a>>;
pub struct PropertyDefinitionRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_property_definition: PropertyDefinition<'a>,
    pub related_property_definition: PropertyDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyDefinitionRelationship<'a> = Id<PropertyDefinitionRelationship_<'a>>;
pub struct PropertyDefinitionRepresentation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyDefinitionRepresentation<'a> = Id<PropertyDefinitionRepresentation_<'a>>;
pub enum PropertyOrShapeSelect<'a> { // select
    PropertyDefinition(PropertyDefinition<'a>),
    ShapeDefinition(ShapeDefinition<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PropertyOrShapeSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PropertyDefinition<'a>>::parse, |r| PropertyOrShapeSelect::PropertyDefinition(r)),
            map(<ShapeDefinition<'a>>::parse, |r| PropertyOrShapeSelect::ShapeDefinition(r)),
        ))(s)
    }
}
pub struct PropertyProcess_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyProcess<'a> = Id<PropertyProcess_<'a>>;
pub struct QualifiedRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub qualifiers: Vec<ValueQualifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QualifiedRepresentationItem<'a> = Id<QualifiedRepresentationItem_<'a>>;
pub struct QualitativeUncertainty_<'a> { // entity
    pub measure_name: Label<'a>,
    pub description: Text<'a>,
    pub uncertainty_value: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QualitativeUncertainty<'a> = Id<QualitativeUncertainty_<'a>>;
pub struct QuantifiedAssemblyComponentUsage_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    pub quantity: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QuantifiedAssemblyComponentUsage<'a> = Id<QuantifiedAssemblyComponentUsage_<'a>>;
pub struct QuasiUniformCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Option<bool>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QuasiUniformCurve<'a> = Id<QuasiUniformCurve_<'a>>;
pub struct QuasiUniformSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Option<bool>,
    pub v_closed: Option<bool>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QuasiUniformSurface<'a> = Id<QuasiUniformSurface_<'a>>;
pub struct RackAndPinionPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pinion_radius: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RackAndPinionPair<'a> = Id<RackAndPinionPair_<'a>>;
pub struct RackAndPinionPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_rack_displacement: TranslationalRangeMeasure<'a>,
    pub upper_limit_rack_displacement: TranslationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RackAndPinionPairRange<'a> = Id<RackAndPinionPairRange_<'a>>;
pub struct RackAndPinionPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_displacement: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RackAndPinionPairValue<'a> = Id<RackAndPinionPairValue_<'a>>;
pub struct RadiusDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RadiusDimension<'a> = Id<RadiusDimension_<'a>>;
pub struct RatioMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for RatioMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> RatioMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct RatioMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RatioMeasureWithUnit<'a> = Id<RatioMeasureWithUnit_<'a>>;
pub struct RatioUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RatioUnit<'a> = Id<RatioUnit_<'a>>;
pub struct RationalBSplineCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Option<bool>,
    pub self_intersect: Option<bool>,
    pub weights_data: Vec<f64>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RationalBSplineCurve<'a> = Id<RationalBSplineCurve_<'a>>;
pub struct RationalBSplineSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Option<bool>,
    pub v_closed: Option<bool>,
    pub self_intersect: Option<bool>,
    pub weights_data: Vec<Vec<f64>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RationalBSplineSurface<'a> = Id<RationalBSplineSurface_<'a>>;
pub struct RealDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RealDefinedFunction<'a> = Id<RealDefinedFunction_<'a>>;
pub struct RealLiteral_<'a> { // entity
    pub the_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RealLiteral<'a> = Id<RealLiteral_<'a>>;
pub struct RealNumericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RealNumericVariable<'a> = Id<RealNumericVariable_<'a>>;
pub struct RectangularClosedProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularClosedProfile<'a> = Id<RectangularClosedProfile_<'a>>;
pub struct RectangularCompositeSurface_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<Vec<SurfacePatch<'a>>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularCompositeSurface<'a> = Id<RectangularCompositeSurface_<'a>>;
pub struct RectangularPattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularPattern<'a> = Id<RectangularPattern_<'a>>;
pub struct RectangularTrimmedSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub u1: ParameterValue<'a>,
    pub u2: ParameterValue<'a>,
    pub v1: ParameterValue<'a>,
    pub v2: ParameterValue<'a>,
    pub usense: bool,
    pub vsense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularTrimmedSurface<'a> = Id<RectangularTrimmedSurface_<'a>>;
pub struct ReferencedModifiedDatum_<'a> { // entity
    pub precedence: i64,
    pub referenced_datum: Datum<'a>,
    pub modifier: LimitCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ReferencedModifiedDatum<'a> = Id<ReferencedModifiedDatum_<'a>>;
pub struct RelativeEventOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub base_event: EventOccurrence<'a>,
    pub offset: TimeMeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RelativeEventOccurrence<'a> = Id<RelativeEventOccurrence_<'a>>;
pub enum RenderingPropertiesSelect<'a> { // select
    SurfaceStyleReflectanceAmbient(SurfaceStyleReflectanceAmbient<'a>),
    SurfaceStyleTransparent(SurfaceStyleTransparent<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for RenderingPropertiesSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<SurfaceStyleReflectanceAmbient<'a>>::parse, |r| RenderingPropertiesSelect::SurfaceStyleReflectanceAmbient(r)),
            map(<SurfaceStyleTransparent<'a>>::parse, |r| RenderingPropertiesSelect::SurfaceStyleTransparent(r)),
        ))(s)
    }
}
#[allow(non_snake_case)]
pub struct RepItemGroup_<'a> { // entity
    pub group__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub representation_item__name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepItemGroup<'a> = Id<RepItemGroup_<'a>>;
pub struct ReparametrisedCompositeCurveSegment_<'a> { // entity
    pub transition: TransitionCode<'a>,
    pub same_sense: bool,
    pub parent_curve: Curve<'a>,
    pub param_length: ParameterValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ReparametrisedCompositeCurveSegment<'a> = Id<ReparametrisedCompositeCurveSegment_<'a>>;
pub struct ReplicateFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ReplicateFeature<'a> = Id<ReplicateFeature_<'a>>;
pub struct Representation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Representation<'a> = Id<Representation_<'a>>;
pub struct RepresentationContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationContext<'a> = Id<RepresentationContext_<'a>>;
pub struct RepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationItem<'a> = Id<RepresentationItem_<'a>>;
pub struct RepresentationMap_<'a> { // entity
    pub mapping_origin: RepresentationItem<'a>,
    pub mapped_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationMap<'a> = Id<RepresentationMap_<'a>>;
pub struct RepresentationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationRelationship<'a> = Id<RepresentationRelationship_<'a>>;
pub struct RepresentationRelationshipWithTransformation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub transformation_operator: Transformation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationRelationshipWithTransformation<'a> = Id<RepresentationRelationshipWithTransformation_<'a>>;
pub enum RepresentedDefinition<'a> { // select
    GeneralProperty(GeneralProperty<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    PropertyDefinitionRelationship(PropertyDefinitionRelationship<'a>),
    ShapeAspect(ShapeAspect<'a>),
    ShapeAspectRelationship(ShapeAspectRelationship<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for RepresentedDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<GeneralProperty<'a>>::parse, |r| RepresentedDefinition::GeneralProperty(r)),
            map(<PropertyDefinition<'a>>::parse, |r| RepresentedDefinition::PropertyDefinition(r)),
            map(<PropertyDefinitionRelationship<'a>>::parse, |r| RepresentedDefinition::PropertyDefinitionRelationship(r)),
            map(<ShapeAspect<'a>>::parse, |r| RepresentedDefinition::ShapeAspect(r)),
            map(<ShapeAspectRelationship<'a>>::parse, |r| RepresentedDefinition::ShapeAspectRelationship(r)),
        ))(s)
    }
}
pub struct RequirementForActionResource_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub kind: ResourceRequirementType<'a>,
    pub operations: Vec<CharacterizedActionDefinition<'a>>,
    pub resources: Vec<ActionResource<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RequirementForActionResource<'a> = Id<RequirementForActionResource_<'a>>;
pub struct ResourceProperty_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub resource: CharacterizedResourceDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResourceProperty<'a> = Id<ResourceProperty_<'a>>;
pub struct ResourcePropertyRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub property: ResourceProperty<'a>,
    pub representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResourcePropertyRepresentation<'a> = Id<ResourcePropertyRepresentation_<'a>>;
pub struct ResourceRequirementType_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResourceRequirementType<'a> = Id<ResourceRequirementType_<'a>>;
pub struct ResultingPath_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub related_frame: RigidPlacement<'a>,
    pub controlling_joints: Vec<KinematicJoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResultingPath<'a> = Id<ResultingPath_<'a>>;
pub struct Retention_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Retention<'a> = Id<Retention_<'a>>;
pub enum ReversibleTopology<'a> { // select
    ReversibleTopologyItem(ReversibleTopologyItem<'a>),
    ListOfReversibleTopologyItem(Vec<ReversibleTopologyItem<'a>>),
    SetOfReversibleTopologyItem(Vec<ReversibleTopologyItem<'a>>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ReversibleTopology<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ReversibleTopologyItem<'a>>::parse, |r| ReversibleTopology::ReversibleTopologyItem(r)),
            map(<Vec<ReversibleTopologyItem<'a>>>::parse, |r| ReversibleTopology::ListOfReversibleTopologyItem(r)),
            map(<Vec<ReversibleTopologyItem<'a>>>::parse, |r| ReversibleTopology::SetOfReversibleTopologyItem(r)),
        ))(s)
    }
}
pub enum ReversibleTopologyItem<'a> { // select
    Edge(Edge<'a>),
    Path(Path<'a>),
    Face(Face<'a>),
    FaceBound(FaceBound<'a>),
    ClosedShell(ClosedShell<'a>),
    OpenShell(OpenShell<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ReversibleTopologyItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Edge<'a>>::parse, |r| ReversibleTopologyItem::Edge(r)),
            map(<Path<'a>>::parse, |r| ReversibleTopologyItem::Path(r)),
            map(<Face<'a>>::parse, |r| ReversibleTopologyItem::Face(r)),
            map(<FaceBound<'a>>::parse, |r| ReversibleTopologyItem::FaceBound(r)),
            map(<ClosedShell<'a>>::parse, |r| ReversibleTopologyItem::ClosedShell(r)),
            map(<OpenShell<'a>>::parse, |r| ReversibleTopologyItem::OpenShell(r)),
        ))(s)
    }
}
pub struct RevolutePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolutePair<'a> = Id<RevolutePair_<'a>>;
pub struct RevolutePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolutePairRange<'a> = Id<RevolutePairRange_<'a>>;
pub struct RevolutePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolutePairValue<'a> = Id<RevolutePairValue_<'a>>;
pub struct RevolvedAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub axis: Axis1Placement<'a>,
    pub angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolvedAreaSolid<'a> = Id<RevolvedAreaSolid_<'a>>;
pub struct RevolvedFaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_face: FaceSurface<'a>,
    pub axis: Axis1Placement<'a>,
    pub angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolvedFaceSolid<'a> = Id<RevolvedFaceSolid_<'a>>;
pub struct Rib_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Rib<'a> = Id<Rib_<'a>>;
pub struct RightAngularWedge_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub x: PositiveLengthMeasure<'a>,
    pub y: PositiveLengthMeasure<'a>,
    pub z: PositiveLengthMeasure<'a>,
    pub ltx: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RightAngularWedge<'a> = Id<RightAngularWedge_<'a>>;
pub struct RightCircularCone_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis1Placement<'a>,
    pub height: PositiveLengthMeasure<'a>,
    pub radius: LengthMeasure<'a>,
    pub semi_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RightCircularCone<'a> = Id<RightCircularCone_<'a>>;
pub struct RightCircularCylinder_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis1Placement<'a>,
    pub height: PositiveLengthMeasure<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RightCircularCylinder<'a> = Id<RightCircularCylinder_<'a>>;
pub enum RigidPlacement<'a> { // select
    Axis2Placement3d(Axis2Placement3d<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for RigidPlacement<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<Axis2Placement3d<'a>>::parse, |r| RigidPlacement::Axis2Placement3d(r))(s)
    }
}
pub struct RoleAssociation_<'a> { // entity
    pub role: ObjectRole<'a>,
    pub item_with_role: RoleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoleAssociation<'a> = Id<RoleAssociation_<'a>>;
pub enum RoleSelect<'a> { // select
    ActionAssignment(ActionAssignment<'a>),
    ActionRequestAssignment(ActionRequestAssignment<'a>),
    ApprovalAssignment(ApprovalAssignment<'a>),
    ApprovalDateTime(ApprovalDateTime<'a>),
    CertificationAssignment(CertificationAssignment<'a>),
    ContractAssignment(ContractAssignment<'a>),
    DocumentReference(DocumentReference<'a>),
    EffectivityAssignment(EffectivityAssignment<'a>),
    GroupAssignment(GroupAssignment<'a>),
    NameAssignment(NameAssignment<'a>),
    SecurityClassificationAssignment(SecurityClassificationAssignment<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for RoleSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ActionAssignment<'a>>::parse, |r| RoleSelect::ActionAssignment(r)),
            map(<ActionRequestAssignment<'a>>::parse, |r| RoleSelect::ActionRequestAssignment(r)),
            map(<ApprovalAssignment<'a>>::parse, |r| RoleSelect::ApprovalAssignment(r)),
            map(<ApprovalDateTime<'a>>::parse, |r| RoleSelect::ApprovalDateTime(r)),
            map(<CertificationAssignment<'a>>::parse, |r| RoleSelect::CertificationAssignment(r)),
            map(<ContractAssignment<'a>>::parse, |r| RoleSelect::ContractAssignment(r)),
            map(<DocumentReference<'a>>::parse, |r| RoleSelect::DocumentReference(r)),
            map(<EffectivityAssignment<'a>>::parse, |r| RoleSelect::EffectivityAssignment(r)),
            map(<GroupAssignment<'a>>::parse, |r| RoleSelect::GroupAssignment(r)),
            map(<NameAssignment<'a>>::parse, |r| RoleSelect::NameAssignment(r)),
            map(<SecurityClassificationAssignment<'a>>::parse, |r| RoleSelect::SecurityClassificationAssignment(r)),
        ))(s)
    }
}
pub struct RollingCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub curve_1: Curve<'a>,
    pub curve_2: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingCurvePair<'a> = Id<RollingCurvePair_<'a>>;
pub struct RollingCurvePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_curve_1: PointOnCurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingCurvePairValue<'a> = Id<RollingCurvePairValue_<'a>>;
pub struct RollingSurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub surface_1: Surface<'a>,
    pub surface_2: Surface<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingSurfacePair<'a> = Id<RollingSurfacePair_<'a>>;
pub struct RollingSurfacePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_surface: PointOnSurface<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingSurfacePairValue<'a> = Id<RollingSurfacePairValue_<'a>>;
pub struct RotationAboutDirection_<'a> { // entity
    pub direction_of_axis: Direction<'a>,
    pub rotation_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RotationAboutDirection<'a> = Id<RotationAboutDirection_<'a>>;
pub enum RotationalRangeMeasure<'a> { // select
    PlaneAngleMeasure(PlaneAngleMeasure<'a>),
    UnlimitedRange(UnlimitedRange<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for RotationalRangeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PlaneAngleMeasure<'a>>::parse, |r| RotationalRangeMeasure::PlaneAngleMeasure(r)),
            map(<UnlimitedRange<'a>>::parse, |r| RotationalRangeMeasure::UnlimitedRange(r)),
        ))(s)
    }
}
pub struct RoundHole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoundHole<'a> = Id<RoundHole_<'a>>;
pub struct RoundedUProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoundedUProfile<'a> = Id<RoundedUProfile_<'a>>;
pub struct RoundnessTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoundnessTolerance<'a> = Id<RoundnessTolerance_<'a>>;
pub struct RuledSurfaceSweptAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub directrix: Curve<'a>,
    pub start_param: f64,
    pub end_param: f64,
    pub reference_surface: Surface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RuledSurfaceSweptAreaSolid<'a> = Id<RuledSurfaceSweptAreaSolid_<'a>>;
pub struct RunoutZoneDefinition_<'a> { // entity
    pub zone: ToleranceZone<'a>,
    pub boundaries: Vec<ShapeAspect<'a>>,
    pub orientation: RunoutZoneOrientation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RunoutZoneDefinition<'a> = Id<RunoutZoneDefinition_<'a>>;
pub struct RunoutZoneOrientation_<'a> { // entity
    pub angle: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RunoutZoneOrientation<'a> = Id<RunoutZoneOrientation_<'a>>;
pub struct RunoutZoneOrientationReferenceDirection_<'a> { // entity
    pub angle: MeasureWithUnit<'a>,
    pub orientation_defining_relationship: ShapeAspectRelationship<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RunoutZoneOrientationReferenceDirection<'a> = Id<RunoutZoneOrientationReferenceDirection_<'a>>;
pub struct ScrewPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pitch: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ScrewPair<'a> = Id<ScrewPair_<'a>>;
pub struct ScrewPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ScrewPairRange<'a> = Id<ScrewPairRange_<'a>>;
pub struct ScrewPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ScrewPairValue<'a> = Id<ScrewPairValue_<'a>>;
pub struct SeamCurve_<'a> { // entity
    pub name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: Vec<PcurveOrSurface<'a>>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SeamCurve<'a> = Id<SeamCurve_<'a>>;
pub struct SeamEdge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_element: Edge<'a>,
    pub orientation: bool,
    pub pcurve_reference: Pcurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SeamEdge<'a> = Id<SeamEdge_<'a>>;
pub struct SecondInMinute<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SecondInMinute<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> SecondInMinute<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct SecurityClassification_<'a> { // entity
    pub name: Label<'a>,
    pub purpose: Text<'a>,
    pub security_level: SecurityClassificationLevel<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SecurityClassification<'a> = Id<SecurityClassification_<'a>>;
pub struct SecurityClassificationAssignment_<'a> { // entity
    pub assigned_security_classification: SecurityClassification<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SecurityClassificationAssignment<'a> = Id<SecurityClassificationAssignment_<'a>>;
pub enum SecurityClassificationItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionProperty(ActionProperty<'a>),
    AppliedActionAssignment(AppliedActionAssignment<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationEffectivity(ConfigurationEffectivity<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment<'a>),
    DocumentFile(DocumentFile<'a>),
    DraughtingModel(DraughtingModel<'a>),
    DrawingRevision(DrawingRevision<'a>),
    ExecutedAction(ExecutedAction<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    ResourceProperty(ResourceProperty<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SecurityClassificationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| SecurityClassificationItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| SecurityClassificationItem::ActionDirective(r)),
            map(<ActionProperty<'a>>::parse, |r| SecurityClassificationItem::ActionProperty(r)),
            map(<AppliedActionAssignment<'a>>::parse, |r| SecurityClassificationItem::AppliedActionAssignment(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| SecurityClassificationItem::AssemblyComponentUsageSubstitute(r)),
            map(<ClassSystem<'a>>::parse, |r| SecurityClassificationItem::ClassSystem(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| SecurityClassificationItem::ConfigurationDesign(r)),
            map(<ConfigurationEffectivity<'a>>::parse, |r| SecurityClassificationItem::ConfigurationEffectivity(r)),
            map(<ConfiguredEffectivityAssignment<'a>>::parse, |r| SecurityClassificationItem::ConfiguredEffectivityAssignment(r)),
            map(<DocumentFile<'a>>::parse, |r| SecurityClassificationItem::DocumentFile(r)),
            map(<DraughtingModel<'a>>::parse, |r| SecurityClassificationItem::DraughtingModel(r)),
            map(<DrawingRevision<'a>>::parse, |r| SecurityClassificationItem::DrawingRevision(r)),
            map(<ExecutedAction<'a>>::parse, |r| SecurityClassificationItem::ExecutedAction(r)),
            map(<GeneralProperty<'a>>::parse, |r| SecurityClassificationItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| SecurityClassificationItem::MaterialDesignation(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| SecurityClassificationItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<OrganizationalProject<'a>>::parse, |r| SecurityClassificationItem::OrganizationalProject(r)),
            map(<PresentationArea<'a>>::parse, |r| SecurityClassificationItem::PresentationArea(r)),
            map(<Product<'a>>::parse, |r| SecurityClassificationItem::Product(r)),
        alt((
            map(<ProductConcept<'a>>::parse, |r| SecurityClassificationItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| SecurityClassificationItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| SecurityClassificationItem::ProductConceptFeatureCategory(r)),
            map(<ProductDefinition<'a>>::parse, |r| SecurityClassificationItem::ProductDefinition(r)),
            map(<ProductDefinitionFormation<'a>>::parse, |r| SecurityClassificationItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| SecurityClassificationItem::ProductDefinitionRelationship(r)),
            map(<PropertyDefinition<'a>>::parse, |r| SecurityClassificationItem::PropertyDefinition(r)),
            map(<ResourceProperty<'a>>::parse, |r| SecurityClassificationItem::ResourceProperty(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| SecurityClassificationItem::ShapeRepresentation(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| SecurityClassificationItem::VersionedActionRequest(r)),
        ))))(s)
    }
}
pub struct SecurityClassificationLevel_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SecurityClassificationLevel<'a> = Id<SecurityClassificationLevel_<'a>>;
pub struct SerialNumberedEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_start_id: Identifier<'a>,
    pub effectivity_end_id: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SerialNumberedEffectivity<'a> = Id<SerialNumberedEffectivity_<'a>>;
pub struct SetOfReversibleTopologyItem<'a>(pub Vec<ReversibleTopologyItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for SetOfReversibleTopologyItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<ReversibleTopologyItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct SetRepresentationItem<'a>(pub Vec<RepresentationItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for SetRepresentationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<RepresentationItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub enum ShadingCurveMethod<'a> { // enum
    ConstantColour,
    LinearColour,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ShadingCurveMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ShadingCurveMethod::*;
        alt((
            map(tag(".CONSTANT_COLOUR."), |_| ConstantColour),
            map(tag(".LINEAR_COLOUR."), |_| LinearColour),
        ))(s)
    }
}
pub enum ShadingSurfaceMethod<'a> { // enum
    ConstantShading,
    ColourShading,
    DotShading,
    NormalShading,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ShadingSurfaceMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ShadingSurfaceMethod::*;
        alt((
            map(tag(".CONSTANT_SHADING."), |_| ConstantShading),
            map(tag(".COLOUR_SHADING."), |_| ColourShading),
            map(tag(".DOT_SHADING."), |_| DotShading),
            map(tag(".NORMAL_SHADING."), |_| NormalShading),
        ))(s)
    }
}
pub struct ShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspect<'a> = Id<ShapeAspect_<'a>>;
pub struct ShapeAspectAssociativity_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectAssociativity<'a> = Id<ShapeAspectAssociativity_<'a>>;
pub struct ShapeAspectDerivingRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectDerivingRelationship<'a> = Id<ShapeAspectDerivingRelationship_<'a>>;
pub struct ShapeAspectRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectRelationship<'a> = Id<ShapeAspectRelationship_<'a>>;
pub struct ShapeAspectTransition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectTransition<'a> = Id<ShapeAspectTransition_<'a>>;
pub struct ShapeDefiningRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeDefiningRelationship<'a> = Id<ShapeDefiningRelationship_<'a>>;
pub enum ShapeDefinition<'a> { // select
    ProductDefinitionShape(ProductDefinitionShape<'a>),
    ShapeAspect(ShapeAspect<'a>),
    ShapeAspectRelationship(ShapeAspectRelationship<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ShapeDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ProductDefinitionShape<'a>>::parse, |r| ShapeDefinition::ProductDefinitionShape(r)),
            map(<ShapeAspect<'a>>::parse, |r| ShapeDefinition::ShapeAspect(r)),
            map(<ShapeAspectRelationship<'a>>::parse, |r| ShapeDefinition::ShapeAspectRelationship(r)),
        ))(s)
    }
}
pub struct ShapeDefinitionRepresentation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeDefinitionRepresentation<'a> = Id<ShapeDefinitionRepresentation_<'a>>;
pub struct ShapeDimensionRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeDimensionRepresentation<'a> = Id<ShapeDimensionRepresentation_<'a>>;
pub struct ShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeRepresentation<'a> = Id<ShapeRepresentation_<'a>>;
pub struct ShapeRepresentationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeRepresentationRelationship<'a> = Id<ShapeRepresentationRelationship_<'a>>;
pub struct ShapeRepresentationWithParameters_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeRepresentationWithParameters<'a> = Id<ShapeRepresentationWithParameters_<'a>>;
pub enum Shell<'a> { // select
    OpenShell(OpenShell<'a>),
    ClosedShell(ClosedShell<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for Shell<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<OpenShell<'a>>::parse, |r| Shell::OpenShell(r)),
            map(<ClosedShell<'a>>::parse, |r| Shell::ClosedShell(r)),
        ))(s)
    }
}
pub struct ShellBasedSurfaceModel_<'a> { // entity
    pub name: Label<'a>,
    pub sbsm_boundary: Vec<Shell<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShellBasedSurfaceModel<'a> = Id<ShellBasedSurfaceModel_<'a>>;
pub enum SiPrefix<'a> { // enum
    Exa,
    Peta,
    Tera,
    Giga,
    Mega,
    Kilo,
    Hecto,
    Deca,
    Deci,
    Centi,
    Milli,
    Micro,
    Nano,
    Pico,
    Femto,
    Atto,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SiPrefix<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SiPrefix::*;
        alt((
            map(tag(".EXA."), |_| Exa),
            map(tag(".PETA."), |_| Peta),
            map(tag(".TERA."), |_| Tera),
            map(tag(".GIGA."), |_| Giga),
            map(tag(".MEGA."), |_| Mega),
            map(tag(".KILO."), |_| Kilo),
            map(tag(".HECTO."), |_| Hecto),
            map(tag(".DECA."), |_| Deca),
            map(tag(".DECI."), |_| Deci),
            map(tag(".CENTI."), |_| Centi),
            map(tag(".MILLI."), |_| Milli),
            map(tag(".MICRO."), |_| Micro),
            map(tag(".NANO."), |_| Nano),
            map(tag(".PICO."), |_| Pico),
            map(tag(".FEMTO."), |_| Femto),
            map(tag(".ATTO."), |_| Atto),
        ))(s)
    }
}
pub struct SiUnit_<'a> { // entity
    pub prefix: Option<SiPrefix<'a>>,
    pub name: SiUnitName<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SiUnit<'a> = Id<SiUnit_<'a>>;
pub enum SiUnitName<'a> { // enum
    Metre,
    Gram,
    Second,
    Ampere,
    Kelvin,
    Mole,
    Candela,
    Radian,
    Steradian,
    Hertz,
    Newton,
    Pascal,
    Joule,
    Watt,
    Coulomb,
    Volt,
    Farad,
    Ohm,
    Siemens,
    Weber,
    Tesla,
    Henry,
    DegreeCelsius,
    Lumen,
    Lux,
    Becquerel,
    Gray,
    Sievert,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SiUnitName<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SiUnitName::*;
        alt((
            map(tag(".METRE."), |_| Metre),
            map(tag(".GRAM."), |_| Gram),
            map(tag(".SECOND."), |_| Second),
            map(tag(".AMPERE."), |_| Ampere),
            map(tag(".KELVIN."), |_| Kelvin),
            map(tag(".MOLE."), |_| Mole),
            map(tag(".CANDELA."), |_| Candela),
            map(tag(".RADIAN."), |_| Radian),
            map(tag(".STERADIAN."), |_| Steradian),
            map(tag(".HERTZ."), |_| Hertz),
            map(tag(".NEWTON."), |_| Newton),
            map(tag(".PASCAL."), |_| Pascal),
            map(tag(".JOULE."), |_| Joule),
            map(tag(".WATT."), |_| Watt),
            map(tag(".COULOMB."), |_| Coulomb),
            map(tag(".VOLT."), |_| Volt),
            map(tag(".FARAD."), |_| Farad),
            map(tag(".OHM."), |_| Ohm),
            map(tag(".SIEMENS."), |_| Siemens),
        alt((
            map(tag(".WEBER."), |_| Weber),
            map(tag(".TESLA."), |_| Tesla),
            map(tag(".HENRY."), |_| Henry),
            map(tag(".DEGREE_CELSIUS."), |_| DegreeCelsius),
            map(tag(".LUMEN."), |_| Lumen),
            map(tag(".LUX."), |_| Lux),
            map(tag(".BECQUEREL."), |_| Becquerel),
            map(tag(".GRAY."), |_| Gray),
            map(tag(".SIEVERT."), |_| Sievert),
        ))))(s)
    }
}
pub struct SimpleBooleanExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleBooleanExpression<'a> = Id<SimpleBooleanExpression_<'a>>;
pub struct SimpleGenericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleGenericExpression<'a> = Id<SimpleGenericExpression_<'a>>;
pub struct SimpleNumericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleNumericExpression<'a> = Id<SimpleNumericExpression_<'a>>;
pub struct SimplePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimplePairRange<'a> = Id<SimplePairRange_<'a>>;
pub struct SimpleStringExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleStringExpression<'a> = Id<SimpleStringExpression_<'a>>;
pub struct SinFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SinFunction<'a> = Id<SinFunction_<'a>>;
pub enum SizeSelect<'a> { // select
    PositiveLengthMeasure(PositiveLengthMeasure<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SizeSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PositiveLengthMeasure<'a>>::parse, |r| SizeSelect::PositiveLengthMeasure(r)),
            map(<MeasureWithUnit<'a>>::parse, |r| SizeSelect::MeasureWithUnit(r)),
            map(<DescriptiveMeasure<'a>>::parse, |r| SizeSelect::DescriptiveMeasure(r)),
        ))(s)
    }
}
pub struct SlashExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlashExpression<'a> = Id<SlashExpression_<'a>>;
pub struct SlidingCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub curve_1: Curve<'a>,
    pub curve_2: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingCurvePair<'a> = Id<SlidingCurvePair_<'a>>;
pub struct SlidingCurvePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_curve_1: PointOnCurve<'a>,
    pub actual_point_on_curve_2: PointOnCurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingCurvePairValue<'a> = Id<SlidingCurvePairValue_<'a>>;
pub struct SlidingSurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub surface_1: Surface<'a>,
    pub surface_2: Surface<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingSurfacePair<'a> = Id<SlidingSurfacePair_<'a>>;
pub struct SlidingSurfacePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_surface_1: PointOnSurface<'a>,
    pub actual_point_on_surface_2: PointOnSurface<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingSurfacePairValue<'a> = Id<SlidingSurfacePairValue_<'a>>;
pub struct Slot_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Slot<'a> = Id<Slot_<'a>>;
pub struct SlotEnd_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlotEnd<'a> = Id<SlotEnd_<'a>>;
pub struct SolidAngleMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SolidAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> SolidAngleMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct SolidAngleMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidAngleMeasureWithUnit<'a> = Id<SolidAngleMeasureWithUnit_<'a>>;
pub struct SolidAngleUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidAngleUnit<'a> = Id<SolidAngleUnit_<'a>>;
pub struct SolidModel_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidModel<'a> = Id<SolidModel_<'a>>;
pub struct SolidReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_solid: SolidModel<'a>,
    pub transformation: CartesianTransformationOperator3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidReplica<'a> = Id<SolidReplica_<'a>>;
pub enum Source<'a> { // enum
    Made,
    Bought,
    NotKnown,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for Source<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use Source::*;
        alt((
            map(tag(".MADE."), |_| Made),
            map(tag(".BOUGHT."), |_| Bought),
            map(tag(".NOT_KNOWN."), |_| NotKnown),
        ))(s)
    }
}
pub enum SourceItem<'a> { // select
    Identifier(Identifier<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SourceItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<Identifier<'a>>::parse, |r| SourceItem::Identifier(r))(s)
    }
}
pub enum SpatialRotation<'a> { // select
    YprRotation(Vec<PlaneAngleMeasure<'a>>),
    RotationAboutDirection(RotationAboutDirection<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SpatialRotation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Vec<PlaneAngleMeasure<'a>>>::parse, |r| SpatialRotation::YprRotation(r)),
            map(<RotationAboutDirection<'a>>::parse, |r| SpatialRotation::RotationAboutDirection(r)),
        ))(s)
    }
}
pub struct SpecifiedHigherUsageOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    pub upper_usage: AssemblyComponentUsage<'a>,
    pub next_usage: NextAssemblyUsageOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SpecifiedHigherUsageOccurrence<'a> = Id<SpecifiedHigherUsageOccurrence_<'a>>;
pub enum SpecifiedItem<'a> { // select
    DrawingRevision(DrawingRevision<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SpecifiedItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<DrawingRevision<'a>>::parse, |r| SpecifiedItem::DrawingRevision(r))(s)
    }
}
pub struct Sphere_<'a> { // entity
    pub name: Label<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    pub centre: Point<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Sphere<'a> = Id<Sphere_<'a>>;
pub struct SphericalPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalPair<'a> = Id<SphericalPair_<'a>>;
pub struct SphericalPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_yaw: RotationalRangeMeasure<'a>,
    pub upper_limit_yaw: RotationalRangeMeasure<'a>,
    pub lower_limit_pitch: RotationalRangeMeasure<'a>,
    pub upper_limit_pitch: RotationalRangeMeasure<'a>,
    pub lower_limit_roll: RotationalRangeMeasure<'a>,
    pub upper_limit_roll: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalPairRange<'a> = Id<SphericalPairRange_<'a>>;
pub struct SphericalPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub input_orientation: SpatialRotation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalPairValue<'a> = Id<SphericalPairValue_<'a>>;
pub struct SphericalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalSurface<'a> = Id<SphericalSurface_<'a>>;
pub struct SqlMappableDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SqlMappableDefinedFunction<'a> = Id<SqlMappableDefinedFunction_<'a>>;
pub struct SquareRootFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SquareRootFunction<'a> = Id<SquareRootFunction_<'a>>;
pub struct SquareUProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SquareUProfile<'a> = Id<SquareUProfile_<'a>>;
pub struct StandardUncertainty_<'a> { // entity
    pub measure_name: Label<'a>,
    pub description: Text<'a>,
    pub uncertainty_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StandardUncertainty<'a> = Id<StandardUncertainty_<'a>>;
pub struct StraightnessTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StraightnessTolerance<'a> = Id<StraightnessTolerance_<'a>>;
pub struct StringDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringDefinedFunction<'a> = Id<StringDefinedFunction_<'a>>;
pub struct StringExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringExpression<'a> = Id<StringExpression_<'a>>;
pub struct StringLiteral_<'a> { // entity
    pub the_value: &'a str,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringLiteral<'a> = Id<StringLiteral_<'a>>;
pub struct StringVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringVariable<'a> = Id<StringVariable_<'a>>;
pub struct StructuredDimensionCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StructuredDimensionCallout<'a> = Id<StructuredDimensionCallout_<'a>>;
pub enum StyleContextSelect<'a> { // select
    Group(Group<'a>),
    PresentationLayerAssignment(PresentationLayerAssignment<'a>),
    PresentationSet(PresentationSet<'a>),
    Representation(Representation<'a>),
    RepresentationItem(RepresentationItem<'a>),
    ShapeRepresentationRelationship(ShapeRepresentationRelationship<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for StyleContextSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Group<'a>>::parse, |r| StyleContextSelect::Group(r)),
            map(<PresentationLayerAssignment<'a>>::parse, |r| StyleContextSelect::PresentationLayerAssignment(r)),
            map(<PresentationSet<'a>>::parse, |r| StyleContextSelect::PresentationSet(r)),
            map(<Representation<'a>>::parse, |r| StyleContextSelect::Representation(r)),
            map(<RepresentationItem<'a>>::parse, |r| StyleContextSelect::RepresentationItem(r)),
            map(<ShapeRepresentationRelationship<'a>>::parse, |r| StyleContextSelect::ShapeRepresentationRelationship(r)),
        ))(s)
    }
}
pub struct StyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StyledItem<'a> = Id<StyledItem_<'a>>;
pub struct Subedge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_start: Vertex<'a>,
    pub edge_end: Vertex<'a>,
    pub parent_edge: Edge<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Subedge<'a> = Id<Subedge_<'a>>;
pub struct Subface_<'a> { // entity
    pub name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    pub parent_face: Face<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Subface<'a> = Id<Subface_<'a>>;
pub struct SubstringExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SubstringExpression<'a> = Id<SubstringExpression_<'a>>;
pub enum SupportedItem<'a> { // select
    ActionDirective(ActionDirective<'a>),
    Action(Action<'a>),
    ActionMethod(ActionMethod<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SupportedItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ActionDirective<'a>>::parse, |r| SupportedItem::ActionDirective(r)),
            map(<Action<'a>>::parse, |r| SupportedItem::Action(r)),
            map(<ActionMethod<'a>>::parse, |r| SupportedItem::ActionMethod(r)),
        ))(s)
    }
}
pub struct Surface_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Surface<'a> = Id<Surface_<'a>>;
pub struct SurfaceConditionCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceConditionCallout<'a> = Id<SurfaceConditionCallout_<'a>>;
pub struct SurfaceCurve_<'a> { // entity
    pub name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: Vec<PcurveOrSurface<'a>>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceCurve<'a> = Id<SurfaceCurve_<'a>>;
pub struct SurfaceCurveSweptAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub directrix: Curve<'a>,
    pub start_param: f64,
    pub end_param: f64,
    pub reference_surface: Surface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceCurveSweptAreaSolid<'a> = Id<SurfaceCurveSweptAreaSolid_<'a>>;
pub struct SurfaceOfLinearExtrusion_<'a> { // entity
    pub name: Label<'a>,
    pub swept_curve: Curve<'a>,
    pub extrusion_axis: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceOfLinearExtrusion<'a> = Id<SurfaceOfLinearExtrusion_<'a>>;
pub struct SurfaceOfRevolution_<'a> { // entity
    pub name: Label<'a>,
    pub swept_curve: Curve<'a>,
    pub axis_position: Axis1Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceOfRevolution<'a> = Id<SurfaceOfRevolution_<'a>>;
pub struct SurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub surface_1: Surface<'a>,
    pub surface_2: Surface<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfacePair<'a> = Id<SurfacePair_<'a>>;
pub struct SurfacePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_surface_1: RectangularTrimmedSurface<'a>,
    pub range_on_surface_2: RectangularTrimmedSurface<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfacePairRange<'a> = Id<SurfacePairRange_<'a>>;
pub struct SurfacePatch_<'a> { // entity
    pub parent_surface: BoundedSurface<'a>,
    pub u_transition: TransitionCode<'a>,
    pub v_transition: TransitionCode<'a>,
    pub u_sense: bool,
    pub v_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfacePatch<'a> = Id<SurfacePatch_<'a>>;
pub struct SurfaceProfileTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceProfileTolerance<'a> = Id<SurfaceProfileTolerance_<'a>>;
pub struct SurfaceRenderingProperties_<'a> { // entity
    pub rendered_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceRenderingProperties<'a> = Id<SurfaceRenderingProperties_<'a>>;
pub struct SurfaceReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_surface: Surface<'a>,
    pub transformation: CartesianTransformationOperator3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceReplica<'a> = Id<SurfaceReplica_<'a>>;
pub enum SurfaceSide<'a> { // enum
    Positive,
    Negative,
    Both,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SurfaceSide<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SurfaceSide::*;
        alt((
            map(tag(".POSITIVE."), |_| Positive),
            map(tag(".NEGATIVE."), |_| Negative),
            map(tag(".BOTH."), |_| Both),
        ))(s)
    }
}
pub struct SurfaceSideStyle_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<SurfaceStyleElementSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceSideStyle<'a> = Id<SurfaceSideStyle_<'a>>;
pub enum SurfaceSideStyleSelect<'a> { // select
    SurfaceSideStyle(SurfaceSideStyle<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SurfaceSideStyleSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<SurfaceSideStyle<'a>>::parse, |r| SurfaceSideStyleSelect::SurfaceSideStyle(r))(s)
    }
}
pub struct SurfaceStyleBoundary_<'a> { // entity
    pub style_of_boundary: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleBoundary<'a> = Id<SurfaceStyleBoundary_<'a>>;
pub struct SurfaceStyleControlGrid_<'a> { // entity
    pub style_of_control_grid: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleControlGrid<'a> = Id<SurfaceStyleControlGrid_<'a>>;
pub enum SurfaceStyleElementSelect<'a> { // select
    SurfaceStyleFillArea(SurfaceStyleFillArea<'a>),
    SurfaceStyleBoundary(SurfaceStyleBoundary<'a>),
    SurfaceStyleSilhouette(SurfaceStyleSilhouette<'a>),
    SurfaceStyleSegmentationCurve(SurfaceStyleSegmentationCurve<'a>),
    SurfaceStyleControlGrid(SurfaceStyleControlGrid<'a>),
    SurfaceStyleParameterLine(SurfaceStyleParameterLine<'a>),
    SurfaceStyleRendering(SurfaceStyleRendering<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SurfaceStyleElementSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<SurfaceStyleFillArea<'a>>::parse, |r| SurfaceStyleElementSelect::SurfaceStyleFillArea(r)),
            map(<SurfaceStyleBoundary<'a>>::parse, |r| SurfaceStyleElementSelect::SurfaceStyleBoundary(r)),
            map(<SurfaceStyleSilhouette<'a>>::parse, |r| SurfaceStyleElementSelect::SurfaceStyleSilhouette(r)),
            map(<SurfaceStyleSegmentationCurve<'a>>::parse, |r| SurfaceStyleElementSelect::SurfaceStyleSegmentationCurve(r)),
            map(<SurfaceStyleControlGrid<'a>>::parse, |r| SurfaceStyleElementSelect::SurfaceStyleControlGrid(r)),
            map(<SurfaceStyleParameterLine<'a>>::parse, |r| SurfaceStyleElementSelect::SurfaceStyleParameterLine(r)),
            map(<SurfaceStyleRendering<'a>>::parse, |r| SurfaceStyleElementSelect::SurfaceStyleRendering(r)),
        ))(s)
    }
}
pub struct SurfaceStyleFillArea_<'a> { // entity
    pub fill_area: FillAreaStyle<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleFillArea<'a> = Id<SurfaceStyleFillArea_<'a>>;
pub struct SurfaceStyleParameterLine_<'a> { // entity
    pub style_of_parameter_lines: CurveOrRender<'a>,
    pub direction_counts: Vec<DirectionCountSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleParameterLine<'a> = Id<SurfaceStyleParameterLine_<'a>>;
pub struct SurfaceStyleReflectanceAmbient_<'a> { // entity
    pub ambient_reflectance: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleReflectanceAmbient<'a> = Id<SurfaceStyleReflectanceAmbient_<'a>>;
pub struct SurfaceStyleReflectanceAmbientDiffuse_<'a> { // entity
    pub ambient_reflectance: f64,
    pub diffuse_reflectance: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleReflectanceAmbientDiffuse<'a> = Id<SurfaceStyleReflectanceAmbientDiffuse_<'a>>;
pub struct SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a> { // entity
    pub ambient_reflectance: f64,
    pub diffuse_reflectance: f64,
    pub specular_reflectance: f64,
    pub specular_exponent: f64,
    pub specular_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleReflectanceAmbientDiffuseSpecular<'a> = Id<SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a>>;
pub struct SurfaceStyleRendering_<'a> { // entity
    pub rendering_method: ShadingSurfaceMethod<'a>,
    pub surface_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleRendering<'a> = Id<SurfaceStyleRendering_<'a>>;
pub struct SurfaceStyleRenderingWithProperties_<'a> { // entity
    pub rendering_method: ShadingSurfaceMethod<'a>,
    pub surface_colour: Colour<'a>,
    pub properties: Vec<RenderingPropertiesSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleRenderingWithProperties<'a> = Id<SurfaceStyleRenderingWithProperties_<'a>>;
pub struct SurfaceStyleSegmentationCurve_<'a> { // entity
    pub style_of_segmentation_curve: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleSegmentationCurve<'a> = Id<SurfaceStyleSegmentationCurve_<'a>>;
pub struct SurfaceStyleSilhouette_<'a> { // entity
    pub style_of_silhouette: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleSilhouette<'a> = Id<SurfaceStyleSilhouette_<'a>>;
pub struct SurfaceStyleTransparent_<'a> { // entity
    pub transparency: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleTransparent<'a> = Id<SurfaceStyleTransparent_<'a>>;
pub struct SurfaceStyleUsage_<'a> { // entity
    pub side: SurfaceSide<'a>,
    pub style: SurfaceSideStyleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleUsage<'a> = Id<SurfaceStyleUsage_<'a>>;
pub struct SurfaceTextureRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceTextureRepresentation<'a> = Id<SurfaceTextureRepresentation_<'a>>;

pub struct SurfaceToleranceDeviation<'a>(pub PositiveLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for SurfaceToleranceDeviation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("SURFACE_TOLERANCE_DEVIATION("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> SurfaceToleranceDeviation<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(PositiveLengthMeasure::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct SurfaceToleranceParameter<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SurfaceToleranceParameter<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> SurfaceToleranceParameter<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct SweptAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptAreaSolid<'a> = Id<SweptAreaSolid_<'a>>;
pub struct SweptDiskSolid_<'a> { // entity
    pub name: Label<'a>,
    pub directrix: Curve<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    pub inner_radius: Option<PositiveLengthMeasure<'a>>,
    pub start_param: f64,
    pub end_param: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptDiskSolid<'a> = Id<SweptDiskSolid_<'a>>;
pub struct SweptFaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_face: FaceSurface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptFaceSolid<'a> = Id<SweptFaceSolid_<'a>>;
pub struct SweptSurface_<'a> { // entity
    pub name: Label<'a>,
    pub swept_curve: Curve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptSurface<'a> = Id<SweptSurface_<'a>>;
pub struct SymbolColour_<'a> { // entity
    pub colour_of_symbol: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolColour<'a> = Id<SymbolColour_<'a>>;
pub struct SymbolRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolRepresentation<'a> = Id<SymbolRepresentation_<'a>>;
pub struct SymbolRepresentationMap_<'a> { // entity
    pub mapping_origin: RepresentationItem<'a>,
    pub mapped_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolRepresentationMap<'a> = Id<SymbolRepresentationMap_<'a>>;
pub struct SymbolStyle_<'a> { // entity
    pub name: Label<'a>,
    pub style_of_symbol: SymbolStyleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolStyle<'a> = Id<SymbolStyle_<'a>>;
pub enum SymbolStyleSelect<'a> { // select
    SymbolColour(SymbolColour<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SymbolStyleSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<SymbolColour<'a>>::parse, |r| SymbolStyleSelect::SymbolColour(r))(s)
    }
}
pub struct SymbolTarget_<'a> { // entity
    pub name: Label<'a>,
    pub placement: Axis2Placement<'a>,
    pub x_scale: PositiveRatioMeasure<'a>,
    pub y_scale: PositiveRatioMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolTarget<'a> = Id<SymbolTarget_<'a>>;
pub struct SymmetricShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymmetricShapeAspect<'a> = Id<SymmetricShapeAspect_<'a>>;
pub struct SymmetryTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymmetryTolerance<'a> = Id<SymmetryTolerance_<'a>>;
pub struct TactileAppearanceRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TactileAppearanceRepresentation<'a> = Id<TactileAppearanceRepresentation_<'a>>;
pub struct TanFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TanFunction<'a> = Id<TanFunction_<'a>>;
pub struct Tangent_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Tangent<'a> = Id<Tangent_<'a>>;
pub struct Taper_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Taper<'a> = Id<Taper_<'a>>;
pub struct TeeProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TeeProfile<'a> = Id<TeeProfile_<'a>>;
pub struct TerminatorSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub annotated_curve: AnnotationCurveOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TerminatorSymbol<'a> = Id<TerminatorSymbol_<'a>>;
pub struct Text<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Text<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> Text<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}

pub struct TextAlignment<'a>(pub Label<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for TextAlignment<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("TEXT_ALIGNMENT("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> TextAlignment<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(Label::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}

pub struct TextDelineation<'a>(pub Label<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for TextDelineation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        delimited(tag("TEXT_DELINEATION("), Self::parse_inner, char(')'))(s)
    }
}
impl<'a> TextDelineation<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(Label::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct TextLiteral_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteral<'a> = Id<TextLiteral_<'a>>;
pub struct TextLiteralWithAssociatedCurves_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub associated_curves: Vec<Curve<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithAssociatedCurves<'a> = Id<TextLiteralWithAssociatedCurves_<'a>>;
pub struct TextLiteralWithBlankingBox_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub blanking: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithBlankingBox<'a> = Id<TextLiteralWithBlankingBox_<'a>>;
pub struct TextLiteralWithDelineation_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub delineation: TextDelineation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithDelineation<'a> = Id<TextLiteralWithDelineation_<'a>>;
pub struct TextLiteralWithExtent_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub extent: PlanarExtent<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithExtent<'a> = Id<TextLiteralWithExtent_<'a>>;
pub enum TextOrCharacter<'a> { // select
    AnnotationText(AnnotationText<'a>),
    AnnotationTextCharacter(AnnotationTextCharacter<'a>),
    DefinedCharacterGlyph(DefinedCharacterGlyph<'a>),
    CompositeText(CompositeText<'a>),
    TextLiteral(TextLiteral<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for TextOrCharacter<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<AnnotationText<'a>>::parse, |r| TextOrCharacter::AnnotationText(r)),
            map(<AnnotationTextCharacter<'a>>::parse, |r| TextOrCharacter::AnnotationTextCharacter(r)),
            map(<DefinedCharacterGlyph<'a>>::parse, |r| TextOrCharacter::DefinedCharacterGlyph(r)),
            map(<CompositeText<'a>>::parse, |r| TextOrCharacter::CompositeText(r)),
            map(<TextLiteral<'a>>::parse, |r| TextOrCharacter::TextLiteral(r)),
        ))(s)
    }
}
pub enum TextPath<'a> { // enum
    Left,
    Right,
    Up,
    Down,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TextPath<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TextPath::*;
        alt((
            map(tag(".LEFT."), |_| Left),
            map(tag(".RIGHT."), |_| Right),
            map(tag(".UP."), |_| Up),
            map(tag(".DOWN."), |_| Down),
        ))(s)
    }
}
pub struct TextStringRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStringRepresentation<'a> = Id<TextStringRepresentation_<'a>>;
pub enum TextStringRepresentationItem<'a> { // select
    TextLiteral(TextLiteral<'a>),
    AnnotationText(AnnotationText<'a>),
    AnnotationTextCharacter(AnnotationTextCharacter<'a>),
    DefinedCharacterGlyph(DefinedCharacterGlyph<'a>),
    CompositeText(CompositeText<'a>),
    Axis2Placement(Axis2Placement<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for TextStringRepresentationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<TextLiteral<'a>>::parse, |r| TextStringRepresentationItem::TextLiteral(r)),
            map(<AnnotationText<'a>>::parse, |r| TextStringRepresentationItem::AnnotationText(r)),
            map(<AnnotationTextCharacter<'a>>::parse, |r| TextStringRepresentationItem::AnnotationTextCharacter(r)),
            map(<DefinedCharacterGlyph<'a>>::parse, |r| TextStringRepresentationItem::DefinedCharacterGlyph(r)),
            map(<CompositeText<'a>>::parse, |r| TextStringRepresentationItem::CompositeText(r)),
            map(<Axis2Placement<'a>>::parse, |r| TextStringRepresentationItem::Axis2Placement(r)),
        ))(s)
    }
}
pub struct TextStyle_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyle<'a> = Id<TextStyle_<'a>>;
pub struct TextStyleForDefinedFont_<'a> { // entity
    pub text_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleForDefinedFont<'a> = Id<TextStyleForDefinedFont_<'a>>;
pub struct TextStyleWithBoxCharacteristics_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    pub characteristics: Vec<BoxCharacteristicSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleWithBoxCharacteristics<'a> = Id<TextStyleWithBoxCharacteristics_<'a>>;
pub struct TextStyleWithMirror_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    pub mirror_placement: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleWithMirror<'a> = Id<TextStyleWithMirror_<'a>>;
pub struct TextStyleWithSpacing_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    pub character_spacing: CharacterSpacingSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleWithSpacing<'a> = Id<TextStyleWithSpacing_<'a>>;
pub struct ThermodynamicTemperatureMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ThermodynamicTemperatureMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> ThermodynamicTemperatureMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct ThermodynamicTemperatureMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ThermodynamicTemperatureMeasureWithUnit<'a> = Id<ThermodynamicTemperatureMeasureWithUnit_<'a>>;
pub struct ThermodynamicTemperatureUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ThermodynamicTemperatureUnit<'a> = Id<ThermodynamicTemperatureUnit_<'a>>;
pub struct Thread_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Thread<'a> = Id<Thread_<'a>>;
pub struct TimeInterval_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeInterval<'a> = Id<TimeInterval_<'a>>;
pub struct TimeIntervalAssignment_<'a> { // entity
    pub assigned_time_interval: TimeInterval<'a>,
    pub role: TimeIntervalRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalAssignment<'a> = Id<TimeIntervalAssignment_<'a>>;
pub struct TimeIntervalBasedEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_period: TimeInterval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalBasedEffectivity<'a> = Id<TimeIntervalBasedEffectivity_<'a>>;
pub enum TimeIntervalItem<'a> { // select
    Action(Action<'a>),
    ActionDirective(ActionDirective<'a>),
    ActionMethod(ActionMethod<'a>),
    ActionProperty(ActionProperty<'a>),
    ActionRelationship(ActionRelationship<'a>),
    ActionRequestSolution(ActionRequestSolution<'a>),
    AlternateProductRelationship(AlternateProductRelationship<'a>),
    AppliedActionAssignment(AppliedActionAssignment<'a>),
    AppliedClassificationAssignment(AppliedClassificationAssignment<'a>),
    AppliedPersonAndOrganizationAssignment(AppliedPersonAndOrganizationAssignment<'a>),
    ApprovalStatus(ApprovalStatus<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute<'a>),
    Certification(Certification<'a>),
    Class(Class<'a>),
    ClassSystem(ClassSystem<'a>),
    ConfigurationDesign(ConfigurationDesign<'a>),
    ConfigurationEffectivity(ConfigurationEffectivity<'a>),
    ConfigurationItem(ConfigurationItem<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment<'a>),
    Contract(Contract<'a>),
    DocumentFile(DocumentFile<'a>),
    DraughtingModel(DraughtingModel<'a>),
    DrawingRevision(DrawingRevision<'a>),
    ExecutedAction(ExecutedAction<'a>),
    GeneralProperty(GeneralProperty<'a>),
    MaterialDesignation(MaterialDesignation<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation<'a>),
    OrganizationRelationship(OrganizationRelationship<'a>),
    OrganizationalProject(OrganizationalProject<'a>),
    PersonAndOrganization(PersonAndOrganization<'a>),
    PresentationArea(PresentationArea<'a>),
    Product(Product<'a>),
    ProductConcept(ProductConcept<'a>),
    ProductConceptFeature(ProductConceptFeature<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage<'a>),
    ProductDefinition(ProductDefinition<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute<'a>),
    PropertyDefinition(PropertyDefinition<'a>),
    RequirementForActionResource(RequirementForActionResource<'a>),
    ResourceProperty(ResourceProperty<'a>),
    SecurityClassification(SecurityClassification<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel<'a>),
    ShapeRepresentation(ShapeRepresentation<'a>),
    VersionedActionRequest(VersionedActionRequest<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for TimeIntervalItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Action<'a>>::parse, |r| TimeIntervalItem::Action(r)),
            map(<ActionDirective<'a>>::parse, |r| TimeIntervalItem::ActionDirective(r)),
            map(<ActionMethod<'a>>::parse, |r| TimeIntervalItem::ActionMethod(r)),
            map(<ActionProperty<'a>>::parse, |r| TimeIntervalItem::ActionProperty(r)),
            map(<ActionRelationship<'a>>::parse, |r| TimeIntervalItem::ActionRelationship(r)),
            map(<ActionRequestSolution<'a>>::parse, |r| TimeIntervalItem::ActionRequestSolution(r)),
            map(<AlternateProductRelationship<'a>>::parse, |r| TimeIntervalItem::AlternateProductRelationship(r)),
            map(<AppliedActionAssignment<'a>>::parse, |r| TimeIntervalItem::AppliedActionAssignment(r)),
            map(<AppliedClassificationAssignment<'a>>::parse, |r| TimeIntervalItem::AppliedClassificationAssignment(r)),
            map(<AppliedPersonAndOrganizationAssignment<'a>>::parse, |r| TimeIntervalItem::AppliedPersonAndOrganizationAssignment(r)),
            map(<ApprovalStatus<'a>>::parse, |r| TimeIntervalItem::ApprovalStatus(r)),
            map(<AssemblyComponentUsageSubstitute<'a>>::parse, |r| TimeIntervalItem::AssemblyComponentUsageSubstitute(r)),
            map(<Certification<'a>>::parse, |r| TimeIntervalItem::Certification(r)),
            map(<Class<'a>>::parse, |r| TimeIntervalItem::Class(r)),
            map(<ClassSystem<'a>>::parse, |r| TimeIntervalItem::ClassSystem(r)),
            map(<ConfigurationDesign<'a>>::parse, |r| TimeIntervalItem::ConfigurationDesign(r)),
            map(<ConfigurationEffectivity<'a>>::parse, |r| TimeIntervalItem::ConfigurationEffectivity(r)),
            map(<ConfigurationItem<'a>>::parse, |r| TimeIntervalItem::ConfigurationItem(r)),
            map(<ConfiguredEffectivityAssignment<'a>>::parse, |r| TimeIntervalItem::ConfiguredEffectivityAssignment(r)),
        alt((
            map(<Contract<'a>>::parse, |r| TimeIntervalItem::Contract(r)),
            map(<DocumentFile<'a>>::parse, |r| TimeIntervalItem::DocumentFile(r)),
            map(<DraughtingModel<'a>>::parse, |r| TimeIntervalItem::DraughtingModel(r)),
            map(<DrawingRevision<'a>>::parse, |r| TimeIntervalItem::DrawingRevision(r)),
            map(<ExecutedAction<'a>>::parse, |r| TimeIntervalItem::ExecutedAction(r)),
            map(<GeneralProperty<'a>>::parse, |r| TimeIntervalItem::GeneralProperty(r)),
            map(<MaterialDesignation<'a>>::parse, |r| TimeIntervalItem::MaterialDesignation(r)),
            map(<MechanicalDesignGeometricPresentationRepresentation<'a>>::parse, |r| TimeIntervalItem::MechanicalDesignGeometricPresentationRepresentation(r)),
            map(<OrganizationRelationship<'a>>::parse, |r| TimeIntervalItem::OrganizationRelationship(r)),
            map(<OrganizationalProject<'a>>::parse, |r| TimeIntervalItem::OrganizationalProject(r)),
            map(<PersonAndOrganization<'a>>::parse, |r| TimeIntervalItem::PersonAndOrganization(r)),
            map(<PresentationArea<'a>>::parse, |r| TimeIntervalItem::PresentationArea(r)),
            map(<Product<'a>>::parse, |r| TimeIntervalItem::Product(r)),
            map(<ProductConcept<'a>>::parse, |r| TimeIntervalItem::ProductConcept(r)),
            map(<ProductConceptFeature<'a>>::parse, |r| TimeIntervalItem::ProductConceptFeature(r)),
            map(<ProductConceptFeatureAssociation<'a>>::parse, |r| TimeIntervalItem::ProductConceptFeatureAssociation(r)),
            map(<ProductConceptFeatureCategory<'a>>::parse, |r| TimeIntervalItem::ProductConceptFeatureCategory(r)),
            map(<ProductConceptFeatureCategoryUsage<'a>>::parse, |r| TimeIntervalItem::ProductConceptFeatureCategoryUsage(r)),
            map(<ProductDefinition<'a>>::parse, |r| TimeIntervalItem::ProductDefinition(r)),
        alt((
            map(<ProductDefinitionFormation<'a>>::parse, |r| TimeIntervalItem::ProductDefinitionFormation(r)),
            map(<ProductDefinitionFormationRelationship<'a>>::parse, |r| TimeIntervalItem::ProductDefinitionFormationRelationship(r)),
            map(<ProductDefinitionRelationship<'a>>::parse, |r| TimeIntervalItem::ProductDefinitionRelationship(r)),
            map(<ProductDefinitionSubstitute<'a>>::parse, |r| TimeIntervalItem::ProductDefinitionSubstitute(r)),
            map(<PropertyDefinition<'a>>::parse, |r| TimeIntervalItem::PropertyDefinition(r)),
            map(<RequirementForActionResource<'a>>::parse, |r| TimeIntervalItem::RequirementForActionResource(r)),
            map(<ResourceProperty<'a>>::parse, |r| TimeIntervalItem::ResourceProperty(r)),
            map(<SecurityClassification<'a>>::parse, |r| TimeIntervalItem::SecurityClassification(r)),
            map(<SecurityClassificationLevel<'a>>::parse, |r| TimeIntervalItem::SecurityClassificationLevel(r)),
            map(<ShapeRepresentation<'a>>::parse, |r| TimeIntervalItem::ShapeRepresentation(r)),
            map(<VersionedActionRequest<'a>>::parse, |r| TimeIntervalItem::VersionedActionRequest(r)),
        ))))))(s)
    }
}
pub struct TimeIntervalRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalRole<'a> = Id<TimeIntervalRole_<'a>>;
pub struct TimeIntervalWithBounds_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub primary_bound: Option<DateTimeOrEventOccurrence<'a>>,
    pub secondary_bound: Option<DateTimeOrEventOccurrence<'a>>,
    pub duration: Option<TimeMeasureWithUnit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalWithBounds<'a> = Id<TimeIntervalWithBounds_<'a>>;
pub struct TimeMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for TimeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> TimeMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct TimeMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeMeasureWithUnit<'a> = Id<TimeMeasureWithUnit_<'a>>;
pub struct TimeUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeUnit<'a> = Id<TimeUnit_<'a>>;
pub enum ToleranceDeviationSelect<'a> { // select
    CurveToleranceDeviation(CurveToleranceDeviation<'a>),
    SurfaceToleranceDeviation(SurfaceToleranceDeviation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ToleranceDeviationSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<CurveToleranceDeviation<'a>>::parse, |r| ToleranceDeviationSelect::CurveToleranceDeviation(r)),
            map(<SurfaceToleranceDeviation<'a>>::parse, |r| ToleranceDeviationSelect::SurfaceToleranceDeviation(r)),
        ))(s)
    }
}
pub enum ToleranceMethodDefinition<'a> { // select
    ToleranceValue(ToleranceValue<'a>),
    LimitsAndFits(LimitsAndFits<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ToleranceMethodDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ToleranceValue<'a>>::parse, |r| ToleranceMethodDefinition::ToleranceValue(r)),
            map(<LimitsAndFits<'a>>::parse, |r| ToleranceMethodDefinition::LimitsAndFits(r)),
        ))(s)
    }
}
pub enum ToleranceParameterSelect<'a> { // select
    CurveToleranceParameter(CurveToleranceParameter<'a>),
    SurfaceToleranceParameter(SurfaceToleranceParameter<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ToleranceParameterSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<CurveToleranceParameter<'a>>::parse, |r| ToleranceParameterSelect::CurveToleranceParameter(r)),
            map(<SurfaceToleranceParameter<'a>>::parse, |r| ToleranceParameterSelect::SurfaceToleranceParameter(r)),
        ))(s)
    }
}
pub enum ToleranceSelect<'a> { // select
    ApproximationToleranceDeviation(ApproximationToleranceDeviation<'a>),
    ApproximationToleranceParameter(ApproximationToleranceParameter<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ToleranceSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ApproximationToleranceDeviation<'a>>::parse, |r| ToleranceSelect::ApproximationToleranceDeviation(r)),
            map(<ApproximationToleranceParameter<'a>>::parse, |r| ToleranceSelect::ApproximationToleranceParameter(r)),
        ))(s)
    }
}
pub struct ToleranceValue_<'a> { // entity
    pub lower_bound: MeasureWithUnit<'a>,
    pub upper_bound: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceValue<'a> = Id<ToleranceValue_<'a>>;
pub struct ToleranceZone_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    pub defining_tolerance: Vec<GeometricTolerance<'a>>,
    pub form: ToleranceZoneForm<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceZone<'a> = Id<ToleranceZone_<'a>>;
pub struct ToleranceZoneDefinition_<'a> { // entity
    pub zone: ToleranceZone<'a>,
    pub boundaries: Vec<ShapeAspect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceZoneDefinition<'a> = Id<ToleranceZoneDefinition_<'a>>;
pub struct ToleranceZoneForm_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceZoneForm<'a> = Id<ToleranceZoneForm_<'a>>;
pub struct TopologicalRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TopologicalRepresentationItem<'a> = Id<TopologicalRepresentationItem_<'a>>;
pub struct ToroidalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub major_radius: PositiveLengthMeasure<'a>,
    pub minor_radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToroidalSurface<'a> = Id<ToroidalSurface_<'a>>;
pub struct Torus_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis1Placement<'a>,
    pub major_radius: PositiveLengthMeasure<'a>,
    pub minor_radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Torus<'a> = Id<Torus_<'a>>;
pub struct TotalRunoutTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TotalRunoutTolerance<'a> = Id<TotalRunoutTolerance_<'a>>;
pub enum Transformation<'a> { // select
    ItemDefinedTransformation(ItemDefinedTransformation<'a>),
    FunctionallyDefinedTransformation(FunctionallyDefinedTransformation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for Transformation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ItemDefinedTransformation<'a>>::parse, |r| Transformation::ItemDefinedTransformation(r)),
            map(<FunctionallyDefinedTransformation<'a>>::parse, |r| Transformation::FunctionallyDefinedTransformation(r)),
        ))(s)
    }
}
pub enum TransitionCode<'a> { // enum
    Discontinuous,
    Continuous,
    ContSameGradient,
    ContSameGradientSameCurvature,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TransitionCode<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TransitionCode::*;
        alt((
            map(tag(".DISCONTINUOUS."), |_| Discontinuous),
            map(tag(".CONTINUOUS."), |_| Continuous),
            map(tag(".CONT_SAME_GRADIENT."), |_| ContSameGradient),
            map(tag(".CONT_SAME_GRADIENT_SAME_CURVATURE."), |_| ContSameGradientSameCurvature),
        ))(s)
    }
}
pub struct TransitionFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TransitionFeature<'a> = Id<TransitionFeature_<'a>>;
pub enum TranslationalRangeMeasure<'a> { // select
    LengthMeasure(LengthMeasure<'a>),
    UnlimitedRange(UnlimitedRange<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for TranslationalRangeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<LengthMeasure<'a>>::parse, |r| TranslationalRangeMeasure::LengthMeasure(r)),
            map(<UnlimitedRange<'a>>::parse, |r| TranslationalRangeMeasure::UnlimitedRange(r)),
        ))(s)
    }
}
pub struct TrimmedCurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub trim_1: Vec<TrimmingSelect<'a>>,
    pub trim_2: Vec<TrimmingSelect<'a>>,
    pub sense_agreement: bool,
    pub master_representation: TrimmingPreference<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TrimmedCurve<'a> = Id<TrimmedCurve_<'a>>;
pub enum TrimmingPreference<'a> { // enum
    Cartesian,
    Parameter,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TrimmingPreference<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TrimmingPreference::*;
        alt((
            map(tag(".CARTESIAN."), |_| Cartesian),
            map(tag(".PARAMETER."), |_| Parameter),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
pub enum TrimmingSelect<'a> { // select
    CartesianPoint(CartesianPoint<'a>),
    ParameterValue(ParameterValue<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for TrimmingSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<CartesianPoint<'a>>::parse, |r| TrimmingSelect::CartesianPoint(r)),
            map(<ParameterValue<'a>>::parse, |r| TrimmingSelect::ParameterValue(r)),
        ))(s)
    }
}
pub struct TwoDirectionRepeatFactor_<'a> { // entity
    pub name: Label<'a>,
    pub repeat_factor: Vector<'a>,
    pub second_repeat_factor: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TwoDirectionRepeatFactor<'a> = Id<TwoDirectionRepeatFactor_<'a>>;
pub struct TypeQualifier_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TypeQualifier<'a> = Id<TypeQualifier_<'a>>;
pub struct UDirectionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for UDirectionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> UDirectionCount<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct UnaryBooleanExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryBooleanExpression<'a> = Id<UnaryBooleanExpression_<'a>>;
pub struct UnaryFunctionCall_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryFunctionCall<'a> = Id<UnaryFunctionCall_<'a>>;
pub struct UnaryGenericExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryGenericExpression<'a> = Id<UnaryGenericExpression_<'a>>;
pub struct UnaryNumericExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryNumericExpression<'a> = Id<UnaryNumericExpression_<'a>>;
pub struct UncertaintyAssignedRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    pub uncertainty: Vec<UncertaintyMeasureWithUnit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UncertaintyAssignedRepresentation<'a> = Id<UncertaintyAssignedRepresentation_<'a>>;
pub struct UncertaintyMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UncertaintyMeasureWithUnit<'a> = Id<UncertaintyMeasureWithUnit_<'a>>;
pub struct UncertaintyQualifier_<'a> { // entity
    pub measure_name: Label<'a>,
    pub description: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UncertaintyQualifier<'a> = Id<UncertaintyQualifier_<'a>>;
pub struct UnconstrainedPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnconstrainedPair<'a> = Id<UnconstrainedPair_<'a>>;
pub struct UnconstrainedPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_placement: Axis2Placement3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnconstrainedPairValue<'a> = Id<UnconstrainedPairValue_<'a>>;
pub struct UniformCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Option<bool>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniformCurve<'a> = Id<UniformCurve_<'a>>;
pub struct UniformSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Option<bool>,
    pub v_closed: Option<bool>,
    pub self_intersect: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniformSurface<'a> = Id<UniformSurface_<'a>>;
pub enum Unit<'a> { // select
    DerivedUnit(DerivedUnit<'a>),
    NamedUnit(NamedUnit<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for Unit<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<DerivedUnit<'a>>::parse, |r| Unit::DerivedUnit(r)),
            map(<NamedUnit<'a>>::parse, |r| Unit::NamedUnit(r)),
        ))(s)
    }
}
pub struct UniversalPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub input_skew_angle: Option<PlaneAngleMeasure<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniversalPair<'a> = Id<UniversalPair_<'a>>;
pub struct UniversalPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_first_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_first_rotation: RotationalRangeMeasure<'a>,
    pub lower_limit_second_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_second_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniversalPairRange<'a> = Id<UniversalPairRange_<'a>>;
pub struct UniversalPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub first_rotation_angle: PlaneAngleMeasure<'a>,
    pub second_rotation_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniversalPairValue<'a> = Id<UniversalPairValue_<'a>>;
pub enum UnlimitedRange<'a> { // enum
    Unlimited,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for UnlimitedRange<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use UnlimitedRange::*;
        map(tag(".UNLIMITED."), |_| Unlimited)(s)
    }
}
pub struct VDirectionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for VDirectionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> VDirectionCount<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct ValueFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ValueFunction<'a> = Id<ValueFunction_<'a>>;
pub enum ValueQualifier<'a> { // select
    PrecisionQualifier(PrecisionQualifier<'a>),
    TypeQualifier(TypeQualifier<'a>),
    UncertaintyQualifier(UncertaintyQualifier<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ValueQualifier<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PrecisionQualifier<'a>>::parse, |r| ValueQualifier::PrecisionQualifier(r)),
            map(<TypeQualifier<'a>>::parse, |r| ValueQualifier::TypeQualifier(r)),
            map(<UncertaintyQualifier<'a>>::parse, |r| ValueQualifier::UncertaintyQualifier(r)),
        ))(s)
    }
}
pub struct ValueRange_<'a> { // entity
    pub name: Label<'a>,
    pub item_element: CompoundItemDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ValueRange<'a> = Id<ValueRange_<'a>>;
pub struct ValueRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub value_component: MeasureValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ValueRepresentationItem<'a> = Id<ValueRepresentationItem_<'a>>;
pub struct Variable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Variable<'a> = Id<Variable_<'a>>;
pub struct VariableSemantics_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VariableSemantics<'a> = Id<VariableSemantics_<'a>>;
pub struct Vector_<'a> { // entity
    pub name: Label<'a>,
    pub orientation: Direction<'a>,
    pub magnitude: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Vector<'a> = Id<Vector_<'a>>;
pub enum VectorOrDirection<'a> { // select
    Vector(Vector<'a>),
    Direction(Direction<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for VectorOrDirection<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<Vector<'a>>::parse, |r| VectorOrDirection::Vector(r)),
            map(<Direction<'a>>::parse, |r| VectorOrDirection::Direction(r)),
        ))(s)
    }
}
#[allow(non_snake_case)]
pub struct VectorStyle_<'a> { // entity
    pub name: Label<'a>,
    pub curve_style__name: Label<'a>,
    pub curve_font: CurveFontOrScaledCurveFontSelect<'a>,
    pub curve_width: SizeSelect<'a>,
    pub curve_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VectorStyle<'a> = Id<VectorStyle_<'a>>;
pub struct VeeProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Option<bool>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VeeProfile<'a> = Id<VeeProfile_<'a>>;
pub struct VersionedActionRequest_<'a> { // entity
    pub id: Identifier<'a>,
    pub version: Label<'a>,
    pub purpose: Text<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VersionedActionRequest<'a> = Id<VersionedActionRequest_<'a>>;
pub struct VersionedActionRequestRelationship_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_versioned_action_request: VersionedActionRequest<'a>,
    pub related_versioned_action_request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VersionedActionRequestRelationship<'a> = Id<VersionedActionRequestRelationship_<'a>>;
pub struct Vertex_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Vertex<'a> = Id<Vertex_<'a>>;
pub struct VertexLoop_<'a> { // entity
    pub name: Label<'a>,
    pub loop_vertex: Vertex<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VertexLoop<'a> = Id<VertexLoop_<'a>>;
pub struct VertexPoint_<'a> { // entity
    pub name: Label<'a>,
    pub vertex_geometry: Point<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VertexPoint<'a> = Id<VertexPoint_<'a>>;
pub struct ViewVolume_<'a> { // entity
    pub projection_type: CentralOrParallel<'a>,
    pub projection_point: CartesianPoint<'a>,
    pub view_plane_distance: LengthMeasure<'a>,
    pub front_plane_distance: LengthMeasure<'a>,
    pub front_plane_clipping: bool,
    pub back_plane_distance: LengthMeasure<'a>,
    pub back_plane_clipping: bool,
    pub view_volume_sides_clipping: bool,
    pub view_window: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ViewVolume<'a> = Id<ViewVolume_<'a>>;
pub struct VisualAppearanceRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VisualAppearanceRepresentation<'a> = Id<VisualAppearanceRepresentation_<'a>>;
pub struct VolumeMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for VolumeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> VolumeMeasure<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub struct VolumeMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VolumeMeasureWithUnit<'a> = Id<VolumeMeasureWithUnit_<'a>>;
pub struct VolumeUnit_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VolumeUnit<'a> = Id<VolumeUnit_<'a>>;
pub struct XorExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type XorExpression<'a> = Id<XorExpression_<'a>>;
pub struct YearNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for YearNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        Self::parse_inner(s)
    }
}
impl<'a> YearNumber<'a> {
    pub fn parse_inner(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse_inner, |r| Self(r, std::marker::PhantomData))(s)
    }
}
pub enum YprEnumeration<'a> { // enum
    Yaw,
    Pitch,
    Roll,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for YprEnumeration<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use YprEnumeration::*;
        alt((
            map(tag(".YAW."), |_| Yaw),
            map(tag(".PITCH."), |_| Pitch),
            map(tag(".ROLL."), |_| Roll),
        ))(s)
    }
}
pub struct YprRotation<'a>(pub Vec<PlaneAngleMeasure<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for YprRotation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<PlaneAngleMeasure<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
