// Autogenerated file, do not hand-edit!
#![allow(non_snake_case)]
use crate::{
    id::Id,
    parse::{IResult, Logical, Derived, Parse, ParseFromChunks,
            param_from_chunks, parse_complex_mapping},
    step_file::FromEntity,
    declare_entity,
};
use nom::{
    branch::{alt},
    bytes::complete::{tag},
    character::complete::{alpha0, alphanumeric1, char},
    combinator::{map, recognize},
    multi::{many0},
    sequence::{delimited, pair},
};
use paste::paste;

declare_entity!(AbsFunction,
    operand: GenericExpression<'a>,
);
declare_entity!(AcosFunction,
    operand: GenericExpression<'a>,
);
declare_entity!(Action,
    name: Label<'a>,
    description: Option<Text<'a>>,
    chosen_method: ActionMethod<'a>,
);
declare_entity!(ActionAssignment,
    assigned_action: Action<'a>,
);
declare_entity!(ActionDirective,
    name: Label<'a>,
    description: Option<Text<'a>>,
    analysis: Text<'a>,
    comment: Text<'a>,
    requests: Vec<VersionedActionRequest<'a>>,
);
#[derive(Debug)]
pub struct ActionItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ActionItem<'a> = Id<ActionItem_<'a>>;

declare_entity!(ActionMethod,
    name: Label<'a>,
    description: Option<Text<'a>>,
    consequence: Text<'a>,
    purpose: Text<'a>,
);
declare_entity!(ActionMethodRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_method: ActionMethod<'a>,
    related_method: ActionMethod<'a>,
);
declare_entity!(ActionProperty,
    name: Label<'a>,
    description: Text<'a>,
    definition: CharacterizedActionDefinition<'a>,
);
declare_entity!(ActionPropertyRepresentation,
    name: Label<'a>,
    description: Text<'a>,
    property: ActionProperty<'a>,
    representation: Representation<'a>,
);
declare_entity!(ActionRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_action: Action<'a>,
    related_action: Action<'a>,
);
declare_entity!(ActionRequestAssignment,
    assigned_action_request: VersionedActionRequest<'a>,
);
#[derive(Debug)]
pub struct ActionRequestItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ActionRequestItem<'a> = Id<ActionRequestItem_<'a>>;

declare_entity!(ActionRequestSolution,
    method: ActionMethod<'a>,
    request: VersionedActionRequest<'a>,
);
declare_entity!(ActionRequestStatus,
    status: Label<'a>,
    assigned_request: VersionedActionRequest<'a>,
);
declare_entity!(ActionResource,
    name: Label<'a>,
    description: Option<Text<'a>>,
    usage: Vec<SupportedItem<'a>>,
    kind: ActionResourceType<'a>,
);
declare_entity!(ActionResourceRequirement,
    name: Label<'a>,
    description: Text<'a>,
    kind: ResourceRequirementType<'a>,
    operations: Vec<CharacterizedActionDefinition<'a>>,
);
declare_entity!(ActionResourceType,
    name: Label<'a>,
);
declare_entity!(ActionStatus,
    status: Label<'a>,
    assigned_action: ExecutedAction<'a>,
);
declare_entity!(Address,
    internal_location: Option<Label<'a>>,
    street_number: Option<Label<'a>>,
    street: Option<Label<'a>>,
    postal_box: Option<Label<'a>>,
    town: Option<Label<'a>>,
    region: Option<Label<'a>>,
    postal_code: Option<Label<'a>>,
    country: Option<Label<'a>>,
    facsimile_number: Option<Label<'a>>,
    telephone_number: Option<Label<'a>>,
    electronic_mail_address: Option<Label<'a>>,
    telex_number: Option<Label<'a>>,
);
declare_entity!(AdvancedBrepShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(AdvancedFace,
    name: Label<'a>,
    bounds: Vec<FaceBound<'a>>,
    face_geometry: Surface<'a>,
    same_sense: bool,
);
#[derive(Debug)]
pub enum AheadOrBehind<'a> { // enum
    Ahead,
    Exact,
    Behind,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for AheadOrBehind<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use AheadOrBehind::*;
        alt((
            map(tag(".AHEAD."), |_| Ahead),
            map(tag(".EXACT."), |_| Exact),
            map(tag(".BEHIND."), |_| Behind),
        ))(s)
    }
}
declare_entity!(AlternateProductRelationship,
    name: Label<'a>,
    definition: Option<Text<'a>>,
    alternate: Product<'a>,
    base: Product<'a>,
    basis: Text<'a>,
);
#[derive(Debug)]
pub struct AmountOfSubstanceMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for AmountOfSubstanceMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(AmountOfSubstanceMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(AmountOfSubstanceUnit,
    dimensions: DimensionalExponents<'a>,
);
declare_entity!(AndExpression,
    operands: Vec<GenericExpression<'a>>,
);
#[derive(Debug)]
pub enum AngleRelator<'a> { // enum
    Equal,
    Large,
    Small,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for AngleRelator<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use AngleRelator::*;
        alt((
            map(tag(".EQUAL."), |_| Equal),
            map(tag(".LARGE."), |_| Large),
            map(tag(".SMALL."), |_| Small),
        ))(s)
    }
}
declare_entity!(AngularDimension,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(AngularLocation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
    angle_selection: AngleRelator<'a>,
);
declare_entity!(AngularSize,
    applies_to: ShapeAspect<'a>,
    name: Label<'a>,
    angle_selection: AngleRelator<'a>,
);
declare_entity!(AngularityTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
    datum_system: Vec<DatumReference<'a>>,
);
declare_entity!(AnnotationCurveOccurrence,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
);
declare_entity!(AnnotationFillArea,
    name: Label<'a>,
    boundaries: Vec<Curve<'a>>,
);
declare_entity!(AnnotationFillAreaOccurrence,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
    fill_style_target: Point<'a>,
);
declare_entity!(AnnotationOccurrence,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
);
declare_entity!(AnnotationOccurrenceAssociativity,
    name: Label<'a>,
    description: Text<'a>,
    relating_annotation_occurrence: AnnotationOccurrence<'a>,
    related_annotation_occurrence: AnnotationOccurrence<'a>,
);
declare_entity!(AnnotationOccurrenceRelationship,
    name: Label<'a>,
    description: Text<'a>,
    relating_annotation_occurrence: AnnotationOccurrence<'a>,
    related_annotation_occurrence: AnnotationOccurrence<'a>,
);
declare_entity!(AnnotationPlane,
    representation_item__name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
    elements: Option<Vec<AnnotationPlaneElement<'a>>>,
);
#[derive(Debug)]
pub struct AnnotationPlaneElement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AnnotationPlaneElement<'a> = Id<AnnotationPlaneElement_<'a>>;

declare_entity!(AnnotationSubfigureOccurrence,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
);
declare_entity!(AnnotationSymbol,
    name: Label<'a>,
    mapping_source: RepresentationMap<'a>,
    mapping_target: RepresentationItem<'a>,
);
declare_entity!(AnnotationSymbolOccurrence,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
);
#[derive(Debug)]
pub struct AnnotationSymbolOccurrenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AnnotationSymbolOccurrenceItem<'a> = Id<AnnotationSymbolOccurrenceItem_<'a>>;

declare_entity!(AnnotationText,
    name: Label<'a>,
    mapping_source: RepresentationMap<'a>,
    mapping_target: RepresentationItem<'a>,
);
declare_entity!(AnnotationTextCharacter,
    name: Label<'a>,
    mapping_source: RepresentationMap<'a>,
    mapping_target: RepresentationItem<'a>,
    alignment: TextAlignment<'a>,
);
declare_entity!(AnnotationTextOccurrence,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
);
#[derive(Debug)]
pub struct AnnotationTextOccurrenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AnnotationTextOccurrenceItem<'a> = Id<AnnotationTextOccurrenceItem_<'a>>;

declare_entity!(Apex,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(ApplicationContext,
    application: Label<'a>,
);
declare_entity!(ApplicationContextElement,
    name: Label<'a>,
    frame_of_reference: ApplicationContext<'a>,
);
declare_entity!(ApplicationContextRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_context: ApplicationContext<'a>,
    related_context: ApplicationContext<'a>,
);
declare_entity!(ApplicationProtocolDefinition,
    status: Label<'a>,
    application_interpreted_model_schema_name: Label<'a>,
    application_protocol_year: YearNumber<'a>,
    application: ApplicationContext<'a>,
);
declare_entity!(AppliedActionAssignment,
    assigned_action: Action<'a>,
    items: Vec<ActionItem<'a>>,
);
declare_entity!(AppliedActionRequestAssignment,
    assigned_action_request: VersionedActionRequest<'a>,
    items: Vec<ActionRequestItem<'a>>,
);
declare_entity!(AppliedApprovalAssignment,
    assigned_approval: Approval<'a>,
    items: Vec<ApprovalItem<'a>>,
);
declare_entity!(AppliedArea,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(AppliedCertificationAssignment,
    assigned_certification: Certification<'a>,
    items: Vec<CertificationItem<'a>>,
);
declare_entity!(AppliedClassificationAssignment,
    assigned_class: Group<'a>,
    role: ClassificationRole<'a>,
    items: Vec<ClassificationItem<'a>>,
);
declare_entity!(AppliedContractAssignment,
    assigned_contract: Contract<'a>,
    items: Vec<ContractItem<'a>>,
);
declare_entity!(AppliedDateAndTimeAssignment,
    assigned_date_and_time: DateAndTime<'a>,
    role: DateTimeRole<'a>,
    items: Vec<DateAndTimeItem<'a>>,
);
declare_entity!(AppliedDateAssignment,
    assigned_date: Date<'a>,
    role: DateRole<'a>,
    items: Vec<DateItem<'a>>,
);
declare_entity!(AppliedDocumentReference,
    assigned_document: Document<'a>,
    source: Label<'a>,
    items: Vec<DocumentReferenceItem<'a>>,
);
declare_entity!(AppliedDocumentUsageConstraintAssignment,
    assigned_document_usage: DocumentUsageConstraint<'a>,
    role: DocumentUsageRole<'a>,
    items: Vec<DocumentReferenceItem<'a>>,
);
declare_entity!(AppliedEffectivityAssignment,
    assigned_effectivity: Effectivity<'a>,
    items: Vec<EffectivityItem<'a>>,
);
declare_entity!(AppliedEventOccurrenceAssignment,
    assigned_event_occurrence: EventOccurrence<'a>,
    role: EventOccurrenceRole<'a>,
    items: Vec<EventOccurrenceItem<'a>>,
);
declare_entity!(AppliedExternalIdentificationAssignment,
    assigned_id: Identifier<'a>,
    role: IdentificationRole<'a>,
    source: ExternalSource<'a>,
    items: Vec<ExternalIdentificationItem<'a>>,
);
declare_entity!(AppliedGroupAssignment,
    assigned_group: Group<'a>,
    items: Vec<GroupItem<'a>>,
);
declare_entity!(AppliedIdentificationAssignment,
    assigned_id: Identifier<'a>,
    role: IdentificationRole<'a>,
    items: Vec<IdentificationItem<'a>>,
);
declare_entity!(AppliedIneffectivityAssignment,
    assigned_effectivity: Effectivity<'a>,
    items: Vec<EffectivityItem<'a>>,
);
declare_entity!(AppliedNameAssignment,
    assigned_name: Label<'a>,
    items: Vec<NameItem<'a>>,
);
declare_entity!(AppliedOrganizationAssignment,
    assigned_organization: Organization<'a>,
    role: OrganizationRole<'a>,
    items: Vec<OrganizationItem<'a>>,
);
declare_entity!(AppliedOrganizationalProjectAssignment,
    assigned_organizational_project: OrganizationalProject<'a>,
    role: OrganizationalProjectRole<'a>,
    items: Vec<OrganizationalProjectItem<'a>>,
);
declare_entity!(AppliedPersonAndOrganizationAssignment,
    assigned_person_and_organization: PersonAndOrganization<'a>,
    role: PersonAndOrganizationRole<'a>,
    items: Vec<PersonAndOrganizationItem<'a>>,
);
declare_entity!(AppliedPresentedItem,
    items: Vec<PresentedItemSelect<'a>>,
);
declare_entity!(AppliedSecurityClassificationAssignment,
    assigned_security_classification: SecurityClassification<'a>,
    items: Vec<SecurityClassificationItem<'a>>,
);
declare_entity!(AppliedTimeIntervalAssignment,
    assigned_time_interval: TimeInterval<'a>,
    role: TimeIntervalRole<'a>,
    items: Vec<TimeIntervalItem<'a>>,
);
declare_entity!(Approval,
    status: ApprovalStatus<'a>,
    level: Label<'a>,
);
declare_entity!(ApprovalAssignment,
    assigned_approval: Approval<'a>,
);
declare_entity!(ApprovalDateTime,
    date_time: DateTimeSelect<'a>,
    dated_approval: Approval<'a>,
);
#[derive(Debug)]
pub struct ApprovalItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ApprovalItem<'a> = Id<ApprovalItem_<'a>>;

declare_entity!(ApprovalPersonOrganization,
    person_organization: PersonOrganizationSelect<'a>,
    authorized_approval: Approval<'a>,
    role: ApprovalRole<'a>,
);
declare_entity!(ApprovalRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_approval: Approval<'a>,
    related_approval: Approval<'a>,
);
declare_entity!(ApprovalRole,
    role: Label<'a>,
);
declare_entity!(ApprovalStatus,
    name: Label<'a>,
);
#[derive(Debug)]
pub enum ApproximationMethod<'a> { // enum
    ChordalDeviation,
    ChordalLength,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ApproximationMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ApproximationMethod::*;
        alt((
            map(tag(".CHORDAL_DEVIATION."), |_| ChordalDeviation),
            map(tag(".CHORDAL_LENGTH."), |_| ChordalLength),
        ))(s)
    }
}
declare_entity!(ApproximationTolerance,
    tolerance: ToleranceSelect<'a>,
);
declare_entity!(ApproximationToleranceDeviation,
    tessellation_type: ApproximationMethod<'a>,
    tolerances: Vec<ToleranceDeviationSelect<'a>>,
    definition_space: ProductOrPresentationSpace<'a>,
);
declare_entity!(ApproximationToleranceParameter,
    tolerances: Vec<ToleranceParameterSelect<'a>>,
);
declare_entity!(AreaInSet,
    area: PresentationArea<'a>,
    in_set: PresentationSet<'a>,
);
#[derive(Debug)]
pub struct AreaMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for AreaMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(AreaMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
#[derive(Debug)]
pub struct AreaOrView_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AreaOrView<'a> = Id<AreaOrView_<'a>>;

declare_entity!(AreaUnit,
    elements: Vec<DerivedUnitElement<'a>>,
);
declare_entity!(AsinFunction,
    operand: GenericExpression<'a>,
);
declare_entity!(AssemblyComponentUsage,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_definition: ProductDefinition<'a>,
    related_product_definition: ProductDefinition<'a>,
    reference_designator: Option<Identifier<'a>>,
);
declare_entity!(AssemblyComponentUsageSubstitute,
    name: Label<'a>,
    definition: Option<Text<'a>>,
    base: AssemblyComponentUsage<'a>,
    substitute: AssemblyComponentUsage<'a>,
);
declare_entity!(AtanFunction,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(AttributeClassificationAssignment,
    assigned_class: Group<'a>,
    attribute_name: Label<'a>,
    role: ClassificationRole<'a>,
);
declare_entity!(AttributeLanguageAssignment,
    assigned_class: Group<'a>,
    attribute_name: Label<'a>,
    role: ClassificationRole<'a>,
    items: Vec<AttributeLanguageItem<'a>>,
);
#[derive(Debug)]
pub struct AttributeLanguageItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AttributeLanguageItem<'a> = Id<AttributeLanguageItem_<'a>>;

#[derive(Debug)]
pub enum AttributeType<'a> { // select
    Label(Label<'a>),
    Text(Text<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for AttributeType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LABEL("), <Label<'a>>::parse, char(')')), |r| AttributeType::Label(r)),
            map(delimited(tag("TEXT("), <Text<'a>>::parse, char(')')), |r| AttributeType::Text(r)),
        ))(s)
    }
}
declare_entity!(AttributeValueAssignment,
    attribute_name: Label<'a>,
    attribute_value: AttributeType<'a>,
    role: AttributeValueRole<'a>,
);
declare_entity!(AttributeValueRole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(Axis1Placement,
    name: Label<'a>,
    location: CartesianPoint<'a>,
    axis: Option<Direction<'a>>,
);
#[derive(Debug)]
pub struct Axis2Placement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Axis2Placement<'a> = Id<Axis2Placement_<'a>>;

declare_entity!(Axis2Placement2d,
    name: Label<'a>,
    location: CartesianPoint<'a>,
    ref_direction: Option<Direction<'a>>,
);
declare_entity!(Axis2Placement3d,
    name: Label<'a>,
    location: CartesianPoint<'a>,
    axis: Option<Direction<'a>>,
    ref_direction: Option<Direction<'a>>,
);
declare_entity!(BSplineCurve,
    name: Label<'a>,
    degree: i64,
    control_points_list: Vec<CartesianPoint<'a>>,
    curve_form: BSplineCurveForm<'a>,
    closed_curve: Logical,
    self_intersect: Logical,
);
#[derive(Debug)]
pub enum BSplineCurveForm<'a> { // enum
    PolylineForm,
    CircularArc,
    EllipticArc,
    ParabolicArc,
    HyperbolicArc,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BSplineCurveForm<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BSplineCurveForm::*;
        alt((
            map(tag(".POLYLINE_FORM."), |_| PolylineForm),
            map(tag(".CIRCULAR_ARC."), |_| CircularArc),
            map(tag(".ELLIPTIC_ARC."), |_| EllipticArc),
            map(tag(".PARABOLIC_ARC."), |_| ParabolicArc),
            map(tag(".HYPERBOLIC_ARC."), |_| HyperbolicArc),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
declare_entity!(BSplineCurveWithKnots,
    name: Label<'a>,
    degree: i64,
    control_points_list: Vec<CartesianPoint<'a>>,
    curve_form: BSplineCurveForm<'a>,
    closed_curve: Logical,
    self_intersect: Logical,
    knot_multiplicities: Vec<i64>,
    knots: Vec<ParameterValue<'a>>,
    knot_spec: KnotType<'a>,
);
declare_entity!(BSplineSurface,
    name: Label<'a>,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    surface_form: BSplineSurfaceForm<'a>,
    u_closed: Logical,
    v_closed: Logical,
    self_intersect: Logical,
);
#[derive(Debug)]
pub enum BSplineSurfaceForm<'a> { // enum
    PlaneSurf,
    CylindricalSurf,
    ConicalSurf,
    SphericalSurf,
    ToroidalSurf,
    SurfOfRevolution,
    RuledSurf,
    GeneralisedCone,
    QuadricSurf,
    SurfOfLinearExtrusion,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BSplineSurfaceForm<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BSplineSurfaceForm::*;
        alt((
            map(tag(".PLANE_SURF."), |_| PlaneSurf),
            map(tag(".CYLINDRICAL_SURF."), |_| CylindricalSurf),
            map(tag(".CONICAL_SURF."), |_| ConicalSurf),
            map(tag(".SPHERICAL_SURF."), |_| SphericalSurf),
            map(tag(".TOROIDAL_SURF."), |_| ToroidalSurf),
            map(tag(".SURF_OF_REVOLUTION."), |_| SurfOfRevolution),
            map(tag(".RULED_SURF."), |_| RuledSurf),
            map(tag(".GENERALISED_CONE."), |_| GeneralisedCone),
            map(tag(".QUADRIC_SURF."), |_| QuadricSurf),
            map(tag(".SURF_OF_LINEAR_EXTRUSION."), |_| SurfOfLinearExtrusion),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
declare_entity!(BSplineSurfaceWithKnots,
    name: Label<'a>,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    surface_form: BSplineSurfaceForm<'a>,
    u_closed: Logical,
    v_closed: Logical,
    self_intersect: Logical,
    u_multiplicities: Vec<i64>,
    v_multiplicities: Vec<i64>,
    u_knots: Vec<ParameterValue<'a>>,
    v_knots: Vec<ParameterValue<'a>>,
    knot_spec: KnotType<'a>,
);
declare_entity!(BackgroundColour,
    presentation: AreaOrView<'a>,
);
declare_entity!(BarringHole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(Bead,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(BeadEnd,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(BezierCurve,
    name: Label<'a>,
    degree: i64,
    control_points_list: Vec<CartesianPoint<'a>>,
    curve_form: BSplineCurveForm<'a>,
    closed_curve: Logical,
    self_intersect: Logical,
);
declare_entity!(BezierSurface,
    name: Label<'a>,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    surface_form: BSplineSurfaceForm<'a>,
    u_closed: Logical,
    v_closed: Logical,
    self_intersect: Logical,
);
declare_entity!(BinaryBooleanExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(BinaryFunctionCall,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(BinaryGenericExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(BinaryNumericExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(Block,
    name: Label<'a>,
    position: Axis2Placement3d<'a>,
    x: PositiveLengthMeasure<'a>,
    y: PositiveLengthMeasure<'a>,
    z: PositiveLengthMeasure<'a>,
);
declare_entity!(BooleanDefinedFunction,
);
declare_entity!(BooleanExpression,
);
declare_entity!(BooleanLiteral,
    the_value: bool,
);
#[derive(Debug)]
pub struct BooleanOperand_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type BooleanOperand<'a> = Id<BooleanOperand_<'a>>;

#[derive(Debug)]
pub enum BooleanOperator<'a> { // enum
    Union,
    Intersection,
    Difference,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BooleanOperator<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BooleanOperator::*;
        alt((
            map(tag(".UNION."), |_| Union),
            map(tag(".INTERSECTION."), |_| Intersection),
            map(tag(".DIFFERENCE."), |_| Difference),
        ))(s)
    }
}
declare_entity!(BooleanResult,
    name: Label<'a>,
    operator: BooleanOperator<'a>,
    first_operand: BooleanOperand<'a>,
    second_operand: BooleanOperand<'a>,
);
declare_entity!(BooleanVariable,
);
declare_entity!(Boss,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(BossTop,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(BoundaryCurve,
    name: Label<'a>,
    segments: Vec<CompositeCurveSegment<'a>>,
    self_intersect: Logical,
);
declare_entity!(BoundedCurve,
    name: Label<'a>,
);
declare_entity!(BoundedPcurve,
    representation_item__name: Label<'a>,
    basis_surface: Surface<'a>,
    reference_to_curve: DefinitionalRepresentation<'a>,
);
declare_entity!(BoundedSurface,
    name: Label<'a>,
);
declare_entity!(BoundedSurfaceCurve,
    representation_item__name: Label<'a>,
    curve_3d: Curve<'a>,
    associated_geometry: Vec<PcurveOrSurface<'a>>,
    master_representation: PreferredSurfaceCurveRepresentation<'a>,
);
#[derive(Debug)]
pub enum BoxCharacteristicSelect<'a> { // select
    BoxHeight(BoxHeight<'a>),
    BoxWidth(BoxWidth<'a>),
    BoxSlantAngle(BoxSlantAngle<'a>),
    BoxRotateAngle(BoxRotateAngle<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for BoxCharacteristicSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("BOX_HEIGHT("), <BoxHeight<'a>>::parse, char(')')), |r| BoxCharacteristicSelect::BoxHeight(r)),
            map(delimited(tag("BOX_WIDTH("), <BoxWidth<'a>>::parse, char(')')), |r| BoxCharacteristicSelect::BoxWidth(r)),
            map(delimited(tag("BOX_SLANT_ANGLE("), <BoxSlantAngle<'a>>::parse, char(')')), |r| BoxCharacteristicSelect::BoxSlantAngle(r)),
            map(delimited(tag("BOX_ROTATE_ANGLE("), <BoxRotateAngle<'a>>::parse, char(')')), |r| BoxCharacteristicSelect::BoxRotateAngle(r)),
        ))(s)
    }
}
declare_entity!(BoxDomain,
    corner: CartesianPoint<'a>,
    xlength: PositiveLengthMeasure<'a>,
    ylength: PositiveLengthMeasure<'a>,
    zlength: PositiveLengthMeasure<'a>,
);

#[derive(Debug)]
pub struct BoxHeight<'a>(pub PositiveRatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxHeight<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveRatioMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct BoxRotateAngle<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxRotateAngle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct BoxSlantAngle<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxSlantAngle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct BoxWidth<'a>(pub PositiveRatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxWidth<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveRatioMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(BoxedHalfSpace,
    name: Label<'a>,
    base_surface: Surface<'a>,
    agreement_flag: bool,
    enclosure: BoxDomain<'a>,
);
declare_entity!(BrepWithVoids,
    name: Label<'a>,
    outer: ClosedShell<'a>,
    voids: Vec<OrientedClosedShell<'a>>,
);
declare_entity!(CalendarDate,
    year_component: YearNumber<'a>,
    day_component: DayInMonthNumber<'a>,
    month_component: MonthInYearNumber<'a>,
);
declare_entity!(CameraImage,
    name: Label<'a>,
    mapping_source: RepresentationMap<'a>,
    mapping_target: RepresentationItem<'a>,
);
declare_entity!(CameraImage2dWithScale,
    name: Label<'a>,
    mapping_source: RepresentationMap<'a>,
    mapping_target: RepresentationItem<'a>,
);
declare_entity!(CameraImage3dWithScale,
    name: Label<'a>,
    mapping_source: RepresentationMap<'a>,
    mapping_target: RepresentationItem<'a>,
);
declare_entity!(CameraModel,
    name: Label<'a>,
);
declare_entity!(CameraModelD2,
    name: Label<'a>,
    view_window: PlanarBox<'a>,
    view_window_clipping: bool,
);
declare_entity!(CameraModelD3,
    name: Label<'a>,
    view_reference_system: Axis2Placement3d<'a>,
    perspective_of_volume: ViewVolume<'a>,
);
declare_entity!(CameraModelD3WithHlhsr,
    name: Label<'a>,
    view_reference_system: Axis2Placement3d<'a>,
    perspective_of_volume: ViewVolume<'a>,
    hidden_line_surface_removal: bool,
);
declare_entity!(CameraUsage,
    mapping_origin: RepresentationItem<'a>,
    mapped_representation: Representation<'a>,
);
declare_entity!(CartesianPoint,
    name: Label<'a>,
    coordinates: Vec<LengthMeasure<'a>>,
);
declare_entity!(CartesianTransformationOperator,
    representation_item__name: Label<'a>,
    functionally_defined_transformation__name: Label<'a>,
    description: Option<Text<'a>>,
    axis1: Option<Direction<'a>>,
    axis2: Option<Direction<'a>>,
    local_origin: CartesianPoint<'a>,
    scale: Option<f64>,
);
declare_entity!(CartesianTransformationOperator2d,
    representation_item__name: Label<'a>,
    functionally_defined_transformation__name: Label<'a>,
    description: Option<Text<'a>>,
    axis1: Option<Direction<'a>>,
    axis2: Option<Direction<'a>>,
    local_origin: CartesianPoint<'a>,
    scale: Option<f64>,
);
declare_entity!(CartesianTransformationOperator3d,
    representation_item__name: Label<'a>,
    functionally_defined_transformation__name: Label<'a>,
    description: Option<Text<'a>>,
    axis1: Option<Direction<'a>>,
    axis2: Option<Direction<'a>>,
    local_origin: CartesianPoint<'a>,
    scale: Option<f64>,
    axis3: Option<Direction<'a>>,
);
#[derive(Debug)]
pub struct CategoryUsageItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CategoryUsageItem<'a> = Id<CategoryUsageItem_<'a>>;

#[derive(Debug)]
pub struct CelsiusTemperatureMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CelsiusTemperatureMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(CelsiusTemperatureMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
#[derive(Debug)]
pub enum CentralOrParallel<'a> { // enum
    Central,
    Parallel,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for CentralOrParallel<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use CentralOrParallel::*;
        alt((
            map(tag(".CENTRAL."), |_| Central),
            map(tag(".PARALLEL."), |_| Parallel),
        ))(s)
    }
}
declare_entity!(CentreOfSymmetry,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(Certification,
    name: Label<'a>,
    purpose: Text<'a>,
    kind: CertificationType<'a>,
);
declare_entity!(CertificationAssignment,
    assigned_certification: Certification<'a>,
);
#[derive(Debug)]
pub struct CertificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CertificationItem<'a> = Id<CertificationItem_<'a>>;

declare_entity!(CertificationType,
    description: Label<'a>,
);
declare_entity!(Chamfer,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(ChamferOffset,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(CharacterGlyphSymbol,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
    character_box: PlanarExtent<'a>,
    baseline_ratio: RatioMeasure<'a>,
);
#[derive(Debug)]
pub enum CharacterSpacingSelect<'a> { // select
    LengthMeasure(LengthMeasure<'a>),
    RatioMeasure(RatioMeasure<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CharacterSpacingSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LENGTH_MEASURE("), <LengthMeasure<'a>>::parse, char(')')), |r| CharacterSpacingSelect::LengthMeasure(r)),
            map(delimited(tag("RATIO_MEASURE("), <RatioMeasure<'a>>::parse, char(')')), |r| CharacterSpacingSelect::RatioMeasure(r)),
            map(<MeasureWithUnit<'a>>::parse, |r| CharacterSpacingSelect::MeasureWithUnit(r)),
            map(delimited(tag("DESCRIPTIVE_MEASURE("), <DescriptiveMeasure<'a>>::parse, char(')')), |r| CharacterSpacingSelect::DescriptiveMeasure(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct CharacterStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterStyleSelect<'a> = Id<CharacterStyleSelect_<'a>>;

#[derive(Debug)]
pub struct CharacterizedActionDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedActionDefinition<'a> = Id<CharacterizedActionDefinition_<'a>>;

declare_entity!(CharacterizedClass,
    characterized_object__name: Label<'a>,
    characterized_object__description: Option<Text<'a>>,
    group__name: Label<'a>,
    group__description: Option<Text<'a>>,
);
#[derive(Debug)]
pub struct CharacterizedDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedDefinition<'a> = Id<CharacterizedDefinition_<'a>>;

#[derive(Debug)]
pub struct CharacterizedMaterialProperty_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedMaterialProperty<'a> = Id<CharacterizedMaterialProperty_<'a>>;

declare_entity!(CharacterizedObject,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
#[derive(Debug)]
pub struct CharacterizedProductDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedProductDefinition<'a> = Id<CharacterizedProductDefinition_<'a>>;

#[derive(Debug)]
pub struct CharacterizedResourceDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedResourceDefinition<'a> = Id<CharacterizedResourceDefinition_<'a>>;

declare_entity!(Circle,
    name: Label<'a>,
    position: Axis2Placement<'a>,
    radius: PositiveLengthMeasure<'a>,
);
declare_entity!(CircularClosedProfile,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(CircularPattern,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(CircularRunoutTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
    datum_system: Vec<DatumReference<'a>>,
);
declare_entity!(Class,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(ClassSystem,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(ClassUsageEffectivityContextAssignment,
    assigned_effectivity_assignment: EffectivityAssignment<'a>,
    role: EffectivityContextRole<'a>,
    items: Vec<ClassUsageEffectivityContextItem<'a>>,
);
#[derive(Debug)]
pub struct ClassUsageEffectivityContextItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ClassUsageEffectivityContextItem<'a> = Id<ClassUsageEffectivityContextItem_<'a>>;

declare_entity!(ClassificationAssignment,
    assigned_class: Group<'a>,
    role: ClassificationRole<'a>,
);
#[derive(Debug)]
pub struct ClassificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ClassificationItem<'a> = Id<ClassificationItem_<'a>>;

declare_entity!(ClassificationRole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(ClosedPathProfile,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(ClosedShell,
    name: Label<'a>,
    cfs_faces: Vec<Face<'a>>,
);
declare_entity!(CoaxialityTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
    datum_system: Vec<DatumReference<'a>>,
);
declare_entity!(Colour,
);
declare_entity!(ColourRgb,
    name: Label<'a>,
    red: f64,
    green: f64,
    blue: f64,
);
declare_entity!(ColourSpecification,
    name: Label<'a>,
);
declare_entity!(CommonDatum,
    shape_aspect__name: Label<'a>,
    shape_aspect__description: Option<Text<'a>>,
    shape_aspect__of_shape: ProductDefinitionShape<'a>,
    shape_aspect__product_definitional: Logical,
    identification: Identifier<'a>,
);
declare_entity!(ComparisonEqual,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(ComparisonExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(ComparisonGreater,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(ComparisonGreaterEqual,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(ComparisonLess,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(ComparisonLessEqual,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(ComparisonNotEqual,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(CompositeCurve,
    name: Label<'a>,
    segments: Vec<CompositeCurveSegment<'a>>,
    self_intersect: Logical,
);
declare_entity!(CompositeCurveOnSurface,
    name: Label<'a>,
    segments: Vec<CompositeCurveSegment<'a>>,
    self_intersect: Logical,
);
declare_entity!(CompositeCurveSegment,
    transition: TransitionCode<'a>,
    same_sense: bool,
    parent_curve: Curve<'a>,
);
declare_entity!(CompositeHole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(CompositeShapeAspect,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(CompositeText,
    name: Label<'a>,
    collected_text: Vec<TextOrCharacter<'a>>,
);
declare_entity!(CompositeTextWithAssociatedCurves,
    name: Label<'a>,
    collected_text: Vec<TextOrCharacter<'a>>,
    associated_curves: Vec<Curve<'a>>,
);
declare_entity!(CompositeTextWithBlankingBox,
    name: Label<'a>,
    collected_text: Vec<TextOrCharacter<'a>>,
    blanking: PlanarBox<'a>,
);
declare_entity!(CompositeTextWithExtent,
    name: Label<'a>,
    collected_text: Vec<TextOrCharacter<'a>>,
    extent: PlanarExtent<'a>,
);
declare_entity!(CompoundFeature,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
#[derive(Debug)]
pub enum CompoundItemDefinition<'a> { // select
    ListRepresentationItem(Vec<RepresentationItem<'a>>),
    SetRepresentationItem(Vec<RepresentationItem<'a>>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CompoundItemDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LIST_REPRESENTATION_ITEM("), <Vec<RepresentationItem<'a>>>::parse, char(')')), |r| CompoundItemDefinition::ListRepresentationItem(r)),
            map(delimited(tag("SET_REPRESENTATION_ITEM("), <Vec<RepresentationItem<'a>>>::parse, char(')')), |r| CompoundItemDefinition::SetRepresentationItem(r)),
        ))(s)
    }
}
declare_entity!(CompoundRepresentationItem,
    name: Label<'a>,
    item_element: CompoundItemDefinition<'a>,
);
declare_entity!(CompoundShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(ConcatExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(ConcentricityTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
    datum_system: Vec<DatumReference<'a>>,
);
declare_entity!(ConceptFeatureOperator,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(ConceptFeatureRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_concept_feature: ProductConceptFeature<'a>,
    related_product_concept_feature: ProductConceptFeature<'a>,
);
declare_entity!(ConceptFeatureRelationshipWithCondition,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_concept_feature: ProductConceptFeature<'a>,
    related_product_concept_feature: ProductConceptFeature<'a>,
    conditional_operator: ConceptFeatureOperator<'a>,
);
declare_entity!(ConditionalConceptFeature,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    condition: ConceptFeatureRelationshipWithCondition<'a>,
);
declare_entity!(ConfigurableItem,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    item_concept: ProductConcept<'a>,
    purpose: Option<Label<'a>>,
    item_concept_feature: Vec<ProductConceptFeatureAssociation<'a>>,
);
declare_entity!(ConfigurationDefinition,
    pair_values: Vec<PairValue<'a>>,
    t_parameter: MotionParameterMeasure<'a>,
);
declare_entity!(ConfigurationDesign,
    configuration: ConfigurationItem<'a>,
    design: ConfigurationDesignItem<'a>,
);
#[derive(Debug)]
pub struct ConfigurationDesignItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ConfigurationDesignItem<'a> = Id<ConfigurationDesignItem_<'a>>;

declare_entity!(ConfigurationEffectivity,
    id: Identifier<'a>,
    usage: ProductDefinitionRelationship<'a>,
    configuration: ConfigurationDesign<'a>,
);
declare_entity!(ConfigurationInterpolation,
    previous_configuration_definition: ConfigurationDefinition<'a>,
    next_configuration_definition: ConfigurationDefinition<'a>,
    interpolation: InterpolationType<'a>,
);
declare_entity!(ConfigurationItem,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    item_concept: ProductConcept<'a>,
    purpose: Option<Label<'a>>,
);
declare_entity!(ConfiguredEffectivityAssignment,
    assigned_effectivity: Effectivity<'a>,
    items: Vec<ConfiguredEffectivityItem<'a>>,
);
declare_entity!(ConfiguredEffectivityContextAssignment,
    assigned_effectivity_assignment: EffectivityAssignment<'a>,
    role: EffectivityContextRole<'a>,
    items: Vec<ConfiguredEffectivityContextItem<'a>>,
);
#[derive(Debug)]
pub struct ConfiguredEffectivityContextItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ConfiguredEffectivityContextItem<'a> = Id<ConfiguredEffectivityContextItem_<'a>>;

#[derive(Debug)]
pub struct ConfiguredEffectivityItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ConfiguredEffectivityItem<'a> = Id<ConfiguredEffectivityItem_<'a>>;

declare_entity!(Conic,
    name: Label<'a>,
    position: Axis2Placement<'a>,
);
declare_entity!(ConicalSurface,
    name: Label<'a>,
    position: Axis2Placement3d<'a>,
    radius: LengthMeasure<'a>,
    semi_angle: PlaneAngleMeasure<'a>,
);
declare_entity!(ConnectedEdgeSet,
    name: Label<'a>,
    ces_edges: Vec<Edge<'a>>,
);
declare_entity!(ConnectedFaceSet,
    name: Label<'a>,
    cfs_faces: Vec<Face<'a>>,
);
declare_entity!(ConnectedFaceSubSet,
    name: Label<'a>,
    cfs_faces: Vec<Face<'a>>,
    parent_face_set: ConnectedFaceSet<'a>,
);
declare_entity!(ConstructiveGeometryRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(ConstructiveGeometryRepresentationRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    rep_1: Representation<'a>,
    rep_2: Representation<'a>,
);
declare_entity!(ContactRatioRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(ContextDependentInvisibility,
    invisible_items: Vec<InvisibleItem<'a>>,
    presentation_context: InvisibilityContext<'a>,
);
#[derive(Debug)]
pub struct ContextDependentMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ContextDependentMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(ContextDependentOverRidingStyledItem,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
    over_ridden_style: StyledItem<'a>,
    style_context: Vec<StyleContextSelect<'a>>,
);
declare_entity!(ContextDependentShapeRepresentation,
    representation_relation: ShapeRepresentationRelationship<'a>,
    represented_product_relation: ProductDefinitionShape<'a>,
);
declare_entity!(ContextDependentUnit,
    dimensions: DimensionalExponents<'a>,
    name: Label<'a>,
);
declare_entity!(Contract,
    name: Label<'a>,
    purpose: Text<'a>,
    kind: ContractType<'a>,
);
declare_entity!(ContractAssignment,
    assigned_contract: Contract<'a>,
);
#[derive(Debug)]
pub struct ContractItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ContractItem<'a> = Id<ContractItem_<'a>>;

declare_entity!(ContractType,
    description: Label<'a>,
);
declare_entity!(ConversionBasedUnit,
    dimensions: Derived,
    name: Label<'a>,
    conversion_factor: MeasureWithUnit<'a>,
);
declare_entity!(CoordinatedUniversalTimeOffset,
    hour_offset: i64,
    minute_offset: Option<i64>,
    sense: AheadOrBehind<'a>,
);
declare_entity!(CosFunction,
    operand: GenericExpression<'a>,
);
#[derive(Debug)]
pub struct CountMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CountMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct CsgPrimitive_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CsgPrimitive<'a> = Id<CsgPrimitive_<'a>>;

#[derive(Debug)]
pub struct CsgSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CsgSelect<'a> = Id<CsgSelect_<'a>>;

declare_entity!(CsgShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(CsgSolid,
    name: Label<'a>,
    tree_root_expression: CsgSelect<'a>,
);
declare_entity!(Curve,
    name: Label<'a>,
);
declare_entity!(CurveBoundedSurface,
    name: Label<'a>,
    basis_surface: Surface<'a>,
    boundaries: Vec<BoundaryCurve<'a>>,
    implicit_outer: bool,
);
declare_entity!(CurveDimension,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
#[derive(Debug)]
pub struct CurveFontOrScaledCurveFontSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveFontOrScaledCurveFontSelect<'a> = Id<CurveFontOrScaledCurveFontSelect_<'a>>;

#[derive(Debug)]
pub struct CurveOnSurface_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveOnSurface<'a> = Id<CurveOnSurface_<'a>>;

#[derive(Debug)]
pub struct CurveOrRender_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveOrRender<'a> = Id<CurveOrRender_<'a>>;

declare_entity!(CurveReplica,
    name: Label<'a>,
    parent_curve: Curve<'a>,
    transformation: CartesianTransformationOperator<'a>,
);
declare_entity!(CurveStyle,
    name: Label<'a>,
    curve_font: CurveFontOrScaledCurveFontSelect<'a>,
    curve_width: SizeSelect<'a>,
    curve_colour: Colour<'a>,
);
declare_entity!(CurveStyleFont,
    name: Label<'a>,
    pattern_list: Vec<CurveStyleFontPattern<'a>>,
);
declare_entity!(CurveStyleFontPattern,
    visible_segment_length: PositiveLengthMeasure<'a>,
    invisible_segment_length: PositiveLengthMeasure<'a>,
);
#[derive(Debug)]
pub struct CurveStyleFontSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveStyleFontSelect<'a> = Id<CurveStyleFontSelect_<'a>>;

declare_entity!(CurveStyleRendering,
    rendering_method: ShadingCurveMethod<'a>,
    rendering_properties: SurfaceRenderingProperties<'a>,
);
declare_entity!(CurveSweptSolidShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);

#[derive(Debug)]
pub struct CurveToleranceDeviation<'a>(pub PositiveLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for CurveToleranceDeviation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveLengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct CurveToleranceParameter<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CurveToleranceParameter<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(CylindricalPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
);
declare_entity!(CylindricalPairRange,
    applies_to_pair: KinematicPair<'a>,
    lower_limit_actual_translation: TranslationalRangeMeasure<'a>,
    upper_limit_actual_translation: TranslationalRangeMeasure<'a>,
    lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
);
declare_entity!(CylindricalPairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_translation: LengthMeasure<'a>,
    actual_rotation: PlaneAngleMeasure<'a>,
);
declare_entity!(CylindricalSurface,
    name: Label<'a>,
    position: Axis2Placement3d<'a>,
    radius: PositiveLengthMeasure<'a>,
);
declare_entity!(CylindricityTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(DataEnvironment,
    name: Label<'a>,
    description: Text<'a>,
    elements: Vec<PropertyDefinitionRepresentation<'a>>,
);
declare_entity!(Date,
    year_component: YearNumber<'a>,
);
declare_entity!(DateAndTime,
    date_component: Date<'a>,
    time_component: LocalTime<'a>,
);
declare_entity!(DateAndTimeAssignment,
    assigned_date_and_time: DateAndTime<'a>,
    role: DateTimeRole<'a>,
);
#[derive(Debug)]
pub struct DateAndTimeItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateAndTimeItem<'a> = Id<DateAndTimeItem_<'a>>;

declare_entity!(DateAssignment,
    assigned_date: Date<'a>,
    role: DateRole<'a>,
);
#[derive(Debug)]
pub struct DateItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateItem<'a> = Id<DateItem_<'a>>;

declare_entity!(DateRole,
    name: Label<'a>,
);
#[derive(Debug)]
pub struct DateTimeOrEventOccurrence_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateTimeOrEventOccurrence<'a> = Id<DateTimeOrEventOccurrence_<'a>>;

declare_entity!(DateTimeRole,
    name: Label<'a>,
);
#[derive(Debug)]
pub struct DateTimeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateTimeSelect<'a> = Id<DateTimeSelect_<'a>>;

declare_entity!(DatedEffectivity,
    id: Identifier<'a>,
    effectivity_end_date: Option<DateTimeOrEventOccurrence<'a>>,
    effectivity_start_date: DateTimeOrEventOccurrence<'a>,
);
declare_entity!(Datum,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
    identification: Identifier<'a>,
);
declare_entity!(DatumFeature,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(DatumFeatureCallout,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(DatumReference,
    precedence: i64,
    referenced_datum: Datum<'a>,
);
declare_entity!(DatumTarget,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
    target_id: Identifier<'a>,
);
declare_entity!(DatumTargetCallout,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
#[derive(Debug)]
pub struct DayInMonthNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DayInMonthNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(DefaultToleranceTable,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(DefaultToleranceTableCell,
    name: Label<'a>,
    item_element: CompoundItemDefinition<'a>,
);
declare_entity!(DefinedCharacterGlyph,
    name: Label<'a>,
    definition: DefinedGlyphSelect<'a>,
    placement: Axis2Placement<'a>,
);
declare_entity!(DefinedFunction,
);
#[derive(Debug)]
pub struct DefinedGlyphSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DefinedGlyphSelect<'a> = Id<DefinedGlyphSelect_<'a>>;

declare_entity!(DefinedSymbol,
    name: Label<'a>,
    definition: DefinedSymbolSelect<'a>,
    target: SymbolTarget<'a>,
);
#[derive(Debug)]
pub struct DefinedSymbolSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DefinedSymbolSelect<'a> = Id<DefinedSymbolSelect_<'a>>;

declare_entity!(DefinitionalRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(DegeneratePcurve,
    name: Label<'a>,
    basis_surface: Surface<'a>,
    reference_to_curve: DefinitionalRepresentation<'a>,
);
declare_entity!(DegenerateToroidalSurface,
    name: Label<'a>,
    position: Axis2Placement3d<'a>,
    major_radius: PositiveLengthMeasure<'a>,
    minor_radius: PositiveLengthMeasure<'a>,
    select_outer: bool,
);
#[derive(Debug)]
pub struct DerivedPropertySelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DerivedPropertySelect<'a> = Id<DerivedPropertySelect_<'a>>;

declare_entity!(DerivedShapeAspect,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(DerivedUnit,
    elements: Vec<DerivedUnitElement<'a>>,
);
declare_entity!(DerivedUnitElement,
    unit: NamedUnit<'a>,
    exponent: f64,
);
declare_entity!(DerivedUnitVariable,
    elements: Vec<DerivedUnitElement<'a>>,
);
declare_entity!(DescriptionAttribute,
    attribute_value: Text<'a>,
    described_item: DescriptionAttributeSelect<'a>,
);
#[derive(Debug)]
pub struct DescriptionAttributeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DescriptionAttributeSelect<'a> = Id<DescriptionAttributeSelect_<'a>>;

#[derive(Debug)]
pub struct DescriptiveMeasure<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DescriptiveMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(DescriptiveRepresentationItem,
    name: Label<'a>,
    description: Text<'a>,
);
declare_entity!(DiameterDimension,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(DimensionCallout,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(DimensionCalloutComponentRelationship,
    name: Label<'a>,
    description: Text<'a>,
    relating_draughting_callout: DraughtingCallout<'a>,
    related_draughting_callout: DraughtingCallout<'a>,
);
declare_entity!(DimensionCalloutRelationship,
    name: Label<'a>,
    description: Text<'a>,
    relating_draughting_callout: DraughtingCallout<'a>,
    related_draughting_callout: DraughtingCallout<'a>,
);
#[derive(Debug)]
pub struct DimensionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DimensionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(DimensionCurve,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
);
declare_entity!(DimensionCurveDirectedCallout,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(DimensionCurveTerminator,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
    annotated_curve: AnnotationCurveOccurrence<'a>,
    role: DimensionExtentUsage<'a>,
);
#[derive(Debug)]
pub enum DimensionExtentUsage<'a> { // enum
    Origin,
    Target,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for DimensionExtentUsage<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use DimensionExtentUsage::*;
        alt((
            map(tag(".ORIGIN."), |_| Origin),
            map(tag(".TARGET."), |_| Target),
        ))(s)
    }
}
declare_entity!(DimensionPair,
    name: Label<'a>,
    description: Text<'a>,
    relating_draughting_callout: DraughtingCallout<'a>,
    related_draughting_callout: DraughtingCallout<'a>,
);
declare_entity!(DimensionRelatedToleranceZoneElement,
    related_dimension: DimensionalLocation<'a>,
    related_element: ToleranceZoneDefinition<'a>,
);
declare_entity!(DimensionTextAssociativity,
    representation_item__name: Label<'a>,
    literal: PresentableText<'a>,
    placement: Axis2Placement<'a>,
    alignment: TextAlignment<'a>,
    path: TextPath<'a>,
    font: FontSelect<'a>,
    mapping_source: RepresentationMap<'a>,
    mapping_target: RepresentationItem<'a>,
);
#[derive(Debug)]
pub struct DimensionalCharacteristic_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DimensionalCharacteristic<'a> = Id<DimensionalCharacteristic_<'a>>;

declare_entity!(DimensionalCharacteristicRepresentation,
    dimension: DimensionalCharacteristic<'a>,
    representation: ShapeDimensionRepresentation<'a>,
);
declare_entity!(DimensionalExponents,
    length_exponent: f64,
    mass_exponent: f64,
    time_exponent: f64,
    electric_current_exponent: f64,
    thermodynamic_temperature_exponent: f64,
    amount_of_substance_exponent: f64,
    luminous_intensity_exponent: f64,
);
declare_entity!(DimensionalLocation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(DimensionalLocationWithPath,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
    path: ShapeAspect<'a>,
);
declare_entity!(DimensionalSize,
    applies_to: ShapeAspect<'a>,
    name: Label<'a>,
);
declare_entity!(DimensionalSizeWithPath,
    applies_to: ShapeAspect<'a>,
    name: Label<'a>,
    path: ShapeAspect<'a>,
);
declare_entity!(DirectedAction,
    name: Label<'a>,
    description: Option<Text<'a>>,
    chosen_method: ActionMethod<'a>,
    directive: ActionDirective<'a>,
);
declare_entity!(DirectedAngle,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(DirectedDimensionalLocation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(Direction,
    name: Label<'a>,
    direction_ratios: Vec<f64>,
);
#[derive(Debug)]
pub enum DirectionCountSelect<'a> { // select
    UDirectionCount(UDirectionCount<'a>),
    VDirectionCount(VDirectionCount<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DirectionCountSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("U_DIRECTION_COUNT("), <UDirectionCount<'a>>::parse, char(')')), |r| DirectionCountSelect::UDirectionCount(r)),
            map(delimited(tag("V_DIRECTION_COUNT("), <VDirectionCount<'a>>::parse, char(')')), |r| DirectionCountSelect::VDirectionCount(r)),
        ))(s)
    }
}
declare_entity!(DirectionShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(DivExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(Document,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    kind: DocumentType<'a>,
);
declare_entity!(DocumentFile,
    id: Identifier<'a>,
    document__name: Label<'a>,
    document__description: Option<Text<'a>>,
    kind: DocumentType<'a>,
    characterized_object__name: Label<'a>,
    characterized_object__description: Option<Text<'a>>,
);
declare_entity!(DocumentProductAssociation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_document: Document<'a>,
    related_product: ProductOrFormationOrDefinition<'a>,
);
declare_entity!(DocumentProductEquivalence,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_document: Document<'a>,
    related_product: ProductOrFormationOrDefinition<'a>,
);
declare_entity!(DocumentReference,
    assigned_document: Document<'a>,
    source: Label<'a>,
);
#[derive(Debug)]
pub struct DocumentReferenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DocumentReferenceItem<'a> = Id<DocumentReferenceItem_<'a>>;

declare_entity!(DocumentRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_document: Document<'a>,
    related_document: Document<'a>,
);
declare_entity!(DocumentRepresentationType,
    name: Label<'a>,
    represented_document: Document<'a>,
);
declare_entity!(DocumentType,
    product_data_type: Label<'a>,
);
declare_entity!(DocumentUsageConstraint,
    source: Document<'a>,
    subject_element: Label<'a>,
    subject_element_value: Text<'a>,
);
declare_entity!(DocumentUsageConstraintAssignment,
    assigned_document_usage: DocumentUsageConstraint<'a>,
    role: DocumentUsageRole<'a>,
);
declare_entity!(DocumentUsageRole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(DraughtingAnnotationOccurrence,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
);
declare_entity!(DraughtingCallout,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
#[derive(Debug)]
pub struct DraughtingCalloutElement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DraughtingCalloutElement<'a> = Id<DraughtingCalloutElement_<'a>>;

declare_entity!(DraughtingCalloutRelationship,
    name: Label<'a>,
    description: Text<'a>,
    relating_draughting_callout: DraughtingCallout<'a>,
    related_draughting_callout: DraughtingCallout<'a>,
);
declare_entity!(DraughtingElements,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(DraughtingModel,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(DraughtingModelItemAssociation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    definition: RepresentedDefinition<'a>,
    used_representation: Representation<'a>,
    identified_item: RepresentationItem<'a>,
);
#[derive(Debug)]
pub struct DraughtingModelItemAssociationSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DraughtingModelItemAssociationSelect<'a> = Id<DraughtingModelItemAssociationSelect_<'a>>;

declare_entity!(DraughtingPreDefinedColour,
    name: Label<'a>,
);
declare_entity!(DraughtingPreDefinedCurveFont,
    name: Label<'a>,
);
declare_entity!(DraughtingPreDefinedTextFont,
    name: Label<'a>,
);
declare_entity!(DraughtingSpecificationReference,
    assigned_document: Document<'a>,
    source: Label<'a>,
    specified_items: Vec<SpecifiedItem<'a>>,
);
declare_entity!(DraughtingSubfigureRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(DraughtingSymbolRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(DraughtingTextLiteralWithDelineation,
    name: Label<'a>,
    literal: PresentableText<'a>,
    placement: Axis2Placement<'a>,
    alignment: TextAlignment<'a>,
    path: TextPath<'a>,
    font: FontSelect<'a>,
    delineation: TextDelineation<'a>,
);
declare_entity!(DraughtingTitle,
    items: Vec<DraughtingTitledItem<'a>>,
    language: Label<'a>,
    contents: Text<'a>,
);
#[derive(Debug)]
pub struct DraughtingTitledItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DraughtingTitledItem<'a> = Id<DraughtingTitledItem_<'a>>;

declare_entity!(DrawingDefinition,
    drawing_number: Identifier<'a>,
    drawing_type: Option<Label<'a>>,
);
declare_entity!(DrawingRevision,
    revision_identifier: Identifier<'a>,
    drawing_identifier: DrawingDefinition<'a>,
    intended_scale: Option<Text<'a>>,
);
declare_entity!(DrawingRevisionSequence,
    predecessor: DrawingRevision<'a>,
    successor: DrawingRevision<'a>,
);
declare_entity!(DrawingSheetLayout,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(DrawingSheetRevision,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
    revision_identifier: Identifier<'a>,
);
declare_entity!(DrawingSheetRevisionUsage,
    area: PresentationArea<'a>,
    in_set: PresentationSet<'a>,
    sheet_number: Identifier<'a>,
);
declare_entity!(Edge,
    name: Label<'a>,
    edge_start: Vertex<'a>,
    edge_end: Vertex<'a>,
);
declare_entity!(EdgeBasedWireframeModel,
    name: Label<'a>,
    ebwm_boundary: Vec<ConnectedEdgeSet<'a>>,
);
declare_entity!(EdgeBasedWireframeShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(EdgeCurve,
    representation_item__name: Label<'a>,
    edge_start: Vertex<'a>,
    edge_end: Vertex<'a>,
    edge_geometry: Curve<'a>,
    same_sense: bool,
);
declare_entity!(EdgeLoop,
    representation_item__name: Label<'a>,
    edge_list: Vec<OrientedEdge<'a>>,
);
declare_entity!(EdgeRound,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(Effectivity,
    id: Identifier<'a>,
);
declare_entity!(EffectivityAssignment,
    assigned_effectivity: Effectivity<'a>,
);
declare_entity!(EffectivityContextAssignment,
    assigned_effectivity_assignment: EffectivityAssignment<'a>,
    role: EffectivityContextRole<'a>,
);
declare_entity!(EffectivityContextRole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
#[derive(Debug)]
pub struct EffectivityItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type EffectivityItem<'a> = Id<EffectivityItem_<'a>>;

declare_entity!(EffectivityRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    related_effectivity: Effectivity<'a>,
    relating_effectivity: Effectivity<'a>,
);
#[derive(Debug)]
pub struct ElectricCurrentMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ElectricCurrentMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(ElectricCurrentMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(ElectricCurrentUnit,
    dimensions: DimensionalExponents<'a>,
);
declare_entity!(ElementDelivery,
    name: Label<'a>,
    description: Option<Text<'a>>,
    chosen_method: ActionMethod<'a>,
);
declare_entity!(ElementarySurface,
    name: Label<'a>,
    position: Axis2Placement3d<'a>,
);
declare_entity!(Ellipse,
    name: Label<'a>,
    position: Axis2Placement<'a>,
    semi_axis_1: PositiveLengthMeasure<'a>,
    semi_axis_2: PositiveLengthMeasure<'a>,
);
declare_entity!(Environment,
    syntactic_representation: GenericVariable<'a>,
    semantics: VariableSemantics<'a>,
);
declare_entity!(EqualsExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(EvaluatedDegeneratePcurve,
    name: Label<'a>,
    basis_surface: Surface<'a>,
    reference_to_curve: DefinitionalRepresentation<'a>,
    equivalent_point: CartesianPoint<'a>,
);
declare_entity!(EventOccurrence,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(EventOccurrenceAssignment,
    assigned_event_occurrence: EventOccurrence<'a>,
    role: EventOccurrenceRole<'a>,
);
declare_entity!(EventOccurrenceContextAssignment,
    assigned_event_occurrence_assignment: EventOccurrenceAssignment<'a>,
    role: EventOccurrenceContextRole<'a>,
);
declare_entity!(EventOccurrenceContextRole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
#[derive(Debug)]
pub struct EventOccurrenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type EventOccurrenceItem<'a> = Id<EventOccurrenceItem_<'a>>;

declare_entity!(EventOccurrenceRole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(ExclusiveProductConceptFeatureCategory,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(ExecutedAction,
    name: Label<'a>,
    description: Option<Text<'a>>,
    chosen_method: ActionMethod<'a>,
);
declare_entity!(ExpFunction,
    operand: GenericExpression<'a>,
);
declare_entity!(Expression,
);
declare_entity!(ExpressionConversionBasedUnit,
    dimensions: DimensionalExponents<'a>,
    name: Label<'a>,
);
declare_entity!(Extension,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(ExternalIdentificationAssignment,
    assigned_id: Identifier<'a>,
    role: IdentificationRole<'a>,
    source: ExternalSource<'a>,
);
#[derive(Debug)]
pub struct ExternalIdentificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ExternalIdentificationItem<'a> = Id<ExternalIdentificationItem_<'a>>;

declare_entity!(ExternalSource,
    source_id: SourceItem<'a>,
);
declare_entity!(ExternallyDefinedCharacterGlyph,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
);
declare_entity!(ExternallyDefinedClass,
    name: Label<'a>,
    description: Option<Text<'a>>,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
);
declare_entity!(ExternallyDefinedCurveFont,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
);
declare_entity!(ExternallyDefinedDimensionDefinition,
    applies_to: ShapeAspect<'a>,
    name: Label<'a>,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
);
declare_entity!(ExternallyDefinedFeatureDefinition,
    name: Label<'a>,
    description: Option<Text<'a>>,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
);
declare_entity!(ExternallyDefinedGeneralProperty,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
);
declare_entity!(ExternallyDefinedHatchStyle,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
    name: Label<'a>,
);
declare_entity!(ExternallyDefinedItem,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
);
declare_entity!(ExternallyDefinedItemRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_item: ExternallyDefinedItem<'a>,
    related_item: ExternallyDefinedItem<'a>,
);
declare_entity!(ExternallyDefinedStyle,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
);
declare_entity!(ExternallyDefinedSymbol,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
);
declare_entity!(ExternallyDefinedTextFont,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
);
declare_entity!(ExternallyDefinedTileStyle,
    item_id: SourceItem<'a>,
    source: ExternalSource<'a>,
    name: Label<'a>,
);
declare_entity!(ExtrudedAreaSolid,
    name: Label<'a>,
    swept_area: CurveBoundedSurface<'a>,
    extruded_direction: Direction<'a>,
    depth: PositiveLengthMeasure<'a>,
);
declare_entity!(ExtrudedFaceSolid,
    name: Label<'a>,
    swept_face: FaceSurface<'a>,
    extruded_direction: Direction<'a>,
    depth: PositiveLengthMeasure<'a>,
);
declare_entity!(Face,
    name: Label<'a>,
    bounds: Vec<FaceBound<'a>>,
);
declare_entity!(FaceBasedSurfaceModel,
    name: Label<'a>,
    fbsm_faces: Vec<ConnectedFaceSet<'a>>,
);
declare_entity!(FaceBound,
    name: Label<'a>,
    bound: Loop<'a>,
    orientation: bool,
);
declare_entity!(FaceOuterBound,
    name: Label<'a>,
    bound: Loop<'a>,
    orientation: bool,
);
declare_entity!(FaceShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(FaceSurface,
    representation_item__name: Label<'a>,
    bounds: Vec<FaceBound<'a>>,
    face_geometry: Surface<'a>,
    same_sense: bool,
);
declare_entity!(FacetedBrep,
    name: Label<'a>,
    outer: ClosedShell<'a>,
);
declare_entity!(FacetedBrepShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(FeatureComponentDefinition,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(FeatureComponentRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(FeatureDefinition,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(FeatureInPanel,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(FeaturePattern,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(FeaturedShape,
    name: Label<'a>,
    description: Option<Text<'a>>,
    definition: CharacterizedDefinition<'a>,
);
declare_entity!(FillAreaStyle,
    name: Label<'a>,
    fill_styles: Vec<FillStyleSelect<'a>>,
);
declare_entity!(FillAreaStyleColour,
    name: Label<'a>,
    fill_colour: Colour<'a>,
);
declare_entity!(FillAreaStyleHatching,
    name: Label<'a>,
    hatch_line_appearance: CurveStyle<'a>,
    start_of_next_hatch_line: OneDirectionRepeatFactor<'a>,
    point_of_reference_hatch_line: CartesianPoint<'a>,
    pattern_start: CartesianPoint<'a>,
    hatch_line_angle: PlaneAngleMeasure<'a>,
);
#[derive(Debug)]
pub struct FillAreaStyleTileShapeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FillAreaStyleTileShapeSelect<'a> = Id<FillAreaStyleTileShapeSelect_<'a>>;

declare_entity!(FillAreaStyleTileSymbolWithStyle,
    name: Label<'a>,
    symbol: AnnotationSymbolOccurrence<'a>,
);
declare_entity!(FillAreaStyleTiles,
    name: Label<'a>,
    tiling_pattern: TwoDirectionRepeatFactor<'a>,
    tiles: Vec<FillAreaStyleTileShapeSelect<'a>>,
    tiling_scale: PositiveRatioMeasure<'a>,
);
#[derive(Debug)]
pub struct FillStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FillStyleSelect<'a> = Id<FillStyleSelect_<'a>>;

declare_entity!(Fillet,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(FlatnessTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
);
#[derive(Debug)]
pub struct FontSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FontSelect<'a> = Id<FontSelect_<'a>>;

declare_entity!(FormatFunction,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(FoundedItem,
);
#[derive(Debug)]
pub struct FoundedItemSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FoundedItemSelect<'a> = Id<FoundedItemSelect_<'a>>;

declare_entity!(FoundedKinematicPath,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(FullyConstrainedPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
);
declare_entity!(FunctionallyDefinedTransformation,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(GearPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    radius_first_link: LengthMeasure<'a>,
    radius_second_link: LengthMeasure<'a>,
    bevel: PlaneAngleMeasure<'a>,
    helical_angle: PlaneAngleMeasure<'a>,
    gear_ratio: f64,
);
declare_entity!(GearPairRange,
    applies_to_pair: KinematicPair<'a>,
    lower_limit_actual_rotation_1: RotationalRangeMeasure<'a>,
    upper_limit_actual_rotation_1: RotationalRangeMeasure<'a>,
);
declare_entity!(GearPairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_rotation_1: PlaneAngleMeasure<'a>,
);
declare_entity!(GeneralFeature,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(GeneralMaterialProperty,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(GeneralProperty,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(GeneralPropertyAssociation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    base_definition: GeneralProperty<'a>,
    derived_definition: DerivedPropertySelect<'a>,
);
declare_entity!(GeneralPropertyRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_property: GeneralProperty<'a>,
    related_property: GeneralProperty<'a>,
);
declare_entity!(GenericCharacterGlyphSymbol,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(GenericExpression,
);
declare_entity!(GenericLiteral,
);
declare_entity!(GenericVariable,
);
declare_entity!(GeometricAlignment,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(GeometricCurveSet,
    name: Label<'a>,
    elements: Vec<GeometricSetSelect<'a>>,
);
declare_entity!(GeometricIntersection,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(GeometricItemSpecificUsage,
    name: Label<'a>,
    description: Option<Text<'a>>,
    definition: RepresentedDefinition<'a>,
    used_representation: Representation<'a>,
    identified_item: RepresentationItem<'a>,
);
declare_entity!(GeometricRepresentationContext,
    context_identifier: Identifier<'a>,
    context_type: Text<'a>,
    coordinate_space_dimension: DimensionCount<'a>,
);
declare_entity!(GeometricRepresentationItem,
    name: Label<'a>,
);
declare_entity!(GeometricSet,
    name: Label<'a>,
    elements: Vec<GeometricSetSelect<'a>>,
);
#[derive(Debug)]
pub struct GeometricSetSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type GeometricSetSelect<'a> = Id<GeometricSetSelect_<'a>>;

declare_entity!(GeometricTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(GeometricToleranceRelationship,
    name: Label<'a>,
    description: Text<'a>,
    relating_geometric_tolerance: GeometricTolerance<'a>,
    related_geometric_tolerance: GeometricTolerance<'a>,
);
declare_entity!(GeometricToleranceWithDatumReference,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
    datum_system: Vec<DatumReference<'a>>,
);
declare_entity!(GeometricToleranceWithDefinedUnit,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
    unit_size: MeasureWithUnit<'a>,
);
declare_entity!(GeometricalToleranceCallout,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(GeometricallyBounded2dWireframeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(GeometricallyBoundedSurfaceShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(GeometricallyBoundedWireframeShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(GlobalUncertaintyAssignedContext,
    context_identifier: Identifier<'a>,
    context_type: Text<'a>,
    uncertainty: Vec<UncertaintyMeasureWithUnit<'a>>,
);
declare_entity!(GlobalUnitAssignedContext,
    context_identifier: Identifier<'a>,
    context_type: Text<'a>,
    units: Vec<Unit<'a>>,
);
declare_entity!(Group,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(GroupAssignment,
    assigned_group: Group<'a>,
);
#[derive(Debug)]
pub struct GroupItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type GroupItem<'a> = Id<GroupItem_<'a>>;

declare_entity!(GroupRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_group: Group<'a>,
    related_group: Group<'a>,
);
declare_entity!(HalfSpaceSolid,
    name: Label<'a>,
    base_surface: Surface<'a>,
    agreement_flag: bool,
);
declare_entity!(HardnessRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(HiddenElementOverRidingStyledItem,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
    over_ridden_style: StyledItem<'a>,
    style_context: Vec<StyleContextSelect<'a>>,
);
declare_entity!(HoleBottom,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(HoleInPanel,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(HomokineticPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    input_skew_angle: Option<PlaneAngleMeasure<'a>>,
);
#[derive(Debug)]
pub struct HourInDay<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for HourInDay<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(Hyperbola,
    name: Label<'a>,
    position: Axis2Placement<'a>,
    semi_axis: PositiveLengthMeasure<'a>,
    semi_imag_axis: PositiveLengthMeasure<'a>,
);
declare_entity!(IdAttribute,
    attribute_value: Identifier<'a>,
    identified_item: IdAttributeSelect<'a>,
);
#[derive(Debug)]
pub struct IdAttributeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type IdAttributeSelect<'a> = Id<IdAttributeSelect_<'a>>;

declare_entity!(IdentificationAssignment,
    assigned_id: Identifier<'a>,
    role: IdentificationRole<'a>,
);
#[derive(Debug)]
pub struct IdentificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type IdentificationItem<'a> = Id<IdentificationItem_<'a>>;

declare_entity!(IdentificationRole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
#[derive(Debug)]
pub struct Identifier<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Identifier<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(InclusionProductConceptFeature,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    condition: ConceptFeatureRelationshipWithCondition<'a>,
);
declare_entity!(IndexExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(InitialState,
    applies_to_mechanism: Mechanism<'a>,
    pair_values: Vec<PairValue<'a>>,
);
declare_entity!(InstancedFeature,
    shape_aspect__name: Label<'a>,
    shape_aspect__description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
    characterized_object__name: Label<'a>,
    characterized_object__description: Option<Text<'a>>,
);
declare_entity!(IntLiteral,
    the_value: f64,
);
declare_entity!(IntNumericVariable,
);
declare_entity!(IntValueFunction,
    operand: GenericExpression<'a>,
);
declare_entity!(IntegerDefinedFunction,
);
declare_entity!(InterpolatedConfigurationSequence,
    interpolation: Vec<ConfigurationInterpolation<'a>>,
);
#[derive(Debug)]
pub enum InterpolationType<'a> { // enum
    Undefined,
    Synchronous,
    Linear,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for InterpolationType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use InterpolationType::*;
        alt((
            map(tag(".UNDEFINED."), |_| Undefined),
            map(tag(".SYNCHRONOUS."), |_| Synchronous),
            map(tag(".LINEAR."), |_| Linear),
        ))(s)
    }
}
declare_entity!(IntersectionCurve,
    name: Label<'a>,
    curve_3d: Curve<'a>,
    associated_geometry: Vec<PcurveOrSurface<'a>>,
    master_representation: PreferredSurfaceCurveRepresentation<'a>,
);
declare_entity!(IntervalExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(Invisibility,
    invisible_items: Vec<InvisibleItem<'a>>,
);
#[derive(Debug)]
pub struct InvisibilityContext_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type InvisibilityContext<'a> = Id<InvisibilityContext_<'a>>;

#[derive(Debug)]
pub struct InvisibleItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type InvisibleItem<'a> = Id<InvisibleItem_<'a>>;

declare_entity!(ItemDefinedTransformation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
);
declare_entity!(ItemIdentifiedRepresentationUsage,
    name: Label<'a>,
    description: Option<Text<'a>>,
    definition: RepresentedDefinition<'a>,
    used_representation: Representation<'a>,
    identified_item: RepresentationItem<'a>,
);
declare_entity!(Joggle,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(JoggleTermination,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(KinematicAnalysisConsistency,
    control: KinematicControl<'a>,
    result: KinematicAnalysisResult<'a>,
);
#[derive(Debug)]
pub struct KinematicAnalysisDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type KinematicAnalysisDefinition<'a> = Id<KinematicAnalysisDefinition_<'a>>;

declare_entity!(KinematicAnalysisResult,
    analysed_mechanism: Mechanism<'a>,
    contained_kinematic_results: Vec<KinematicResult<'a>>,
);
declare_entity!(KinematicControl,
    controlled_mechanism: Mechanism<'a>,
    contained_kinematic_programs: Vec<KinematicAnalysisDefinition<'a>>,
);
#[derive(Debug)]
pub struct KinematicFrameBackground_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type KinematicFrameBackground<'a> = Id<KinematicFrameBackground_<'a>>;

declare_entity!(KinematicFrameBackgroundRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(KinematicFrameBackgroundRepresentationAssociation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    rep_1: Representation<'a>,
    rep_2: Representation<'a>,
    transformation_operator: Transformation<'a>,
);
declare_entity!(KinematicFrameBasedTransformation,
    representation_item__name: Label<'a>,
    functionally_defined_transformation__name: Label<'a>,
    description: Option<Text<'a>>,
    transformator: RigidPlacement<'a>,
);
declare_entity!(KinematicGroundRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(KinematicJoint,
    first_link: KinematicLink<'a>,
    second_link: KinematicLink<'a>,
);
declare_entity!(KinematicLink,
);
declare_entity!(KinematicLinkRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(KinematicLinkRepresentationAssociation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    rep_1: Representation<'a>,
    rep_2: Representation<'a>,
);
declare_entity!(KinematicLinkRepresentationRelation,
    topological_aspects: KinematicLink<'a>,
    geometric_aspects: KinematicLinkRepresentation<'a>,
);
declare_entity!(KinematicPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
);
declare_entity!(KinematicPath,
    name: Label<'a>,
);
declare_entity!(KinematicPropertyDefinition,
    name: Label<'a>,
    description: Option<Text<'a>>,
    definition: CharacterizedDefinition<'a>,
    ground_definition: CharacterizedDefinition<'a>,
);
declare_entity!(KinematicPropertyRepresentationRelation,
    definition: RepresentedDefinition<'a>,
    used_representation: Representation<'a>,
);
#[derive(Debug)]
pub struct KinematicResult_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type KinematicResult<'a> = Id<KinematicResult_<'a>>;

declare_entity!(KinematicStructure,
    joints: Vec<KinematicJoint<'a>>,
);
#[derive(Debug)]
pub enum KnotType<'a> { // enum
    UniformKnots,
    QuasiUniformKnots,
    PiecewiseBezierKnots,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for KnotType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use KnotType::*;
        alt((
            map(tag(".UNIFORM_KNOTS."), |_| UniformKnots),
            map(tag(".QUASI_UNIFORM_KNOTS."), |_| QuasiUniformKnots),
            map(tag(".PIECEWISE_BEZIER_KNOTS."), |_| PiecewiseBezierKnots),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
declare_entity!(KnownSource,
    source_id: SourceItem<'a>,
    name: Label<'a>,
);
#[derive(Debug)]
pub struct Label<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Label<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(Language,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(LanguageAssignment,
    assigned_class: Group<'a>,
    role: ClassificationRole<'a>,
    items: Vec<LanguageItem<'a>>,
);
#[derive(Debug)]
pub struct LanguageItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type LanguageItem<'a> = Id<LanguageItem_<'a>>;

#[derive(Debug)]
pub struct LayeredItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type LayeredItem<'a> = Id<LayeredItem_<'a>>;

declare_entity!(LeaderCurve,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
);
declare_entity!(LeaderDirectedCallout,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(LeaderDirectedDimension,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(LeaderTerminator,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
    annotated_curve: AnnotationCurveOccurrence<'a>,
);
declare_entity!(LengthFunction,
    operand: GenericExpression<'a>,
);
#[derive(Debug)]
pub struct LengthMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for LengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(LengthMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(LengthUnit,
    dimensions: DimensionalExponents<'a>,
);
declare_entity!(LightSource,
    name: Label<'a>,
    light_colour: Colour<'a>,
);
declare_entity!(LightSourceAmbient,
    name: Label<'a>,
    light_colour: Colour<'a>,
);
declare_entity!(LightSourceDirectional,
    name: Label<'a>,
    light_colour: Colour<'a>,
    orientation: Direction<'a>,
);
declare_entity!(LightSourcePositional,
    name: Label<'a>,
    light_colour: Colour<'a>,
    position: CartesianPoint<'a>,
    constant_attenuation: f64,
    distance_attenuation: f64,
);
declare_entity!(LightSourceSpot,
    name: Label<'a>,
    light_colour: Colour<'a>,
    position: CartesianPoint<'a>,
    orientation: Direction<'a>,
    concentration_exponent: f64,
    constant_attenuation: f64,
    distance_attenuation: f64,
    spread_angle: PositivePlaneAngleMeasure<'a>,
);
declare_entity!(LikeExpression,
    operands: Vec<GenericExpression<'a>>,
);
#[derive(Debug)]
pub enum LimitCondition<'a> { // enum
    MaximumMaterialCondition,
    LeastMaterialCondition,
    RegardlessOfFeatureSize,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for LimitCondition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use LimitCondition::*;
        alt((
            map(tag(".MAXIMUM_MATERIAL_CONDITION."), |_| MaximumMaterialCondition),
            map(tag(".LEAST_MATERIAL_CONDITION."), |_| LeastMaterialCondition),
            map(tag(".REGARDLESS_OF_FEATURE_SIZE."), |_| RegardlessOfFeatureSize),
        ))(s)
    }
}
declare_entity!(LimitsAndFits,
    form_variance: Label<'a>,
    zone_variance: Label<'a>,
    grade: Label<'a>,
    source: Text<'a>,
);
declare_entity!(Line,
    name: Label<'a>,
    pnt: CartesianPoint<'a>,
    dir: Vector<'a>,
);
declare_entity!(LineProfileTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(LinearDimension,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
#[derive(Debug)]
pub struct ListOfReversibleTopologyItem<'a>(pub Vec<ReversibleTopologyItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for ListOfReversibleTopologyItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<ReversibleTopologyItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct ListRepresentationItem<'a>(pub Vec<RepresentationItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for ListRepresentationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<RepresentationItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(LiteralNumber,
    the_value: f64,
);
declare_entity!(LocalTime,
    hour_component: HourInDay<'a>,
    minute_component: Option<MinuteInHour<'a>>,
    second_component: Option<SecondInMinute<'a>>,
    zone: CoordinatedUniversalTimeOffset<'a>,
);
declare_entity!(LocationShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(Locator,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(Log10Function,
    operand: GenericExpression<'a>,
);
declare_entity!(Log2Function,
    operand: GenericExpression<'a>,
);
declare_entity!(LogFunction,
    operand: GenericExpression<'a>,
);
declare_entity!(Loop,
    name: Label<'a>,
);
declare_entity!(LotEffectivity,
    id: Identifier<'a>,
    effectivity_lot_id: Identifier<'a>,
    effectivity_lot_size: MeasureWithUnit<'a>,
);
#[derive(Debug)]
pub struct LuminousIntensityMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for LuminousIntensityMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(LuminousIntensityMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(LuminousIntensityUnit,
    dimensions: DimensionalExponents<'a>,
);
declare_entity!(MakeFromUsageOption,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_definition: ProductDefinition<'a>,
    related_product_definition: ProductDefinition<'a>,
    ranking: i64,
    ranking_rationale: Text<'a>,
    quantity: MeasureWithUnit<'a>,
);
declare_entity!(ManifoldSolidBrep,
    name: Label<'a>,
    outer: ClosedShell<'a>,
);
declare_entity!(ManifoldSubsurfaceShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(ManifoldSurfaceShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(MappedItem,
    name: Label<'a>,
    mapping_source: RepresentationMap<'a>,
    mapping_target: RepresentationItem<'a>,
);
#[derive(Debug)]
pub enum MarkerSelect<'a> { // select
    MarkerType(MarkerType<'a>),
    PreDefinedMarker(PreDefinedMarker<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MarkerSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("MARKER_TYPE("), <MarkerType<'a>>::parse, char(')')), |r| MarkerSelect::MarkerType(r)),
            map(<PreDefinedMarker<'a>>::parse, |r| MarkerSelect::PreDefinedMarker(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub enum MarkerType<'a> { // enum
    Dot,
    X,
    Plus,
    Asterisk,
    Ring,
    Square,
    Triangle,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for MarkerType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use MarkerType::*;
        alt((
            map(tag(".DOT."), |_| Dot),
            map(tag(".X."), |_| X),
            map(tag(".PLUS."), |_| Plus),
            map(tag(".ASTERISK."), |_| Asterisk),
            map(tag(".RING."), |_| Ring),
            map(tag(".SQUARE."), |_| Square),
            map(tag(".TRIANGLE."), |_| Triangle),
        ))(s)
    }
}
#[derive(Debug)]
pub struct MassMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MassMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(MassMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(MassUnit,
    dimensions: DimensionalExponents<'a>,
);
declare_entity!(MaterialDesignation,
    name: Label<'a>,
    definitions: Vec<CharacterizedDefinition<'a>>,
);
declare_entity!(MaterialDesignationCharacterization,
    name: Label<'a>,
    description: Text<'a>,
    designation: MaterialDesignation<'a>,
    property: CharacterizedMaterialProperty<'a>,
);
declare_entity!(MaterialProperty,
    name: Label<'a>,
    description: Option<Text<'a>>,
    definition: CharacterizedDefinition<'a>,
);
declare_entity!(MaterialPropertyRepresentation,
    definition: RepresentedDefinition<'a>,
    used_representation: Representation<'a>,
    dependent_environment: DataEnvironment<'a>,
);
declare_entity!(MaximumFunction,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(MeasureQualification,
    name: Label<'a>,
    description: Text<'a>,
    qualified_measure: MeasureWithUnit<'a>,
    qualifiers: Vec<ValueQualifier<'a>>,
);
declare_entity!(MeasureRepresentationItem,
    name: Label<'a>,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
#[derive(Debug)]
pub enum MeasureValue<'a> { // select
    AmountOfSubstanceMeasure(AmountOfSubstanceMeasure<'a>),
    AreaMeasure(AreaMeasure<'a>),
    CelsiusTemperatureMeasure(CelsiusTemperatureMeasure<'a>),
    ContextDependentMeasure(ContextDependentMeasure<'a>),
    CountMeasure(CountMeasure<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    ElectricCurrentMeasure(ElectricCurrentMeasure<'a>),
    LengthMeasure(LengthMeasure<'a>),
    LuminousIntensityMeasure(LuminousIntensityMeasure<'a>),
    MassMeasure(MassMeasure<'a>),
    NumericMeasure(NumericMeasure<'a>),
    NonNegativeLengthMeasure(NonNegativeLengthMeasure<'a>),
    ParameterValue(ParameterValue<'a>),
    PlaneAngleMeasure(PlaneAngleMeasure<'a>),
    PositiveLengthMeasure(PositiveLengthMeasure<'a>),
    PositivePlaneAngleMeasure(PositivePlaneAngleMeasure<'a>),
    PositiveRatioMeasure(PositiveRatioMeasure<'a>),
    RatioMeasure(RatioMeasure<'a>),
    SolidAngleMeasure(SolidAngleMeasure<'a>),
    ThermodynamicTemperatureMeasure(ThermodynamicTemperatureMeasure<'a>),
    TimeMeasure(TimeMeasure<'a>),
    VolumeMeasure(VolumeMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MeasureValue<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("AMOUNT_OF_SUBSTANCE_MEASURE("), <AmountOfSubstanceMeasure<'a>>::parse, char(')')), |r| MeasureValue::AmountOfSubstanceMeasure(r)),
            map(delimited(tag("AREA_MEASURE("), <AreaMeasure<'a>>::parse, char(')')), |r| MeasureValue::AreaMeasure(r)),
            map(delimited(tag("CELSIUS_TEMPERATURE_MEASURE("), <CelsiusTemperatureMeasure<'a>>::parse, char(')')), |r| MeasureValue::CelsiusTemperatureMeasure(r)),
            map(delimited(tag("CONTEXT_DEPENDENT_MEASURE("), <ContextDependentMeasure<'a>>::parse, char(')')), |r| MeasureValue::ContextDependentMeasure(r)),
            map(delimited(tag("COUNT_MEASURE("), <CountMeasure<'a>>::parse, char(')')), |r| MeasureValue::CountMeasure(r)),
            map(delimited(tag("DESCRIPTIVE_MEASURE("), <DescriptiveMeasure<'a>>::parse, char(')')), |r| MeasureValue::DescriptiveMeasure(r)),
            map(delimited(tag("ELECTRIC_CURRENT_MEASURE("), <ElectricCurrentMeasure<'a>>::parse, char(')')), |r| MeasureValue::ElectricCurrentMeasure(r)),
            map(delimited(tag("LENGTH_MEASURE("), <LengthMeasure<'a>>::parse, char(')')), |r| MeasureValue::LengthMeasure(r)),
            map(delimited(tag("LUMINOUS_INTENSITY_MEASURE("), <LuminousIntensityMeasure<'a>>::parse, char(')')), |r| MeasureValue::LuminousIntensityMeasure(r)),
            map(delimited(tag("MASS_MEASURE("), <MassMeasure<'a>>::parse, char(')')), |r| MeasureValue::MassMeasure(r)),
            map(delimited(tag("NUMERIC_MEASURE("), <NumericMeasure<'a>>::parse, char(')')), |r| MeasureValue::NumericMeasure(r)),
            map(delimited(tag("NON_NEGATIVE_LENGTH_MEASURE("), <NonNegativeLengthMeasure<'a>>::parse, char(')')), |r| MeasureValue::NonNegativeLengthMeasure(r)),
            map(delimited(tag("PARAMETER_VALUE("), <ParameterValue<'a>>::parse, char(')')), |r| MeasureValue::ParameterValue(r)),
            map(delimited(tag("PLANE_ANGLE_MEASURE("), <PlaneAngleMeasure<'a>>::parse, char(')')), |r| MeasureValue::PlaneAngleMeasure(r)),
            map(delimited(tag("POSITIVE_LENGTH_MEASURE("), <PositiveLengthMeasure<'a>>::parse, char(')')), |r| MeasureValue::PositiveLengthMeasure(r)),
            map(delimited(tag("POSITIVE_PLANE_ANGLE_MEASURE("), <PositivePlaneAngleMeasure<'a>>::parse, char(')')), |r| MeasureValue::PositivePlaneAngleMeasure(r)),
            map(delimited(tag("POSITIVE_RATIO_MEASURE("), <PositiveRatioMeasure<'a>>::parse, char(')')), |r| MeasureValue::PositiveRatioMeasure(r)),
            map(delimited(tag("RATIO_MEASURE("), <RatioMeasure<'a>>::parse, char(')')), |r| MeasureValue::RatioMeasure(r)),
            map(delimited(tag("SOLID_ANGLE_MEASURE("), <SolidAngleMeasure<'a>>::parse, char(')')), |r| MeasureValue::SolidAngleMeasure(r)),
        alt((
            map(delimited(tag("THERMODYNAMIC_TEMPERATURE_MEASURE("), <ThermodynamicTemperatureMeasure<'a>>::parse, char(')')), |r| MeasureValue::ThermodynamicTemperatureMeasure(r)),
            map(delimited(tag("TIME_MEASURE("), <TimeMeasure<'a>>::parse, char(')')), |r| MeasureValue::TimeMeasure(r)),
            map(delimited(tag("VOLUME_MEASURE("), <VolumeMeasure<'a>>::parse, char(')')), |r| MeasureValue::VolumeMeasure(r)),
        ))))(s)
    }
}
declare_entity!(MeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(MechanicalDesignGeometricPresentationArea,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(MechanicalDesignGeometricPresentationRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(Mechanism,
    structure_definition: KinematicStructure<'a>,
    base: KinematicLink<'a>,
    containing_property: KinematicPropertyDefinition<'a>,
);
declare_entity!(MechanismBasePlacement,
    name: Label<'a>,
    description: Option<Text<'a>>,
    rep_1: Representation<'a>,
    rep_2: Derived,
    transformation_operator: Transformation<'a>,
    base_of_mechanism: Mechanism<'a>,
);
declare_entity!(MinimumFunction,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(MinusExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(MinusFunction,
    operand: GenericExpression<'a>,
);
#[derive(Debug)]
pub struct MinuteInHour<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MinuteInHour<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(ModExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(ModifiedGeometricTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
    modifier: LimitCondition<'a>,
);
declare_entity!(ModifiedPattern,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(MomentsOfInertiaRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
#[derive(Debug)]
pub struct MonthInYearNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MonthInYearNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(MotionLinkRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    rep_1: Representation<'a>,
    rep_2: Representation<'a>,
    related_frame: RigidPlacement<'a>,
);
#[derive(Debug)]
pub enum MotionParameterMeasure<'a> { // select
    ParameterValue(ParameterValue<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MotionParameterMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("PARAMETER_VALUE("), <ParameterValue<'a>>::parse, char(')')), |r| MotionParameterMeasure::ParameterValue(r)),
            map(<MeasureWithUnit<'a>>::parse, |r| MotionParameterMeasure::MeasureWithUnit(r)),
        ))(s)
    }
}
declare_entity!(MultExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(MultiLanguageAttributeAssignment,
    attribute_name: Label<'a>,
    attribute_value: AttributeType<'a>,
    role: AttributeValueRole<'a>,
    items: Vec<MultiLanguageAttributeItem<'a>>,
);
#[derive(Debug)]
pub struct MultiLanguageAttributeItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type MultiLanguageAttributeItem<'a> = Id<MultiLanguageAttributeItem_<'a>>;

declare_entity!(MultipleArityBooleanExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(MultipleArityFunctionCall,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(MultipleArityGenericExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(MultipleArityNumericExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(NameAssignment,
    assigned_name: Label<'a>,
);
declare_entity!(NameAttribute,
    attribute_value: Label<'a>,
    named_item: NameAttributeSelect<'a>,
);
#[derive(Debug)]
pub struct NameAttributeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type NameAttributeSelect<'a> = Id<NameAttributeSelect_<'a>>;

#[derive(Debug)]
pub struct NameItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type NameItem<'a> = Id<NameItem_<'a>>;

declare_entity!(NamedUnit,
    dimensions: DimensionalExponents<'a>,
);
declare_entity!(NamedUnitVariable,
    dimensions: DimensionalExponents<'a>,
);
declare_entity!(NextAssemblyUsageOccurrence,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_definition: ProductDefinition<'a>,
    related_product_definition: ProductDefinition<'a>,
    reference_designator: Option<Identifier<'a>>,
);
declare_entity!(NgonClosedProfile,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(NonManifoldSurfaceShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);

#[derive(Debug)]
pub struct NonNegativeLengthMeasure<'a>(pub LengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for NonNegativeLengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(LengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(NotExpression,
    operand: GenericExpression<'a>,
);
#[derive(Debug)]
pub enum NullStyle<'a> { // enum
    Null,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for NullStyle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use NullStyle::*;
        map(tag(".NULL."), |_| Null)(s)
    }
}
declare_entity!(NumericDefinedFunction,
);
declare_entity!(NumericExpression,
);
#[derive(Debug)]
pub struct NumericMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for NumericMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(NumericVariable,
);
declare_entity!(ObjectRole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(OddFunction,
    operand: GenericExpression<'a>,
);
declare_entity!(OffsetCurve2d,
    name: Label<'a>,
    basis_curve: Curve<'a>,
    distance: LengthMeasure<'a>,
    self_intersect: Logical,
);
declare_entity!(OffsetCurve3d,
    name: Label<'a>,
    basis_curve: Curve<'a>,
    distance: LengthMeasure<'a>,
    self_intersect: Logical,
    ref_direction: Direction<'a>,
);
declare_entity!(OffsetSurface,
    name: Label<'a>,
    basis_surface: Surface<'a>,
    distance: LengthMeasure<'a>,
    self_intersect: Logical,
);
declare_entity!(OneDirectionRepeatFactor,
    name: Label<'a>,
    repeat_factor: Vector<'a>,
);
declare_entity!(OpenPathProfile,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(OpenShell,
    name: Label<'a>,
    cfs_faces: Vec<Face<'a>>,
);
declare_entity!(OrExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(OrdinateDimension,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(Organization,
    id: Option<Identifier<'a>>,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(OrganizationAssignment,
    assigned_organization: Organization<'a>,
    role: OrganizationRole<'a>,
);
#[derive(Debug)]
pub struct OrganizationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type OrganizationItem<'a> = Id<OrganizationItem_<'a>>;

declare_entity!(OrganizationRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_organization: Organization<'a>,
    related_organization: Organization<'a>,
);
declare_entity!(OrganizationRole,
    name: Label<'a>,
);
declare_entity!(OrganizationalAddress,
    internal_location: Option<Label<'a>>,
    street_number: Option<Label<'a>>,
    street: Option<Label<'a>>,
    postal_box: Option<Label<'a>>,
    town: Option<Label<'a>>,
    region: Option<Label<'a>>,
    postal_code: Option<Label<'a>>,
    country: Option<Label<'a>>,
    facsimile_number: Option<Label<'a>>,
    telephone_number: Option<Label<'a>>,
    electronic_mail_address: Option<Label<'a>>,
    telex_number: Option<Label<'a>>,
    organizations: Vec<Organization<'a>>,
    description: Option<Text<'a>>,
);
declare_entity!(OrganizationalProject,
    name: Label<'a>,
    description: Option<Text<'a>>,
    responsible_organizations: Vec<Organization<'a>>,
);
declare_entity!(OrganizationalProjectAssignment,
    assigned_organizational_project: OrganizationalProject<'a>,
    role: OrganizationalProjectRole<'a>,
);
#[derive(Debug)]
pub struct OrganizationalProjectItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type OrganizationalProjectItem<'a> = Id<OrganizationalProjectItem_<'a>>;

declare_entity!(OrganizationalProjectRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_organizational_project: OrganizationalProject<'a>,
    related_organizational_project: OrganizationalProject<'a>,
);
declare_entity!(OrganizationalProjectRole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(OrientedClosedShell,
    name: Label<'a>,
    cfs_faces: Derived,
    closed_shell_element: ClosedShell<'a>,
    orientation: bool,
);
declare_entity!(OrientedEdge,
    name: Label<'a>,
    edge_start: Derived,
    edge_end: Derived,
    edge_element: Edge<'a>,
    orientation: bool,
);
declare_entity!(OrientedFace,
    name: Label<'a>,
    bounds: Derived,
    face_element: Face<'a>,
    orientation: bool,
);
declare_entity!(OrientedOpenShell,
    name: Label<'a>,
    cfs_faces: Derived,
    open_shell_element: OpenShell<'a>,
    orientation: bool,
);
declare_entity!(OrientedPath,
    name: Label<'a>,
    edge_list: Derived,
    path_element: Path<'a>,
    orientation: bool,
);
declare_entity!(OrientedSurface,
    name: Label<'a>,
    orientation: bool,
);
declare_entity!(OuterBoundaryCurve,
    name: Label<'a>,
    segments: Vec<CompositeCurveSegment<'a>>,
    self_intersect: Logical,
);
declare_entity!(OverRidingStyledItem,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
    over_ridden_style: StyledItem<'a>,
);
declare_entity!(PackageProductConceptFeature,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(PairActuator,
    actuated_pair: KinematicPair<'a>,
    name: Label<'a>,
);
declare_entity!(PairValue,
    applies_to_pair: KinematicPair<'a>,
);
declare_entity!(Parabola,
    name: Label<'a>,
    position: Axis2Placement<'a>,
    focal_dist: LengthMeasure<'a>,
);
declare_entity!(ParallelOffset,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
    offset: MeasureWithUnit<'a>,
);
declare_entity!(ParallelismTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
    datum_system: Vec<DatumReference<'a>>,
);
#[derive(Debug)]
pub struct ParameterValue<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ParameterValue<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(ParametricRepresentationContext,
    context_identifier: Identifier<'a>,
    context_type: Text<'a>,
);
declare_entity!(PartialCircularProfile,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(Path,
    name: Label<'a>,
    edge_list: Vec<OrientedEdge<'a>>,
);
declare_entity!(PathFeatureComponent,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(PathShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(PatternOffsetMembership,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(PatternOmitMembership,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(Pcurve,
    name: Label<'a>,
    basis_surface: Surface<'a>,
    reference_to_curve: DefinitionalRepresentation<'a>,
);
#[derive(Debug)]
pub struct PcurveOrSurface_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PcurveOrSurface<'a> = Id<PcurveOrSurface_<'a>>;

declare_entity!(PerpendicularTo,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(PerpendicularityTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
    datum_system: Vec<DatumReference<'a>>,
);
declare_entity!(Person,
    id: Identifier<'a>,
    last_name: Option<Label<'a>>,
    first_name: Option<Label<'a>>,
    middle_names: Option<Vec<Label<'a>>>,
    prefix_titles: Option<Vec<Label<'a>>>,
    suffix_titles: Option<Vec<Label<'a>>>,
);
declare_entity!(PersonAndOrganization,
    the_person: Person<'a>,
    the_organization: Organization<'a>,
);
declare_entity!(PersonAndOrganizationAddress,
    address__internal_location: Option<Label<'a>>,
    address__street_number: Option<Label<'a>>,
    address__street: Option<Label<'a>>,
    address__postal_box: Option<Label<'a>>,
    address__town: Option<Label<'a>>,
    address__region: Option<Label<'a>>,
    address__postal_code: Option<Label<'a>>,
    address__country: Option<Label<'a>>,
    address__facsimile_number: Option<Label<'a>>,
    address__telephone_number: Option<Label<'a>>,
    address__electronic_mail_address: Option<Label<'a>>,
    address__telex_number: Option<Label<'a>>,
    organizations: Vec<Organization<'a>>,
    organizational_address__description: Option<Text<'a>>,
    people: Vec<Person<'a>>,
    personal_address__description: Option<Text<'a>>,
);
declare_entity!(PersonAndOrganizationAssignment,
    assigned_person_and_organization: PersonAndOrganization<'a>,
    role: PersonAndOrganizationRole<'a>,
);
#[derive(Debug)]
pub struct PersonAndOrganizationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PersonAndOrganizationItem<'a> = Id<PersonAndOrganizationItem_<'a>>;

declare_entity!(PersonAndOrganizationRole,
    name: Label<'a>,
);
#[derive(Debug)]
pub struct PersonOrganizationSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PersonOrganizationSelect<'a> = Id<PersonOrganizationSelect_<'a>>;

declare_entity!(PersonalAddress,
    internal_location: Option<Label<'a>>,
    street_number: Option<Label<'a>>,
    street: Option<Label<'a>>,
    postal_box: Option<Label<'a>>,
    town: Option<Label<'a>>,
    region: Option<Label<'a>>,
    postal_code: Option<Label<'a>>,
    country: Option<Label<'a>>,
    facsimile_number: Option<Label<'a>>,
    telephone_number: Option<Label<'a>>,
    electronic_mail_address: Option<Label<'a>>,
    telex_number: Option<Label<'a>>,
    people: Vec<Person<'a>>,
    description: Option<Text<'a>>,
);
declare_entity!(PhysicallyModelledProductDefinition,
    id: Identifier<'a>,
    description: Option<Text<'a>>,
    formation: ProductDefinitionFormation<'a>,
    frame_of_reference: ProductDefinitionContext<'a>,
    documentation_ids: Vec<Document<'a>>,
);
declare_entity!(PlacedDatumTargetFeature,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
    target_id: Identifier<'a>,
);
declare_entity!(PlacedFeature,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(Placement,
    name: Label<'a>,
    location: CartesianPoint<'a>,
);
declare_entity!(PlanarBox,
    name: Label<'a>,
    size_in_x: LengthMeasure<'a>,
    size_in_y: LengthMeasure<'a>,
    placement: Axis2Placement<'a>,
);
declare_entity!(PlanarCurvePair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    curve_1: Curve<'a>,
    curve_2: Curve<'a>,
    orientation: bool,
);
declare_entity!(PlanarCurvePairRange,
    applies_to_pair: KinematicPair<'a>,
    range_on_curve_1: TrimmedCurve<'a>,
    range_on_curve_2: TrimmedCurve<'a>,
);
declare_entity!(PlanarExtent,
    name: Label<'a>,
    size_in_x: LengthMeasure<'a>,
    size_in_y: LengthMeasure<'a>,
);
declare_entity!(PlanarPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
);
declare_entity!(PlanarPairRange,
    applies_to_pair: KinematicPair<'a>,
    lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    lower_limit_actual_translation_x: TranslationalRangeMeasure<'a>,
    upper_limit_actual_translation_x: TranslationalRangeMeasure<'a>,
    lower_limit_actual_translation_y: TranslationalRangeMeasure<'a>,
    upper_limit_actual_translation_y: TranslationalRangeMeasure<'a>,
);
declare_entity!(PlanarPairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_rotation: PlaneAngleMeasure<'a>,
    actual_translation_x: LengthMeasure<'a>,
    actual_translation_y: LengthMeasure<'a>,
);
declare_entity!(PlanarShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(Plane,
    name: Label<'a>,
    position: Axis2Placement3d<'a>,
);
#[derive(Debug)]
pub struct PlaneAngleMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for PlaneAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(PlaneAngleMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(PlaneAngleUnit,
    dimensions: DimensionalExponents<'a>,
);
#[derive(Debug)]
pub struct PlaneOrPlanarBox_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PlaneOrPlanarBox<'a> = Id<PlaneOrPlanarBox_<'a>>;

declare_entity!(PlusExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(PlusMinusTolerance,
    range: ToleranceMethodDefinition<'a>,
    toleranced_dimension: DimensionalCharacteristic<'a>,
);
declare_entity!(Pocket,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(PocketBottom,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(Point,
    name: Label<'a>,
);
declare_entity!(PointOnCurve,
    name: Label<'a>,
    basis_curve: Curve<'a>,
    point_parameter: ParameterValue<'a>,
);
declare_entity!(PointOnPlanarCurvePair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    pair_curve: Curve<'a>,
    orientation: bool,
);
declare_entity!(PointOnPlanarCurvePairRange,
    applies_to_pair: KinematicPair<'a>,
    range_on_pair_curve: TrimmedCurve<'a>,
    lower_limit_yaw: RotationalRangeMeasure<'a>,
    upper_limit_yaw: RotationalRangeMeasure<'a>,
    lower_limit_pitch: RotationalRangeMeasure<'a>,
    upper_limit_pitch: RotationalRangeMeasure<'a>,
    lower_limit_roll: RotationalRangeMeasure<'a>,
    upper_limit_roll: RotationalRangeMeasure<'a>,
);
declare_entity!(PointOnPlanarCurvePairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_point_on_curve: PointOnCurve<'a>,
    input_orientation: SpatialRotation<'a>,
);
declare_entity!(PointOnSurface,
    name: Label<'a>,
    basis_surface: Surface<'a>,
    point_parameter_u: ParameterValue<'a>,
    point_parameter_v: ParameterValue<'a>,
);
declare_entity!(PointOnSurfacePair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    pair_surface: Surface<'a>,
);
declare_entity!(PointOnSurfacePairRange,
    applies_to_pair: KinematicPair<'a>,
    range_on_pair_surface: RectangularTrimmedSurface<'a>,
    lower_limit_yaw: RotationalRangeMeasure<'a>,
    upper_limit_yaw: RotationalRangeMeasure<'a>,
    lower_limit_pitch: RotationalRangeMeasure<'a>,
    upper_limit_pitch: RotationalRangeMeasure<'a>,
    lower_limit_roll: RotationalRangeMeasure<'a>,
    upper_limit_roll: RotationalRangeMeasure<'a>,
);
declare_entity!(PointOnSurfacePairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_point_on_surface: PointOnSurface<'a>,
    input_orientation: SpatialRotation<'a>,
);
declare_entity!(PointPlacementShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(PointReplica,
    name: Label<'a>,
    parent_pt: Point<'a>,
    transformation: CartesianTransformationOperator<'a>,
);
declare_entity!(PointStyle,
    name: Label<'a>,
    marker: MarkerSelect<'a>,
    marker_size: SizeSelect<'a>,
    marker_colour: Colour<'a>,
);
declare_entity!(PolyLoop,
    representation_item__name: Label<'a>,
    polygon: Vec<CartesianPoint<'a>>,
);
declare_entity!(Polyline,
    name: Label<'a>,
    points: Vec<CartesianPoint<'a>>,
);
declare_entity!(PositionTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
);

#[derive(Debug)]
pub struct PositiveLengthMeasure<'a>(pub NonNegativeLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositiveLengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(NonNegativeLengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct PositivePlaneAngleMeasure<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositivePlaneAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct PositiveRatioMeasure<'a>(pub RatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositiveRatioMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(RatioMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(PowerExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(PreDefinedColour,
    name: Label<'a>,
);
declare_entity!(PreDefinedCurveFont,
    name: Label<'a>,
);
declare_entity!(PreDefinedDimensionSymbol,
    name: Label<'a>,
);
declare_entity!(PreDefinedGeometricalToleranceSymbol,
    name: Label<'a>,
);
declare_entity!(PreDefinedItem,
    name: Label<'a>,
);
declare_entity!(PreDefinedMarker,
    name: Label<'a>,
);
declare_entity!(PreDefinedPointMarkerSymbol,
    pre_defined_item__name: Label<'a>,
);
declare_entity!(PreDefinedPresentationStyle,
    name: Label<'a>,
);
declare_entity!(PreDefinedSurfaceConditionSymbol,
    name: Label<'a>,
);
declare_entity!(PreDefinedSymbol,
    name: Label<'a>,
);
declare_entity!(PreDefinedTerminatorSymbol,
    name: Label<'a>,
);
declare_entity!(PreDefinedTextFont,
    name: Label<'a>,
);
declare_entity!(PrecisionQualifier,
    precision_value: i64,
);
#[derive(Debug)]
pub enum PreferredSurfaceCurveRepresentation<'a> { // enum
    Curve3d,
    PcurveS1,
    PcurveS2,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for PreferredSurfaceCurveRepresentation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use PreferredSurfaceCurveRepresentation::*;
        alt((
            map(tag(".CURVE_3D."), |_| Curve3d),
            map(tag(".PCURVE_S1."), |_| PcurveS1),
            map(tag(".PCURVE_S2."), |_| PcurveS2),
        ))(s)
    }
}
#[derive(Debug)]
pub struct PresentableText<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for PresentableText<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(PresentationArea,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(PresentationLayerAssignment,
    name: Label<'a>,
    description: Text<'a>,
    assigned_items: Vec<LayeredItem<'a>>,
);
declare_entity!(PresentationRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
#[derive(Debug)]
pub struct PresentationRepresentationSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PresentationRepresentationSelect<'a> = Id<PresentationRepresentationSelect_<'a>>;

declare_entity!(PresentationSet,
);
declare_entity!(PresentationSize,
    unit: PresentationSizeAssignmentSelect<'a>,
    size: PlanarBox<'a>,
);
#[derive(Debug)]
pub struct PresentationSizeAssignmentSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PresentationSizeAssignmentSelect<'a> = Id<PresentationSizeAssignmentSelect_<'a>>;

declare_entity!(PresentationStyleAssignment,
    styles: Vec<PresentationStyleSelect<'a>>,
);
declare_entity!(PresentationStyleByContext,
    styles: Vec<PresentationStyleSelect<'a>>,
    style_context: StyleContextSelect<'a>,
);
#[derive(Debug)]
pub enum PresentationStyleSelect<'a> { // select
    PreDefinedPresentationStyle(PreDefinedPresentationStyle<'a>),
    PointStyle(PointStyle<'a>),
    CurveStyle(CurveStyle<'a>),
    SurfaceStyleUsage(SurfaceStyleUsage<'a>),
    SymbolStyle(SymbolStyle<'a>),
    FillAreaStyle(FillAreaStyle<'a>),
    TextStyle(TextStyle<'a>),
    ApproximationTolerance(ApproximationTolerance<'a>),
    ExternallyDefinedStyle(ExternallyDefinedStyle<'a>),
    NullStyle(NullStyle<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PresentationStyleSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PreDefinedPresentationStyle<'a>>::parse, |r| PresentationStyleSelect::PreDefinedPresentationStyle(r)),
            map(<PointStyle<'a>>::parse, |r| PresentationStyleSelect::PointStyle(r)),
            map(<CurveStyle<'a>>::parse, |r| PresentationStyleSelect::CurveStyle(r)),
            map(<SurfaceStyleUsage<'a>>::parse, |r| PresentationStyleSelect::SurfaceStyleUsage(r)),
            map(<SymbolStyle<'a>>::parse, |r| PresentationStyleSelect::SymbolStyle(r)),
            map(<FillAreaStyle<'a>>::parse, |r| PresentationStyleSelect::FillAreaStyle(r)),
            map(<TextStyle<'a>>::parse, |r| PresentationStyleSelect::TextStyle(r)),
            map(<ApproximationTolerance<'a>>::parse, |r| PresentationStyleSelect::ApproximationTolerance(r)),
            map(<ExternallyDefinedStyle<'a>>::parse, |r| PresentationStyleSelect::ExternallyDefinedStyle(r)),
            map(delimited(tag("NULL_STYLE("), <NullStyle<'a>>::parse, char(')')), |r| PresentationStyleSelect::NullStyle(r)),
        ))(s)
    }
}
declare_entity!(PresentationView,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(PresentedItem,
);
declare_entity!(PresentedItemRepresentation,
    presentation: PresentationRepresentationSelect<'a>,
    item: PresentedItem<'a>,
);
#[derive(Debug)]
pub struct PresentedItemSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PresentedItemSelect<'a> = Id<PresentedItemSelect_<'a>>;

declare_entity!(PrismaticPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
);
declare_entity!(PrismaticPairRange,
    applies_to_pair: KinematicPair<'a>,
    lower_limit_actual_translation: TranslationalRangeMeasure<'a>,
    upper_limit_actual_translation: TranslationalRangeMeasure<'a>,
);
declare_entity!(PrismaticPairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_translation: LengthMeasure<'a>,
);
declare_entity!(ProcessOperation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    consequence: Text<'a>,
    purpose: Text<'a>,
);
declare_entity!(ProcessPlan,
    name: Label<'a>,
    description: Option<Text<'a>>,
    chosen_method: ActionMethod<'a>,
);
declare_entity!(ProcessProductAssociation,
    name: Label<'a>,
    description: Text<'a>,
    defined_product: CharacterizedProductDefinition<'a>,
    process: ProductDefinitionProcess<'a>,
);
declare_entity!(ProcessPropertyAssociation,
    name: Label<'a>,
    description: Text<'a>,
    process: PropertyProcess<'a>,
    property_or_shape: PropertyOrShapeSelect<'a>,
);
declare_entity!(Product,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    frame_of_reference: Vec<ProductContext<'a>>,
);
declare_entity!(ProductCategory,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(ProductCategoryRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    category: ProductCategory<'a>,
    sub_category: ProductCategory<'a>,
);
declare_entity!(ProductClass,
    id: Identifier<'a>,
    product_concept__name: Label<'a>,
    product_concept__description: Option<Text<'a>>,
    market_context: ProductConceptContext<'a>,
    characterized_object__name: Label<'a>,
    characterized_object__description: Option<Text<'a>>,
);
declare_entity!(ProductConcept,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    market_context: ProductConceptContext<'a>,
);
declare_entity!(ProductConceptContext,
    name: Label<'a>,
    frame_of_reference: ApplicationContext<'a>,
    market_segment_type: Label<'a>,
);
declare_entity!(ProductConceptFeature,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(ProductConceptFeatureAssociation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    concept: ProductConcept<'a>,
    feature: ProductConceptFeature<'a>,
);
declare_entity!(ProductConceptFeatureCategory,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(ProductConceptFeatureCategoryUsage,
    assigned_group: Group<'a>,
    items: Vec<CategoryUsageItem<'a>>,
);
declare_entity!(ProductConceptRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_concept: ProductConcept<'a>,
    related_product_concept: ProductConcept<'a>,
);
declare_entity!(ProductContext,
    name: Label<'a>,
    frame_of_reference: ApplicationContext<'a>,
    discipline_type: Label<'a>,
);
declare_entity!(ProductDefinition,
    id: Identifier<'a>,
    description: Option<Text<'a>>,
    formation: ProductDefinitionFormation<'a>,
    frame_of_reference: ProductDefinitionContext<'a>,
);
declare_entity!(ProductDefinitionContext,
    name: Label<'a>,
    frame_of_reference: ApplicationContext<'a>,
    life_cycle_stage: Label<'a>,
);
declare_entity!(ProductDefinitionContextAssociation,
    definition: ProductDefinition<'a>,
    frame_of_reference: ProductDefinitionContext<'a>,
    role: ProductDefinitionContextRole<'a>,
);
declare_entity!(ProductDefinitionContextRole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(ProductDefinitionEffectivity,
    id: Identifier<'a>,
    usage: ProductDefinitionRelationship<'a>,
);
declare_entity!(ProductDefinitionFormation,
    id: Identifier<'a>,
    description: Option<Text<'a>>,
    of_product: Product<'a>,
);
declare_entity!(ProductDefinitionFormationRelationship,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_definition_formation: ProductDefinitionFormation<'a>,
    related_product_definition_formation: ProductDefinitionFormation<'a>,
);
declare_entity!(ProductDefinitionFormationWithSpecifiedSource,
    id: Identifier<'a>,
    description: Option<Text<'a>>,
    of_product: Product<'a>,
    make_or_buy: Source<'a>,
);
declare_entity!(ProductDefinitionOccurrenceRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    occurrence: ProductDefinition<'a>,
    occurrence_usage: AssemblyComponentUsage<'a>,
);
declare_entity!(ProductDefinitionProcess,
    name: Label<'a>,
    description: Option<Text<'a>>,
    chosen_method: ActionMethod<'a>,
    identification: Identifier<'a>,
);
declare_entity!(ProductDefinitionRelationship,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_definition: ProductDefinition<'a>,
    related_product_definition: ProductDefinition<'a>,
);
declare_entity!(ProductDefinitionResource,
    name: Label<'a>,
    action_resource__description: Option<Text<'a>>,
    usage: Vec<SupportedItem<'a>>,
    kind: ActionResourceType<'a>,
    id: Identifier<'a>,
    product_definition__description: Option<Text<'a>>,
    formation: ProductDefinitionFormation<'a>,
    frame_of_reference: ProductDefinitionContext<'a>,
);
declare_entity!(ProductDefinitionShape,
    name: Label<'a>,
    description: Option<Text<'a>>,
    definition: CharacterizedDefinition<'a>,
);
declare_entity!(ProductDefinitionSubstitute,
    description: Option<Text<'a>>,
    context_relationship: ProductDefinitionRelationship<'a>,
    substitute_definition: ProductDefinition<'a>,
);
declare_entity!(ProductDefinitionUsage,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_definition: ProductDefinition<'a>,
    related_product_definition: ProductDefinition<'a>,
);
declare_entity!(ProductDefinitionWithAssociatedDocuments,
    id: Identifier<'a>,
    description: Option<Text<'a>>,
    formation: ProductDefinitionFormation<'a>,
    frame_of_reference: ProductDefinitionContext<'a>,
    documentation_ids: Vec<Document<'a>>,
);
declare_entity!(ProductIdentification,
    id: Identifier<'a>,
    configuration_item__name: Label<'a>,
    configuration_item__description: Option<Text<'a>>,
    item_concept: ProductConcept<'a>,
    purpose: Option<Label<'a>>,
    characterized_object__name: Label<'a>,
    characterized_object__description: Option<Text<'a>>,
);
#[derive(Debug)]
pub struct ProductOrFormationOrDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ProductOrFormationOrDefinition<'a> = Id<ProductOrFormationOrDefinition_<'a>>;

#[derive(Debug)]
pub enum ProductOrPresentationSpace<'a> { // enum
    ProductShapeSpace,
    PresentationAreaSpace,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ProductOrPresentationSpace<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ProductOrPresentationSpace::*;
        alt((
            map(tag(".PRODUCT_SHAPE_SPACE."), |_| ProductShapeSpace),
            map(tag(".PRESENTATION_AREA_SPACE."), |_| PresentationAreaSpace),
        ))(s)
    }
}
declare_entity!(ProductProcessPlan,
    name: Label<'a>,
    description: Option<Text<'a>>,
    chosen_method: ActionMethod<'a>,
    identification: Identifier<'a>,
);
declare_entity!(ProductRelatedProductCategory,
    name: Label<'a>,
    description: Option<Text<'a>>,
    products: Vec<Product<'a>>,
);
declare_entity!(ProductSpecification,
    configuration_item__id: Identifier<'a>,
    configuration_item__name: Label<'a>,
    configuration_item__description: Option<Text<'a>>,
    configuration_item__item_concept: ProductConcept<'a>,
    configuration_item__purpose: Option<Label<'a>>,
    characterized_object__name: Label<'a>,
    characterized_object__description: Option<Text<'a>>,
    item_concept_feature: Vec<ProductConceptFeatureAssociation<'a>>,
);
declare_entity!(ProjectedZoneDefinition,
    zone: ToleranceZone<'a>,
    boundaries: Vec<ShapeAspect<'a>>,
    projection_end: ShapeAspect<'a>,
    projected_length: MeasureWithUnit<'a>,
);
declare_entity!(ProjectionCurve,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
);
declare_entity!(ProjectionDirectedCallout,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(PromissoryUsageOccurrence,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_definition: ProductDefinition<'a>,
    related_product_definition: ProductDefinition<'a>,
    reference_designator: Option<Identifier<'a>>,
);
declare_entity!(PropertyDefinition,
    name: Label<'a>,
    description: Option<Text<'a>>,
    definition: CharacterizedDefinition<'a>,
);
declare_entity!(PropertyDefinitionRelationship,
    name: Label<'a>,
    description: Text<'a>,
    relating_property_definition: PropertyDefinition<'a>,
    related_property_definition: PropertyDefinition<'a>,
);
declare_entity!(PropertyDefinitionRepresentation,
    definition: RepresentedDefinition<'a>,
    used_representation: Representation<'a>,
);
#[derive(Debug)]
pub struct PropertyOrShapeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PropertyOrShapeSelect<'a> = Id<PropertyOrShapeSelect_<'a>>;

declare_entity!(PropertyProcess,
    name: Label<'a>,
    description: Option<Text<'a>>,
    chosen_method: ActionMethod<'a>,
    identification: Identifier<'a>,
);
declare_entity!(QualifiedRepresentationItem,
    name: Label<'a>,
    qualifiers: Vec<ValueQualifier<'a>>,
);
declare_entity!(QualitativeUncertainty,
    measure_name: Label<'a>,
    description: Text<'a>,
    uncertainty_value: Text<'a>,
);
declare_entity!(QuantifiedAssemblyComponentUsage,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_definition: ProductDefinition<'a>,
    related_product_definition: ProductDefinition<'a>,
    reference_designator: Option<Identifier<'a>>,
    quantity: MeasureWithUnit<'a>,
);
declare_entity!(QuasiUniformCurve,
    name: Label<'a>,
    degree: i64,
    control_points_list: Vec<CartesianPoint<'a>>,
    curve_form: BSplineCurveForm<'a>,
    closed_curve: Logical,
    self_intersect: Logical,
);
declare_entity!(QuasiUniformSurface,
    name: Label<'a>,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    surface_form: BSplineSurfaceForm<'a>,
    u_closed: Logical,
    v_closed: Logical,
    self_intersect: Logical,
);
declare_entity!(RackAndPinionPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    pinion_radius: LengthMeasure<'a>,
);
declare_entity!(RackAndPinionPairRange,
    applies_to_pair: KinematicPair<'a>,
    lower_limit_rack_displacement: TranslationalRangeMeasure<'a>,
    upper_limit_rack_displacement: TranslationalRangeMeasure<'a>,
);
declare_entity!(RackAndPinionPairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_displacement: LengthMeasure<'a>,
);
declare_entity!(RadiusDimension,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
#[derive(Debug)]
pub struct RatioMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for RatioMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(RatioMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(RatioUnit,
    dimensions: DimensionalExponents<'a>,
);
declare_entity!(RationalBSplineCurve,
    name: Label<'a>,
    degree: i64,
    control_points_list: Vec<CartesianPoint<'a>>,
    curve_form: BSplineCurveForm<'a>,
    closed_curve: Logical,
    self_intersect: Logical,
    weights_data: Vec<f64>,
);
declare_entity!(RationalBSplineSurface,
    name: Label<'a>,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    surface_form: BSplineSurfaceForm<'a>,
    u_closed: Logical,
    v_closed: Logical,
    self_intersect: Logical,
    weights_data: Vec<Vec<f64>>,
);
declare_entity!(RealDefinedFunction,
);
declare_entity!(RealLiteral,
    the_value: f64,
);
declare_entity!(RealNumericVariable,
);
declare_entity!(RectangularClosedProfile,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(RectangularCompositeSurface,
    name: Label<'a>,
    segments: Vec<Vec<SurfacePatch<'a>>>,
);
declare_entity!(RectangularPattern,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(RectangularTrimmedSurface,
    name: Label<'a>,
    basis_surface: Surface<'a>,
    u1: ParameterValue<'a>,
    u2: ParameterValue<'a>,
    v1: ParameterValue<'a>,
    v2: ParameterValue<'a>,
    usense: bool,
    vsense: bool,
);
declare_entity!(ReferencedModifiedDatum,
    precedence: i64,
    referenced_datum: Datum<'a>,
    modifier: LimitCondition<'a>,
);
declare_entity!(RelativeEventOccurrence,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    base_event: EventOccurrence<'a>,
    offset: TimeMeasureWithUnit<'a>,
);
#[derive(Debug)]
pub struct RenderingPropertiesSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RenderingPropertiesSelect<'a> = Id<RenderingPropertiesSelect_<'a>>;

declare_entity!(RepItemGroup,
    group__name: Label<'a>,
    description: Option<Text<'a>>,
    representation_item__name: Label<'a>,
);
declare_entity!(ReparametrisedCompositeCurveSegment,
    transition: TransitionCode<'a>,
    same_sense: bool,
    parent_curve: Curve<'a>,
    param_length: ParameterValue<'a>,
);
declare_entity!(ReplicateFeature,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(Representation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(RepresentationContext,
    context_identifier: Identifier<'a>,
    context_type: Text<'a>,
);
declare_entity!(RepresentationItem,
    name: Label<'a>,
);
declare_entity!(RepresentationMap,
    mapping_origin: RepresentationItem<'a>,
    mapped_representation: Representation<'a>,
);
declare_entity!(RepresentationRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    rep_1: Representation<'a>,
    rep_2: Representation<'a>,
);
declare_entity!(RepresentationRelationshipWithTransformation,
    name: Label<'a>,
    description: Option<Text<'a>>,
    rep_1: Representation<'a>,
    rep_2: Representation<'a>,
    transformation_operator: Transformation<'a>,
);
#[derive(Debug)]
pub struct RepresentedDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RepresentedDefinition<'a> = Id<RepresentedDefinition_<'a>>;

declare_entity!(RequirementForActionResource,
    name: Label<'a>,
    description: Text<'a>,
    kind: ResourceRequirementType<'a>,
    operations: Vec<CharacterizedActionDefinition<'a>>,
    resources: Vec<ActionResource<'a>>,
);
declare_entity!(ResourceProperty,
    name: Label<'a>,
    description: Text<'a>,
    resource: CharacterizedResourceDefinition<'a>,
);
declare_entity!(ResourcePropertyRepresentation,
    name: Label<'a>,
    description: Text<'a>,
    property: ResourceProperty<'a>,
    representation: Representation<'a>,
);
declare_entity!(ResourceRequirementType,
    name: Label<'a>,
    description: Text<'a>,
);
declare_entity!(ResultingPath,
    name: Label<'a>,
    description: Option<Text<'a>>,
    rep_1: Representation<'a>,
    rep_2: Representation<'a>,
    related_frame: RigidPlacement<'a>,
    controlling_joints: Vec<KinematicJoint<'a>>,
);
declare_entity!(Retention,
    name: Label<'a>,
    description: Option<Text<'a>>,
    chosen_method: ActionMethod<'a>,
);
#[derive(Debug)]
pub enum ReversibleTopology<'a> { // select
    ReversibleTopologyItem(ReversibleTopologyItem<'a>),
    ListOfReversibleTopologyItem(Vec<ReversibleTopologyItem<'a>>),
    SetOfReversibleTopologyItem(Vec<ReversibleTopologyItem<'a>>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ReversibleTopology<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ReversibleTopologyItem<'a>>::parse, |r| ReversibleTopology::ReversibleTopologyItem(r)),
            map(delimited(tag("LIST_OF_REVERSIBLE_TOPOLOGY_ITEM("), <Vec<ReversibleTopologyItem<'a>>>::parse, char(')')), |r| ReversibleTopology::ListOfReversibleTopologyItem(r)),
            map(delimited(tag("SET_OF_REVERSIBLE_TOPOLOGY_ITEM("), <Vec<ReversibleTopologyItem<'a>>>::parse, char(')')), |r| ReversibleTopology::SetOfReversibleTopologyItem(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct ReversibleTopologyItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ReversibleTopologyItem<'a> = Id<ReversibleTopologyItem_<'a>>;

declare_entity!(RevolutePair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
);
declare_entity!(RevolutePairRange,
    applies_to_pair: KinematicPair<'a>,
    lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
);
declare_entity!(RevolutePairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_rotation: PlaneAngleMeasure<'a>,
);
declare_entity!(RevolvedAreaSolid,
    name: Label<'a>,
    swept_area: CurveBoundedSurface<'a>,
    axis: Axis1Placement<'a>,
    angle: PlaneAngleMeasure<'a>,
);
declare_entity!(RevolvedFaceSolid,
    name: Label<'a>,
    swept_face: FaceSurface<'a>,
    axis: Axis1Placement<'a>,
    angle: PlaneAngleMeasure<'a>,
);
declare_entity!(Rib,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(RightAngularWedge,
    name: Label<'a>,
    position: Axis2Placement3d<'a>,
    x: PositiveLengthMeasure<'a>,
    y: PositiveLengthMeasure<'a>,
    z: PositiveLengthMeasure<'a>,
    ltx: LengthMeasure<'a>,
);
declare_entity!(RightCircularCone,
    name: Label<'a>,
    position: Axis1Placement<'a>,
    height: PositiveLengthMeasure<'a>,
    radius: LengthMeasure<'a>,
    semi_angle: PlaneAngleMeasure<'a>,
);
declare_entity!(RightCircularCylinder,
    name: Label<'a>,
    position: Axis1Placement<'a>,
    height: PositiveLengthMeasure<'a>,
    radius: PositiveLengthMeasure<'a>,
);
#[derive(Debug)]
pub struct RigidPlacement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RigidPlacement<'a> = Id<RigidPlacement_<'a>>;

declare_entity!(RoleAssociation,
    role: ObjectRole<'a>,
    item_with_role: RoleSelect<'a>,
);
#[derive(Debug)]
pub struct RoleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RoleSelect<'a> = Id<RoleSelect_<'a>>;

declare_entity!(RollingCurvePair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    curve_1: Curve<'a>,
    curve_2: Curve<'a>,
    orientation: bool,
);
declare_entity!(RollingCurvePairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_point_on_curve_1: PointOnCurve<'a>,
);
declare_entity!(RollingSurfacePair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    surface_1: Surface<'a>,
    surface_2: Surface<'a>,
    orientation: bool,
);
declare_entity!(RollingSurfacePairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_point_on_surface: PointOnSurface<'a>,
    actual_rotation: PlaneAngleMeasure<'a>,
);
declare_entity!(RotationAboutDirection,
    direction_of_axis: Direction<'a>,
    rotation_angle: PlaneAngleMeasure<'a>,
);
#[derive(Debug)]
pub enum RotationalRangeMeasure<'a> { // select
    PlaneAngleMeasure(PlaneAngleMeasure<'a>),
    UnlimitedRange(UnlimitedRange<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for RotationalRangeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("PLANE_ANGLE_MEASURE("), <PlaneAngleMeasure<'a>>::parse, char(')')), |r| RotationalRangeMeasure::PlaneAngleMeasure(r)),
            map(delimited(tag("UNLIMITED_RANGE("), <UnlimitedRange<'a>>::parse, char(')')), |r| RotationalRangeMeasure::UnlimitedRange(r)),
        ))(s)
    }
}
declare_entity!(RoundHole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(RoundedUProfile,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(RoundnessTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(RuledSurfaceSweptAreaSolid,
    name: Label<'a>,
    swept_area: CurveBoundedSurface<'a>,
    directrix: Curve<'a>,
    start_param: f64,
    end_param: f64,
    reference_surface: Surface<'a>,
);
declare_entity!(RunoutZoneDefinition,
    zone: ToleranceZone<'a>,
    boundaries: Vec<ShapeAspect<'a>>,
    orientation: RunoutZoneOrientation<'a>,
);
declare_entity!(RunoutZoneOrientation,
    angle: MeasureWithUnit<'a>,
);
declare_entity!(RunoutZoneOrientationReferenceDirection,
    angle: MeasureWithUnit<'a>,
    orientation_defining_relationship: ShapeAspectRelationship<'a>,
);
declare_entity!(ScrewPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    pitch: LengthMeasure<'a>,
);
declare_entity!(ScrewPairRange,
    applies_to_pair: KinematicPair<'a>,
    lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
);
declare_entity!(ScrewPairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_rotation: PlaneAngleMeasure<'a>,
);
declare_entity!(SeamCurve,
    name: Label<'a>,
    curve_3d: Curve<'a>,
    associated_geometry: Vec<PcurveOrSurface<'a>>,
    master_representation: PreferredSurfaceCurveRepresentation<'a>,
);
declare_entity!(SeamEdge,
    name: Label<'a>,
    edge_start: Vertex<'a>,
    edge_end: Vertex<'a>,
    edge_element: Edge<'a>,
    orientation: bool,
    pcurve_reference: Pcurve<'a>,
);
#[derive(Debug)]
pub struct SecondInMinute<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SecondInMinute<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(SecurityClassification,
    name: Label<'a>,
    purpose: Text<'a>,
    security_level: SecurityClassificationLevel<'a>,
);
declare_entity!(SecurityClassificationAssignment,
    assigned_security_classification: SecurityClassification<'a>,
);
#[derive(Debug)]
pub struct SecurityClassificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SecurityClassificationItem<'a> = Id<SecurityClassificationItem_<'a>>;

declare_entity!(SecurityClassificationLevel,
    name: Label<'a>,
);
declare_entity!(SerialNumberedEffectivity,
    id: Identifier<'a>,
    effectivity_start_id: Identifier<'a>,
    effectivity_end_id: Option<Identifier<'a>>,
);
#[derive(Debug)]
pub struct SetOfReversibleTopologyItem<'a>(pub Vec<ReversibleTopologyItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for SetOfReversibleTopologyItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<ReversibleTopologyItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct SetRepresentationItem<'a>(pub Vec<RepresentationItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for SetRepresentationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<RepresentationItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub enum ShadingCurveMethod<'a> { // enum
    ConstantColour,
    LinearColour,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ShadingCurveMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ShadingCurveMethod::*;
        alt((
            map(tag(".CONSTANT_COLOUR."), |_| ConstantColour),
            map(tag(".LINEAR_COLOUR."), |_| LinearColour),
        ))(s)
    }
}
#[derive(Debug)]
pub enum ShadingSurfaceMethod<'a> { // enum
    ConstantShading,
    ColourShading,
    DotShading,
    NormalShading,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ShadingSurfaceMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ShadingSurfaceMethod::*;
        alt((
            map(tag(".CONSTANT_SHADING."), |_| ConstantShading),
            map(tag(".COLOUR_SHADING."), |_| ColourShading),
            map(tag(".DOT_SHADING."), |_| DotShading),
            map(tag(".NORMAL_SHADING."), |_| NormalShading),
        ))(s)
    }
}
declare_entity!(ShapeAspect,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(ShapeAspectAssociativity,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(ShapeAspectDerivingRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(ShapeAspectRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(ShapeAspectTransition,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(ShapeDefiningRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_shape_aspect: ShapeAspect<'a>,
    related_shape_aspect: ShapeAspect<'a>,
);
#[derive(Debug)]
pub struct ShapeDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ShapeDefinition<'a> = Id<ShapeDefinition_<'a>>;

declare_entity!(ShapeDefinitionRepresentation,
    definition: RepresentedDefinition<'a>,
    used_representation: Representation<'a>,
);
declare_entity!(ShapeDimensionRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(ShapeRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(ShapeRepresentationRelationship,
    name: Label<'a>,
    description: Option<Text<'a>>,
    rep_1: Representation<'a>,
    rep_2: Representation<'a>,
);
declare_entity!(ShapeRepresentationWithParameters,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
#[derive(Debug)]
pub struct Shell_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Shell<'a> = Id<Shell_<'a>>;

declare_entity!(ShellBasedSurfaceModel,
    name: Label<'a>,
    sbsm_boundary: Vec<Shell<'a>>,
);
#[derive(Debug)]
pub enum SiPrefix<'a> { // enum
    Exa,
    Peta,
    Tera,
    Giga,
    Mega,
    Kilo,
    Hecto,
    Deca,
    Deci,
    Centi,
    Milli,
    Micro,
    Nano,
    Pico,
    Femto,
    Atto,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SiPrefix<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SiPrefix::*;
        alt((
            map(tag(".EXA."), |_| Exa),
            map(tag(".PETA."), |_| Peta),
            map(tag(".TERA."), |_| Tera),
            map(tag(".GIGA."), |_| Giga),
            map(tag(".MEGA."), |_| Mega),
            map(tag(".KILO."), |_| Kilo),
            map(tag(".HECTO."), |_| Hecto),
            map(tag(".DECA."), |_| Deca),
            map(tag(".DECI."), |_| Deci),
            map(tag(".CENTI."), |_| Centi),
            map(tag(".MILLI."), |_| Milli),
            map(tag(".MICRO."), |_| Micro),
            map(tag(".NANO."), |_| Nano),
            map(tag(".PICO."), |_| Pico),
            map(tag(".FEMTO."), |_| Femto),
            map(tag(".ATTO."), |_| Atto),
        ))(s)
    }
}
declare_entity!(SiUnit,
    dimensions: Derived,
    prefix: Option<SiPrefix<'a>>,
    name: SiUnitName<'a>,
);
#[derive(Debug)]
pub enum SiUnitName<'a> { // enum
    Metre,
    Gram,
    Second,
    Ampere,
    Kelvin,
    Mole,
    Candela,
    Radian,
    Steradian,
    Hertz,
    Newton,
    Pascal,
    Joule,
    Watt,
    Coulomb,
    Volt,
    Farad,
    Ohm,
    Siemens,
    Weber,
    Tesla,
    Henry,
    DegreeCelsius,
    Lumen,
    Lux,
    Becquerel,
    Gray,
    Sievert,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SiUnitName<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SiUnitName::*;
        alt((
            map(tag(".METRE."), |_| Metre),
            map(tag(".GRAM."), |_| Gram),
            map(tag(".SECOND."), |_| Second),
            map(tag(".AMPERE."), |_| Ampere),
            map(tag(".KELVIN."), |_| Kelvin),
            map(tag(".MOLE."), |_| Mole),
            map(tag(".CANDELA."), |_| Candela),
            map(tag(".RADIAN."), |_| Radian),
            map(tag(".STERADIAN."), |_| Steradian),
            map(tag(".HERTZ."), |_| Hertz),
            map(tag(".NEWTON."), |_| Newton),
            map(tag(".PASCAL."), |_| Pascal),
            map(tag(".JOULE."), |_| Joule),
            map(tag(".WATT."), |_| Watt),
            map(tag(".COULOMB."), |_| Coulomb),
            map(tag(".VOLT."), |_| Volt),
            map(tag(".FARAD."), |_| Farad),
            map(tag(".OHM."), |_| Ohm),
            map(tag(".SIEMENS."), |_| Siemens),
        alt((
            map(tag(".WEBER."), |_| Weber),
            map(tag(".TESLA."), |_| Tesla),
            map(tag(".HENRY."), |_| Henry),
            map(tag(".DEGREE_CELSIUS."), |_| DegreeCelsius),
            map(tag(".LUMEN."), |_| Lumen),
            map(tag(".LUX."), |_| Lux),
            map(tag(".BECQUEREL."), |_| Becquerel),
            map(tag(".GRAY."), |_| Gray),
            map(tag(".SIEVERT."), |_| Sievert),
        ))))(s)
    }
}
declare_entity!(SimpleBooleanExpression,
);
declare_entity!(SimpleGenericExpression,
);
declare_entity!(SimpleNumericExpression,
);
declare_entity!(SimplePairRange,
    applies_to_pair: KinematicPair<'a>,
);
declare_entity!(SimpleStringExpression,
);
declare_entity!(SinFunction,
    operand: GenericExpression<'a>,
);
#[derive(Debug)]
pub enum SizeSelect<'a> { // select
    PositiveLengthMeasure(PositiveLengthMeasure<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SizeSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("POSITIVE_LENGTH_MEASURE("), <PositiveLengthMeasure<'a>>::parse, char(')')), |r| SizeSelect::PositiveLengthMeasure(r)),
            map(<MeasureWithUnit<'a>>::parse, |r| SizeSelect::MeasureWithUnit(r)),
            map(delimited(tag("DESCRIPTIVE_MEASURE("), <DescriptiveMeasure<'a>>::parse, char(')')), |r| SizeSelect::DescriptiveMeasure(r)),
        ))(s)
    }
}
declare_entity!(SlashExpression,
    operands: Vec<GenericExpression<'a>>,
);
declare_entity!(SlidingCurvePair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    curve_1: Curve<'a>,
    curve_2: Curve<'a>,
    orientation: bool,
);
declare_entity!(SlidingCurvePairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_point_on_curve_1: PointOnCurve<'a>,
    actual_point_on_curve_2: PointOnCurve<'a>,
);
declare_entity!(SlidingSurfacePair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    surface_1: Surface<'a>,
    surface_2: Surface<'a>,
    orientation: bool,
);
declare_entity!(SlidingSurfacePairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_point_on_surface_1: PointOnSurface<'a>,
    actual_point_on_surface_2: PointOnSurface<'a>,
    actual_rotation: PlaneAngleMeasure<'a>,
);
declare_entity!(Slot,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(SlotEnd,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
#[derive(Debug)]
pub struct SolidAngleMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SolidAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(SolidAngleMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(SolidAngleUnit,
    dimensions: DimensionalExponents<'a>,
);
declare_entity!(SolidModel,
    name: Label<'a>,
);
declare_entity!(SolidReplica,
    name: Label<'a>,
    parent_solid: SolidModel<'a>,
    transformation: CartesianTransformationOperator3d<'a>,
);
#[derive(Debug)]
pub enum Source<'a> { // enum
    Made,
    Bought,
    NotKnown,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for Source<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use Source::*;
        alt((
            map(tag(".MADE."), |_| Made),
            map(tag(".BOUGHT."), |_| Bought),
            map(tag(".NOT_KNOWN."), |_| NotKnown),
        ))(s)
    }
}
#[derive(Debug)]
pub enum SourceItem<'a> { // select
    Identifier(Identifier<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SourceItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(delimited(tag("IDENTIFIER("), <Identifier<'a>>::parse, char(')')), |r| SourceItem::Identifier(r))(s)
    }
}
#[derive(Debug)]
pub enum SpatialRotation<'a> { // select
    YprRotation(Vec<PlaneAngleMeasure<'a>>),
    RotationAboutDirection(RotationAboutDirection<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SpatialRotation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("YPR_ROTATION("), <Vec<PlaneAngleMeasure<'a>>>::parse, char(')')), |r| SpatialRotation::YprRotation(r)),
            map(<RotationAboutDirection<'a>>::parse, |r| SpatialRotation::RotationAboutDirection(r)),
        ))(s)
    }
}
declare_entity!(SpecifiedHigherUsageOccurrence,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_product_definition: ProductDefinition<'a>,
    related_product_definition: ProductDefinition<'a>,
    reference_designator: Option<Identifier<'a>>,
    upper_usage: AssemblyComponentUsage<'a>,
    next_usage: NextAssemblyUsageOccurrence<'a>,
);
#[derive(Debug)]
pub struct SpecifiedItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SpecifiedItem<'a> = Id<SpecifiedItem_<'a>>;

declare_entity!(Sphere,
    name: Label<'a>,
    radius: PositiveLengthMeasure<'a>,
    centre: Point<'a>,
);
declare_entity!(SphericalPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
);
declare_entity!(SphericalPairRange,
    applies_to_pair: KinematicPair<'a>,
    lower_limit_yaw: RotationalRangeMeasure<'a>,
    upper_limit_yaw: RotationalRangeMeasure<'a>,
    lower_limit_pitch: RotationalRangeMeasure<'a>,
    upper_limit_pitch: RotationalRangeMeasure<'a>,
    lower_limit_roll: RotationalRangeMeasure<'a>,
    upper_limit_roll: RotationalRangeMeasure<'a>,
);
declare_entity!(SphericalPairValue,
    applies_to_pair: KinematicPair<'a>,
    input_orientation: SpatialRotation<'a>,
);
declare_entity!(SphericalSurface,
    name: Label<'a>,
    position: Axis2Placement3d<'a>,
    radius: PositiveLengthMeasure<'a>,
);
declare_entity!(SqlMappableDefinedFunction,
);
declare_entity!(SquareRootFunction,
    operand: GenericExpression<'a>,
);
declare_entity!(SquareUProfile,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(StandardUncertainty,
    measure_name: Label<'a>,
    description: Text<'a>,
    uncertainty_value: f64,
);
declare_entity!(StraightnessTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(StringDefinedFunction,
);
declare_entity!(StringExpression,
);
declare_entity!(StringLiteral,
    the_value: &'a str,
);
declare_entity!(StringVariable,
);
declare_entity!(StructuredDimensionCallout,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
#[derive(Debug)]
pub struct StyleContextSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type StyleContextSelect<'a> = Id<StyleContextSelect_<'a>>;

declare_entity!(StyledItem,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
);
declare_entity!(Subedge,
    name: Label<'a>,
    edge_start: Vertex<'a>,
    edge_end: Vertex<'a>,
    parent_edge: Edge<'a>,
);
declare_entity!(Subface,
    name: Label<'a>,
    bounds: Vec<FaceBound<'a>>,
    parent_face: Face<'a>,
);
declare_entity!(SubstringExpression,
    operands: Vec<GenericExpression<'a>>,
);
#[derive(Debug)]
pub struct SupportedItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SupportedItem<'a> = Id<SupportedItem_<'a>>;

declare_entity!(Surface,
    name: Label<'a>,
);
declare_entity!(SurfaceConditionCallout,
    name: Label<'a>,
    contents: Vec<DraughtingCalloutElement<'a>>,
);
declare_entity!(SurfaceCurve,
    name: Label<'a>,
    curve_3d: Curve<'a>,
    associated_geometry: Vec<PcurveOrSurface<'a>>,
    master_representation: PreferredSurfaceCurveRepresentation<'a>,
);
declare_entity!(SurfaceCurveSweptAreaSolid,
    name: Label<'a>,
    swept_area: CurveBoundedSurface<'a>,
    directrix: Curve<'a>,
    start_param: f64,
    end_param: f64,
    reference_surface: Surface<'a>,
);
declare_entity!(SurfaceOfLinearExtrusion,
    name: Label<'a>,
    swept_curve: Curve<'a>,
    extrusion_axis: Vector<'a>,
);
declare_entity!(SurfaceOfRevolution,
    name: Label<'a>,
    swept_curve: Curve<'a>,
    axis_position: Axis1Placement<'a>,
);
declare_entity!(SurfacePair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    surface_1: Surface<'a>,
    surface_2: Surface<'a>,
    orientation: bool,
);
declare_entity!(SurfacePairRange,
    applies_to_pair: KinematicPair<'a>,
    range_on_surface_1: RectangularTrimmedSurface<'a>,
    range_on_surface_2: RectangularTrimmedSurface<'a>,
    lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
);
declare_entity!(SurfacePatch,
    parent_surface: BoundedSurface<'a>,
    u_transition: TransitionCode<'a>,
    v_transition: TransitionCode<'a>,
    u_sense: bool,
    v_sense: bool,
);
declare_entity!(SurfaceProfileTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
);
declare_entity!(SurfaceRenderingProperties,
    rendered_colour: Colour<'a>,
);
declare_entity!(SurfaceReplica,
    name: Label<'a>,
    parent_surface: Surface<'a>,
    transformation: CartesianTransformationOperator3d<'a>,
);
#[derive(Debug)]
pub enum SurfaceSide<'a> { // enum
    Positive,
    Negative,
    Both,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SurfaceSide<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SurfaceSide::*;
        alt((
            map(tag(".POSITIVE."), |_| Positive),
            map(tag(".NEGATIVE."), |_| Negative),
            map(tag(".BOTH."), |_| Both),
        ))(s)
    }
}
declare_entity!(SurfaceSideStyle,
    name: Label<'a>,
    styles: Vec<SurfaceStyleElementSelect<'a>>,
);
#[derive(Debug)]
pub struct SurfaceSideStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SurfaceSideStyleSelect<'a> = Id<SurfaceSideStyleSelect_<'a>>;

declare_entity!(SurfaceStyleBoundary,
    style_of_boundary: CurveOrRender<'a>,
);
declare_entity!(SurfaceStyleControlGrid,
    style_of_control_grid: CurveOrRender<'a>,
);
#[derive(Debug)]
pub struct SurfaceStyleElementSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SurfaceStyleElementSelect<'a> = Id<SurfaceStyleElementSelect_<'a>>;

declare_entity!(SurfaceStyleFillArea,
    fill_area: FillAreaStyle<'a>,
);
declare_entity!(SurfaceStyleParameterLine,
    style_of_parameter_lines: CurveOrRender<'a>,
    direction_counts: Vec<DirectionCountSelect<'a>>,
);
declare_entity!(SurfaceStyleReflectanceAmbient,
    ambient_reflectance: f64,
);
declare_entity!(SurfaceStyleReflectanceAmbientDiffuse,
    ambient_reflectance: f64,
    diffuse_reflectance: f64,
);
declare_entity!(SurfaceStyleReflectanceAmbientDiffuseSpecular,
    ambient_reflectance: f64,
    diffuse_reflectance: f64,
    specular_reflectance: f64,
    specular_exponent: f64,
    specular_colour: Colour<'a>,
);
declare_entity!(SurfaceStyleRendering,
    rendering_method: ShadingSurfaceMethod<'a>,
    surface_colour: Colour<'a>,
);
declare_entity!(SurfaceStyleRenderingWithProperties,
    rendering_method: ShadingSurfaceMethod<'a>,
    surface_colour: Colour<'a>,
    properties: Vec<RenderingPropertiesSelect<'a>>,
);
declare_entity!(SurfaceStyleSegmentationCurve,
    style_of_segmentation_curve: CurveOrRender<'a>,
);
declare_entity!(SurfaceStyleSilhouette,
    style_of_silhouette: CurveOrRender<'a>,
);
declare_entity!(SurfaceStyleTransparent,
    transparency: f64,
);
declare_entity!(SurfaceStyleUsage,
    side: SurfaceSide<'a>,
    style: SurfaceSideStyleSelect<'a>,
);
declare_entity!(SurfaceTextureRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);

#[derive(Debug)]
pub struct SurfaceToleranceDeviation<'a>(pub PositiveLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for SurfaceToleranceDeviation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveLengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct SurfaceToleranceParameter<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SurfaceToleranceParameter<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(SweptAreaSolid,
    name: Label<'a>,
    swept_area: CurveBoundedSurface<'a>,
);
declare_entity!(SweptDiskSolid,
    name: Label<'a>,
    directrix: Curve<'a>,
    radius: PositiveLengthMeasure<'a>,
    inner_radius: Option<PositiveLengthMeasure<'a>>,
    start_param: f64,
    end_param: f64,
);
declare_entity!(SweptFaceSolid,
    name: Label<'a>,
    swept_face: FaceSurface<'a>,
);
declare_entity!(SweptSurface,
    name: Label<'a>,
    swept_curve: Curve<'a>,
);
declare_entity!(SymbolColour,
    colour_of_symbol: Colour<'a>,
);
declare_entity!(SymbolRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(SymbolRepresentationMap,
    mapping_origin: RepresentationItem<'a>,
    mapped_representation: Representation<'a>,
);
declare_entity!(SymbolStyle,
    name: Label<'a>,
    style_of_symbol: SymbolStyleSelect<'a>,
);
#[derive(Debug)]
pub struct SymbolStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SymbolStyleSelect<'a> = Id<SymbolStyleSelect_<'a>>;

declare_entity!(SymbolTarget,
    name: Label<'a>,
    placement: Axis2Placement<'a>,
    x_scale: PositiveRatioMeasure<'a>,
    y_scale: PositiveRatioMeasure<'a>,
);
declare_entity!(SymmetricShapeAspect,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(SymmetryTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
    datum_system: Vec<DatumReference<'a>>,
);
declare_entity!(TactileAppearanceRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
declare_entity!(TanFunction,
    operand: GenericExpression<'a>,
);
declare_entity!(Tangent,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(Taper,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(TeeProfile,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(TerminatorSymbol,
    name: Label<'a>,
    styles: Vec<PresentationStyleAssignment<'a>>,
    item: RepresentationItem<'a>,
    annotated_curve: AnnotationCurveOccurrence<'a>,
);
#[derive(Debug)]
pub struct Text<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Text<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct TextAlignment<'a>(pub Label<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for TextAlignment<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(Label::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct TextDelineation<'a>(pub Label<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for TextDelineation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(Label::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(TextLiteral,
    name: Label<'a>,
    literal: PresentableText<'a>,
    placement: Axis2Placement<'a>,
    alignment: TextAlignment<'a>,
    path: TextPath<'a>,
    font: FontSelect<'a>,
);
declare_entity!(TextLiteralWithAssociatedCurves,
    name: Label<'a>,
    literal: PresentableText<'a>,
    placement: Axis2Placement<'a>,
    alignment: TextAlignment<'a>,
    path: TextPath<'a>,
    font: FontSelect<'a>,
    associated_curves: Vec<Curve<'a>>,
);
declare_entity!(TextLiteralWithBlankingBox,
    name: Label<'a>,
    literal: PresentableText<'a>,
    placement: Axis2Placement<'a>,
    alignment: TextAlignment<'a>,
    path: TextPath<'a>,
    font: FontSelect<'a>,
    blanking: PlanarBox<'a>,
);
declare_entity!(TextLiteralWithDelineation,
    name: Label<'a>,
    literal: PresentableText<'a>,
    placement: Axis2Placement<'a>,
    alignment: TextAlignment<'a>,
    path: TextPath<'a>,
    font: FontSelect<'a>,
    delineation: TextDelineation<'a>,
);
declare_entity!(TextLiteralWithExtent,
    name: Label<'a>,
    literal: PresentableText<'a>,
    placement: Axis2Placement<'a>,
    alignment: TextAlignment<'a>,
    path: TextPath<'a>,
    font: FontSelect<'a>,
    extent: PlanarExtent<'a>,
);
#[derive(Debug)]
pub struct TextOrCharacter_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type TextOrCharacter<'a> = Id<TextOrCharacter_<'a>>;

#[derive(Debug)]
pub enum TextPath<'a> { // enum
    Left,
    Right,
    Up,
    Down,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TextPath<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TextPath::*;
        alt((
            map(tag(".LEFT."), |_| Left),
            map(tag(".RIGHT."), |_| Right),
            map(tag(".UP."), |_| Up),
            map(tag(".DOWN."), |_| Down),
        ))(s)
    }
}
declare_entity!(TextStringRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
#[derive(Debug)]
pub struct TextStringRepresentationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type TextStringRepresentationItem<'a> = Id<TextStringRepresentationItem_<'a>>;

declare_entity!(TextStyle,
    name: Label<'a>,
    character_appearance: CharacterStyleSelect<'a>,
);
declare_entity!(TextStyleForDefinedFont,
    text_colour: Colour<'a>,
);
declare_entity!(TextStyleWithBoxCharacteristics,
    name: Label<'a>,
    character_appearance: CharacterStyleSelect<'a>,
    characteristics: Vec<BoxCharacteristicSelect<'a>>,
);
declare_entity!(TextStyleWithMirror,
    name: Label<'a>,
    character_appearance: CharacterStyleSelect<'a>,
    mirror_placement: Axis2Placement<'a>,
);
declare_entity!(TextStyleWithSpacing,
    name: Label<'a>,
    character_appearance: CharacterStyleSelect<'a>,
    character_spacing: CharacterSpacingSelect<'a>,
);
#[derive(Debug)]
pub struct ThermodynamicTemperatureMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ThermodynamicTemperatureMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(ThermodynamicTemperatureMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(ThermodynamicTemperatureUnit,
    dimensions: DimensionalExponents<'a>,
);
declare_entity!(Thread,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(TimeInterval,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(TimeIntervalAssignment,
    assigned_time_interval: TimeInterval<'a>,
    role: TimeIntervalRole<'a>,
);
declare_entity!(TimeIntervalBasedEffectivity,
    id: Identifier<'a>,
    effectivity_period: TimeInterval<'a>,
);
#[derive(Debug)]
pub struct TimeIntervalItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type TimeIntervalItem<'a> = Id<TimeIntervalItem_<'a>>;

declare_entity!(TimeIntervalRole,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(TimeIntervalWithBounds,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    primary_bound: Option<DateTimeOrEventOccurrence<'a>>,
    secondary_bound: Option<DateTimeOrEventOccurrence<'a>>,
    duration: Option<TimeMeasureWithUnit<'a>>,
);
#[derive(Debug)]
pub struct TimeMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for TimeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(TimeMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(TimeUnit,
    dimensions: DimensionalExponents<'a>,
);
#[derive(Debug)]
pub enum ToleranceDeviationSelect<'a> { // select
    CurveToleranceDeviation(CurveToleranceDeviation<'a>),
    SurfaceToleranceDeviation(SurfaceToleranceDeviation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ToleranceDeviationSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("CURVE_TOLERANCE_DEVIATION("), <CurveToleranceDeviation<'a>>::parse, char(')')), |r| ToleranceDeviationSelect::CurveToleranceDeviation(r)),
            map(delimited(tag("SURFACE_TOLERANCE_DEVIATION("), <SurfaceToleranceDeviation<'a>>::parse, char(')')), |r| ToleranceDeviationSelect::SurfaceToleranceDeviation(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct ToleranceMethodDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ToleranceMethodDefinition<'a> = Id<ToleranceMethodDefinition_<'a>>;

#[derive(Debug)]
pub enum ToleranceParameterSelect<'a> { // select
    CurveToleranceParameter(CurveToleranceParameter<'a>),
    SurfaceToleranceParameter(SurfaceToleranceParameter<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ToleranceParameterSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("CURVE_TOLERANCE_PARAMETER("), <CurveToleranceParameter<'a>>::parse, char(')')), |r| ToleranceParameterSelect::CurveToleranceParameter(r)),
            map(delimited(tag("SURFACE_TOLERANCE_PARAMETER("), <SurfaceToleranceParameter<'a>>::parse, char(')')), |r| ToleranceParameterSelect::SurfaceToleranceParameter(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct ToleranceSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ToleranceSelect<'a> = Id<ToleranceSelect_<'a>>;

declare_entity!(ToleranceValue,
    lower_bound: MeasureWithUnit<'a>,
    upper_bound: MeasureWithUnit<'a>,
);
declare_entity!(ToleranceZone,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
    defining_tolerance: Vec<GeometricTolerance<'a>>,
    form: ToleranceZoneForm<'a>,
);
declare_entity!(ToleranceZoneDefinition,
    zone: ToleranceZone<'a>,
    boundaries: Vec<ShapeAspect<'a>>,
);
declare_entity!(ToleranceZoneForm,
    name: Label<'a>,
);
declare_entity!(TopologicalRepresentationItem,
    name: Label<'a>,
);
declare_entity!(ToroidalSurface,
    name: Label<'a>,
    position: Axis2Placement3d<'a>,
    major_radius: PositiveLengthMeasure<'a>,
    minor_radius: PositiveLengthMeasure<'a>,
);
declare_entity!(Torus,
    name: Label<'a>,
    position: Axis1Placement<'a>,
    major_radius: PositiveLengthMeasure<'a>,
    minor_radius: PositiveLengthMeasure<'a>,
);
declare_entity!(TotalRunoutTolerance,
    name: Label<'a>,
    description: Text<'a>,
    magnitude: MeasureWithUnit<'a>,
    toleranced_shape_aspect: ShapeAspect<'a>,
    datum_system: Vec<DatumReference<'a>>,
);
#[derive(Debug)]
pub struct Transformation_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Transformation<'a> = Id<Transformation_<'a>>;

#[derive(Debug)]
pub enum TransitionCode<'a> { // enum
    Discontinuous,
    Continuous,
    ContSameGradient,
    ContSameGradientSameCurvature,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TransitionCode<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TransitionCode::*;
        alt((
            map(tag(".DISCONTINUOUS."), |_| Discontinuous),
            map(tag(".CONTINUOUS."), |_| Continuous),
            map(tag(".CONT_SAME_GRADIENT."), |_| ContSameGradient),
            map(tag(".CONT_SAME_GRADIENT_SAME_CURVATURE."), |_| ContSameGradientSameCurvature),
        ))(s)
    }
}
declare_entity!(TransitionFeature,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
#[derive(Debug)]
pub enum TranslationalRangeMeasure<'a> { // select
    LengthMeasure(LengthMeasure<'a>),
    UnlimitedRange(UnlimitedRange<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for TranslationalRangeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LENGTH_MEASURE("), <LengthMeasure<'a>>::parse, char(')')), |r| TranslationalRangeMeasure::LengthMeasure(r)),
            map(delimited(tag("UNLIMITED_RANGE("), <UnlimitedRange<'a>>::parse, char(')')), |r| TranslationalRangeMeasure::UnlimitedRange(r)),
        ))(s)
    }
}
declare_entity!(TrimmedCurve,
    name: Label<'a>,
    basis_curve: Curve<'a>,
    trim_1: Vec<TrimmingSelect<'a>>,
    trim_2: Vec<TrimmingSelect<'a>>,
    sense_agreement: bool,
    master_representation: TrimmingPreference<'a>,
);
#[derive(Debug)]
pub enum TrimmingPreference<'a> { // enum
    Cartesian,
    Parameter,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TrimmingPreference<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TrimmingPreference::*;
        alt((
            map(tag(".CARTESIAN."), |_| Cartesian),
            map(tag(".PARAMETER."), |_| Parameter),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
#[derive(Debug)]
pub enum TrimmingSelect<'a> { // select
    CartesianPoint(CartesianPoint<'a>),
    ParameterValue(ParameterValue<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for TrimmingSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<CartesianPoint<'a>>::parse, |r| TrimmingSelect::CartesianPoint(r)),
            map(delimited(tag("PARAMETER_VALUE("), <ParameterValue<'a>>::parse, char(')')), |r| TrimmingSelect::ParameterValue(r)),
        ))(s)
    }
}
declare_entity!(TwoDirectionRepeatFactor,
    name: Label<'a>,
    repeat_factor: Vector<'a>,
    second_repeat_factor: Vector<'a>,
);
declare_entity!(TypeQualifier,
    name: Label<'a>,
);
#[derive(Debug)]
pub struct UDirectionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for UDirectionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(UnaryBooleanExpression,
    operand: GenericExpression<'a>,
);
declare_entity!(UnaryFunctionCall,
    operand: GenericExpression<'a>,
);
declare_entity!(UnaryGenericExpression,
    operand: GenericExpression<'a>,
);
declare_entity!(UnaryNumericExpression,
    operand: GenericExpression<'a>,
);
declare_entity!(UncertaintyAssignedRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
    uncertainty: Vec<UncertaintyMeasureWithUnit<'a>>,
);
declare_entity!(UncertaintyMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(UncertaintyQualifier,
    measure_name: Label<'a>,
    description: Text<'a>,
);
declare_entity!(UnconstrainedPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
);
declare_entity!(UnconstrainedPairValue,
    applies_to_pair: KinematicPair<'a>,
    actual_placement: Axis2Placement3d<'a>,
);
declare_entity!(UniformCurve,
    name: Label<'a>,
    degree: i64,
    control_points_list: Vec<CartesianPoint<'a>>,
    curve_form: BSplineCurveForm<'a>,
    closed_curve: Logical,
    self_intersect: Logical,
);
declare_entity!(UniformSurface,
    name: Label<'a>,
    u_degree: i64,
    v_degree: i64,
    control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    surface_form: BSplineSurfaceForm<'a>,
    u_closed: Logical,
    v_closed: Logical,
    self_intersect: Logical,
);
#[derive(Debug)]
pub struct Unit_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Unit<'a> = Id<Unit_<'a>>;

declare_entity!(UniversalPair,
    name: Label<'a>,
    description: Option<Text<'a>>,
    transform_item_1: RepresentationItem<'a>,
    transform_item_2: RepresentationItem<'a>,
    joint: KinematicJoint<'a>,
    input_skew_angle: Option<PlaneAngleMeasure<'a>>,
);
declare_entity!(UniversalPairRange,
    applies_to_pair: KinematicPair<'a>,
    lower_limit_first_rotation: RotationalRangeMeasure<'a>,
    upper_limit_first_rotation: RotationalRangeMeasure<'a>,
    lower_limit_second_rotation: RotationalRangeMeasure<'a>,
    upper_limit_second_rotation: RotationalRangeMeasure<'a>,
);
declare_entity!(UniversalPairValue,
    applies_to_pair: KinematicPair<'a>,
    first_rotation_angle: PlaneAngleMeasure<'a>,
    second_rotation_angle: PlaneAngleMeasure<'a>,
);
#[derive(Debug)]
pub enum UnlimitedRange<'a> { // enum
    Unlimited,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for UnlimitedRange<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use UnlimitedRange::*;
        map(tag(".UNLIMITED."), |_| Unlimited)(s)
    }
}
#[derive(Debug)]
pub struct VDirectionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for VDirectionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(ValueFunction,
    operand: GenericExpression<'a>,
);
#[derive(Debug)]
pub struct ValueQualifier_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ValueQualifier<'a> = Id<ValueQualifier_<'a>>;

declare_entity!(ValueRange,
    name: Label<'a>,
    item_element: CompoundItemDefinition<'a>,
);
declare_entity!(ValueRepresentationItem,
    name: Label<'a>,
    value_component: MeasureValue<'a>,
);
declare_entity!(Variable,
);
declare_entity!(VariableSemantics,
);
declare_entity!(Vector,
    name: Label<'a>,
    orientation: Direction<'a>,
    magnitude: LengthMeasure<'a>,
);
#[derive(Debug)]
pub struct VectorOrDirection_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type VectorOrDirection<'a> = Id<VectorOrDirection_<'a>>;

declare_entity!(VectorStyle,
    pre_defined_item__name: Label<'a>,
    curve_style__name: Label<'a>,
    curve_font: CurveFontOrScaledCurveFontSelect<'a>,
    curve_width: SizeSelect<'a>,
    curve_colour: Colour<'a>,
);
declare_entity!(VeeProfile,
    name: Label<'a>,
    description: Option<Text<'a>>,
    of_shape: ProductDefinitionShape<'a>,
    product_definitional: Logical,
);
declare_entity!(VersionedActionRequest,
    id: Identifier<'a>,
    version: Label<'a>,
    purpose: Text<'a>,
    description: Option<Text<'a>>,
);
declare_entity!(VersionedActionRequestRelationship,
    id: Identifier<'a>,
    name: Label<'a>,
    description: Option<Text<'a>>,
    relating_versioned_action_request: VersionedActionRequest<'a>,
    related_versioned_action_request: VersionedActionRequest<'a>,
);
declare_entity!(Vertex,
    name: Label<'a>,
);
declare_entity!(VertexLoop,
    name: Label<'a>,
    loop_vertex: Vertex<'a>,
);
declare_entity!(VertexPoint,
    representation_item__name: Label<'a>,
    vertex_geometry: Point<'a>,
);
declare_entity!(ViewVolume,
    projection_type: CentralOrParallel<'a>,
    projection_point: CartesianPoint<'a>,
    view_plane_distance: LengthMeasure<'a>,
    front_plane_distance: LengthMeasure<'a>,
    front_plane_clipping: bool,
    back_plane_distance: LengthMeasure<'a>,
    back_plane_clipping: bool,
    view_volume_sides_clipping: bool,
    view_window: PlanarBox<'a>,
);
declare_entity!(VisualAppearanceRepresentation,
    name: Label<'a>,
    items: Vec<RepresentationItem<'a>>,
    context_of_items: RepresentationContext<'a>,
);
#[derive(Debug)]
pub struct VolumeMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for VolumeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
declare_entity!(VolumeMeasureWithUnit,
    value_component: MeasureValue<'a>,
    unit_component: Unit<'a>,
);
declare_entity!(VolumeUnit,
    elements: Vec<DerivedUnitElement<'a>>,
);
declare_entity!(XorExpression,
    operands: Vec<GenericExpression<'a>>,
);
#[derive(Debug)]
pub struct YearNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for YearNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub enum YprEnumeration<'a> { // enum
    Yaw,
    Pitch,
    Roll,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for YprEnumeration<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use YprEnumeration::*;
        alt((
            map(tag(".YAW."), |_| Yaw),
            map(tag(".PITCH."), |_| Pitch),
            map(tag(".ROLL."), |_| Roll),
        ))(s)
    }
}
#[derive(Debug)]
pub struct YprRotation<'a>(pub Vec<PlaneAngleMeasure<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for YprRotation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<PlaneAngleMeasure<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub enum Entity<'a> {
    AbsFunction(AbsFunction_<'a>),
    AcosFunction(AcosFunction_<'a>),
    Action(Action_<'a>),
    ActionAssignment(ActionAssignment_<'a>),
    ActionDirective(ActionDirective_<'a>),
    ActionMethod(ActionMethod_<'a>),
    ActionMethodRelationship(ActionMethodRelationship_<'a>),
    ActionProperty(ActionProperty_<'a>),
    ActionPropertyRepresentation(ActionPropertyRepresentation_<'a>),
    ActionRelationship(ActionRelationship_<'a>),
    ActionRequestAssignment(ActionRequestAssignment_<'a>),
    ActionRequestSolution(ActionRequestSolution_<'a>),
    ActionRequestStatus(ActionRequestStatus_<'a>),
    ActionResource(ActionResource_<'a>),
    ActionResourceRequirement(ActionResourceRequirement_<'a>),
    ActionResourceType(ActionResourceType_<'a>),
    ActionStatus(ActionStatus_<'a>),
    Address(Address_<'a>),
    AdvancedBrepShapeRepresentation(AdvancedBrepShapeRepresentation_<'a>),
    AdvancedFace(AdvancedFace_<'a>),
    AlternateProductRelationship(AlternateProductRelationship_<'a>),
    AmountOfSubstanceMeasureWithUnit(AmountOfSubstanceMeasureWithUnit_<'a>),
    AmountOfSubstanceUnit(AmountOfSubstanceUnit_<'a>),
    AndExpression(AndExpression_<'a>),
    AngularDimension(AngularDimension_<'a>),
    AngularLocation(AngularLocation_<'a>),
    AngularSize(AngularSize_<'a>),
    AngularityTolerance(AngularityTolerance_<'a>),
    AnnotationCurveOccurrence(AnnotationCurveOccurrence_<'a>),
    AnnotationFillArea(AnnotationFillArea_<'a>),
    AnnotationFillAreaOccurrence(AnnotationFillAreaOccurrence_<'a>),
    AnnotationOccurrence(AnnotationOccurrence_<'a>),
    AnnotationOccurrenceAssociativity(AnnotationOccurrenceAssociativity_<'a>),
    AnnotationOccurrenceRelationship(AnnotationOccurrenceRelationship_<'a>),
    AnnotationPlane(AnnotationPlane_<'a>),
    AnnotationSubfigureOccurrence(AnnotationSubfigureOccurrence_<'a>),
    AnnotationSymbol(AnnotationSymbol_<'a>),
    AnnotationSymbolOccurrence(AnnotationSymbolOccurrence_<'a>),
    AnnotationText(AnnotationText_<'a>),
    AnnotationTextCharacter(AnnotationTextCharacter_<'a>),
    AnnotationTextOccurrence(AnnotationTextOccurrence_<'a>),
    Apex(Apex_<'a>),
    ApplicationContext(ApplicationContext_<'a>),
    ApplicationContextElement(ApplicationContextElement_<'a>),
    ApplicationContextRelationship(ApplicationContextRelationship_<'a>),
    ApplicationProtocolDefinition(ApplicationProtocolDefinition_<'a>),
    AppliedActionAssignment(AppliedActionAssignment_<'a>),
    AppliedActionRequestAssignment(AppliedActionRequestAssignment_<'a>),
    AppliedApprovalAssignment(AppliedApprovalAssignment_<'a>),
    AppliedArea(AppliedArea_<'a>),
    AppliedCertificationAssignment(AppliedCertificationAssignment_<'a>),
    AppliedClassificationAssignment(AppliedClassificationAssignment_<'a>),
    AppliedContractAssignment(AppliedContractAssignment_<'a>),
    AppliedDateAndTimeAssignment(AppliedDateAndTimeAssignment_<'a>),
    AppliedDateAssignment(AppliedDateAssignment_<'a>),
    AppliedDocumentReference(AppliedDocumentReference_<'a>),
    AppliedDocumentUsageConstraintAssignment(AppliedDocumentUsageConstraintAssignment_<'a>),
    AppliedEffectivityAssignment(AppliedEffectivityAssignment_<'a>),
    AppliedEventOccurrenceAssignment(AppliedEventOccurrenceAssignment_<'a>),
    AppliedExternalIdentificationAssignment(AppliedExternalIdentificationAssignment_<'a>),
    AppliedGroupAssignment(AppliedGroupAssignment_<'a>),
    AppliedIdentificationAssignment(AppliedIdentificationAssignment_<'a>),
    AppliedIneffectivityAssignment(AppliedIneffectivityAssignment_<'a>),
    AppliedNameAssignment(AppliedNameAssignment_<'a>),
    AppliedOrganizationAssignment(AppliedOrganizationAssignment_<'a>),
    AppliedOrganizationalProjectAssignment(AppliedOrganizationalProjectAssignment_<'a>),
    AppliedPersonAndOrganizationAssignment(AppliedPersonAndOrganizationAssignment_<'a>),
    AppliedPresentedItem(AppliedPresentedItem_<'a>),
    AppliedSecurityClassificationAssignment(AppliedSecurityClassificationAssignment_<'a>),
    AppliedTimeIntervalAssignment(AppliedTimeIntervalAssignment_<'a>),
    Approval(Approval_<'a>),
    ApprovalAssignment(ApprovalAssignment_<'a>),
    ApprovalDateTime(ApprovalDateTime_<'a>),
    ApprovalPersonOrganization(ApprovalPersonOrganization_<'a>),
    ApprovalRelationship(ApprovalRelationship_<'a>),
    ApprovalRole(ApprovalRole_<'a>),
    ApprovalStatus(ApprovalStatus_<'a>),
    ApproximationTolerance(ApproximationTolerance_<'a>),
    ApproximationToleranceDeviation(ApproximationToleranceDeviation_<'a>),
    ApproximationToleranceParameter(ApproximationToleranceParameter_<'a>),
    AreaInSet(AreaInSet_<'a>),
    AreaMeasureWithUnit(AreaMeasureWithUnit_<'a>),
    AreaUnit(AreaUnit_<'a>),
    AsinFunction(AsinFunction_<'a>),
    AssemblyComponentUsage(AssemblyComponentUsage_<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute_<'a>),
    AtanFunction(AtanFunction_<'a>),
    AttributeClassificationAssignment(AttributeClassificationAssignment_<'a>),
    AttributeLanguageAssignment(AttributeLanguageAssignment_<'a>),
    AttributeValueAssignment(AttributeValueAssignment_<'a>),
    AttributeValueRole(AttributeValueRole_<'a>),
    Axis1Placement(Axis1Placement_<'a>),
    Axis2Placement2d(Axis2Placement2d_<'a>),
    Axis2Placement3d(Axis2Placement3d_<'a>),
    BSplineCurve(BSplineCurve_<'a>),
    BSplineCurveWithKnots(BSplineCurveWithKnots_<'a>),
    BSplineSurface(BSplineSurface_<'a>),
    BSplineSurfaceWithKnots(BSplineSurfaceWithKnots_<'a>),
    BackgroundColour(BackgroundColour_<'a>),
    BarringHole(BarringHole_<'a>),
    Bead(Bead_<'a>),
    BeadEnd(BeadEnd_<'a>),
    BezierCurve(BezierCurve_<'a>),
    BezierSurface(BezierSurface_<'a>),
    BinaryBooleanExpression(BinaryBooleanExpression_<'a>),
    BinaryFunctionCall(BinaryFunctionCall_<'a>),
    BinaryGenericExpression(BinaryGenericExpression_<'a>),
    BinaryNumericExpression(BinaryNumericExpression_<'a>),
    Block(Block_<'a>),
    BooleanDefinedFunction(BooleanDefinedFunction_<'a>),
    BooleanExpression(BooleanExpression_<'a>),
    BooleanLiteral(BooleanLiteral_<'a>),
    BooleanResult(BooleanResult_<'a>),
    BooleanVariable(BooleanVariable_<'a>),
    Boss(Boss_<'a>),
    BossTop(BossTop_<'a>),
    BoundaryCurve(BoundaryCurve_<'a>),
    BoundedCurve(BoundedCurve_<'a>),
    BoundedPcurve(BoundedPcurve_<'a>),
    BoundedSurface(BoundedSurface_<'a>),
    BoundedSurfaceCurve(BoundedSurfaceCurve_<'a>),
    BoxDomain(BoxDomain_<'a>),
    BoxedHalfSpace(BoxedHalfSpace_<'a>),
    BrepWithVoids(BrepWithVoids_<'a>),
    CalendarDate(CalendarDate_<'a>),
    CameraImage(CameraImage_<'a>),
    CameraImage2dWithScale(CameraImage2dWithScale_<'a>),
    CameraImage3dWithScale(CameraImage3dWithScale_<'a>),
    CameraModel(CameraModel_<'a>),
    CameraModelD2(CameraModelD2_<'a>),
    CameraModelD3(CameraModelD3_<'a>),
    CameraModelD3WithHlhsr(CameraModelD3WithHlhsr_<'a>),
    CameraUsage(CameraUsage_<'a>),
    CartesianPoint(CartesianPoint_<'a>),
    CartesianTransformationOperator(CartesianTransformationOperator_<'a>),
    CartesianTransformationOperator2d(CartesianTransformationOperator2d_<'a>),
    CartesianTransformationOperator3d(CartesianTransformationOperator3d_<'a>),
    CelsiusTemperatureMeasureWithUnit(CelsiusTemperatureMeasureWithUnit_<'a>),
    CentreOfSymmetry(CentreOfSymmetry_<'a>),
    Certification(Certification_<'a>),
    CertificationAssignment(CertificationAssignment_<'a>),
    CertificationType(CertificationType_<'a>),
    Chamfer(Chamfer_<'a>),
    ChamferOffset(ChamferOffset_<'a>),
    CharacterGlyphSymbol(CharacterGlyphSymbol_<'a>),
    CharacterizedClass(CharacterizedClass_<'a>),
    CharacterizedObject(CharacterizedObject_<'a>),
    Circle(Circle_<'a>),
    CircularClosedProfile(CircularClosedProfile_<'a>),
    CircularPattern(CircularPattern_<'a>),
    CircularRunoutTolerance(CircularRunoutTolerance_<'a>),
    Class(Class_<'a>),
    ClassSystem(ClassSystem_<'a>),
    ClassUsageEffectivityContextAssignment(ClassUsageEffectivityContextAssignment_<'a>),
    ClassificationAssignment(ClassificationAssignment_<'a>),
    ClassificationRole(ClassificationRole_<'a>),
    ClosedPathProfile(ClosedPathProfile_<'a>),
    ClosedShell(ClosedShell_<'a>),
    CoaxialityTolerance(CoaxialityTolerance_<'a>),
    Colour(Colour_<'a>),
    ColourRgb(ColourRgb_<'a>),
    ColourSpecification(ColourSpecification_<'a>),
    CommonDatum(CommonDatum_<'a>),
    ComparisonEqual(ComparisonEqual_<'a>),
    ComparisonExpression(ComparisonExpression_<'a>),
    ComparisonGreater(ComparisonGreater_<'a>),
    ComparisonGreaterEqual(ComparisonGreaterEqual_<'a>),
    ComparisonLess(ComparisonLess_<'a>),
    ComparisonLessEqual(ComparisonLessEqual_<'a>),
    ComparisonNotEqual(ComparisonNotEqual_<'a>),
    CompositeCurve(CompositeCurve_<'a>),
    CompositeCurveOnSurface(CompositeCurveOnSurface_<'a>),
    CompositeCurveSegment(CompositeCurveSegment_<'a>),
    CompositeHole(CompositeHole_<'a>),
    CompositeShapeAspect(CompositeShapeAspect_<'a>),
    CompositeText(CompositeText_<'a>),
    CompositeTextWithAssociatedCurves(CompositeTextWithAssociatedCurves_<'a>),
    CompositeTextWithBlankingBox(CompositeTextWithBlankingBox_<'a>),
    CompositeTextWithExtent(CompositeTextWithExtent_<'a>),
    CompoundFeature(CompoundFeature_<'a>),
    CompoundRepresentationItem(CompoundRepresentationItem_<'a>),
    CompoundShapeRepresentation(CompoundShapeRepresentation_<'a>),
    ConcatExpression(ConcatExpression_<'a>),
    ConcentricityTolerance(ConcentricityTolerance_<'a>),
    ConceptFeatureOperator(ConceptFeatureOperator_<'a>),
    ConceptFeatureRelationship(ConceptFeatureRelationship_<'a>),
    ConceptFeatureRelationshipWithCondition(ConceptFeatureRelationshipWithCondition_<'a>),
    ConditionalConceptFeature(ConditionalConceptFeature_<'a>),
    ConfigurableItem(ConfigurableItem_<'a>),
    ConfigurationDefinition(ConfigurationDefinition_<'a>),
    ConfigurationDesign(ConfigurationDesign_<'a>),
    ConfigurationEffectivity(ConfigurationEffectivity_<'a>),
    ConfigurationInterpolation(ConfigurationInterpolation_<'a>),
    ConfigurationItem(ConfigurationItem_<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment_<'a>),
    ConfiguredEffectivityContextAssignment(ConfiguredEffectivityContextAssignment_<'a>),
    Conic(Conic_<'a>),
    ConicalSurface(ConicalSurface_<'a>),
    ConnectedEdgeSet(ConnectedEdgeSet_<'a>),
    ConnectedFaceSet(ConnectedFaceSet_<'a>),
    ConnectedFaceSubSet(ConnectedFaceSubSet_<'a>),
    ConstructiveGeometryRepresentation(ConstructiveGeometryRepresentation_<'a>),
    ConstructiveGeometryRepresentationRelationship(ConstructiveGeometryRepresentationRelationship_<'a>),
    ContactRatioRepresentation(ContactRatioRepresentation_<'a>),
    ContextDependentInvisibility(ContextDependentInvisibility_<'a>),
    ContextDependentOverRidingStyledItem(ContextDependentOverRidingStyledItem_<'a>),
    ContextDependentShapeRepresentation(ContextDependentShapeRepresentation_<'a>),
    ContextDependentUnit(ContextDependentUnit_<'a>),
    Contract(Contract_<'a>),
    ContractAssignment(ContractAssignment_<'a>),
    ContractType(ContractType_<'a>),
    ConversionBasedUnit(ConversionBasedUnit_<'a>),
    CoordinatedUniversalTimeOffset(CoordinatedUniversalTimeOffset_<'a>),
    CosFunction(CosFunction_<'a>),
    CsgShapeRepresentation(CsgShapeRepresentation_<'a>),
    CsgSolid(CsgSolid_<'a>),
    Curve(Curve_<'a>),
    CurveBoundedSurface(CurveBoundedSurface_<'a>),
    CurveDimension(CurveDimension_<'a>),
    CurveReplica(CurveReplica_<'a>),
    CurveStyle(CurveStyle_<'a>),
    CurveStyleFont(CurveStyleFont_<'a>),
    CurveStyleFontPattern(CurveStyleFontPattern_<'a>),
    CurveStyleRendering(CurveStyleRendering_<'a>),
    CurveSweptSolidShapeRepresentation(CurveSweptSolidShapeRepresentation_<'a>),
    CylindricalPair(CylindricalPair_<'a>),
    CylindricalPairRange(CylindricalPairRange_<'a>),
    CylindricalPairValue(CylindricalPairValue_<'a>),
    CylindricalSurface(CylindricalSurface_<'a>),
    CylindricityTolerance(CylindricityTolerance_<'a>),
    DataEnvironment(DataEnvironment_<'a>),
    Date(Date_<'a>),
    DateAndTime(DateAndTime_<'a>),
    DateAndTimeAssignment(DateAndTimeAssignment_<'a>),
    DateAssignment(DateAssignment_<'a>),
    DateRole(DateRole_<'a>),
    DateTimeRole(DateTimeRole_<'a>),
    DatedEffectivity(DatedEffectivity_<'a>),
    Datum(Datum_<'a>),
    DatumFeature(DatumFeature_<'a>),
    DatumFeatureCallout(DatumFeatureCallout_<'a>),
    DatumReference(DatumReference_<'a>),
    DatumTarget(DatumTarget_<'a>),
    DatumTargetCallout(DatumTargetCallout_<'a>),
    DefaultToleranceTable(DefaultToleranceTable_<'a>),
    DefaultToleranceTableCell(DefaultToleranceTableCell_<'a>),
    DefinedCharacterGlyph(DefinedCharacterGlyph_<'a>),
    DefinedFunction(DefinedFunction_<'a>),
    DefinedSymbol(DefinedSymbol_<'a>),
    DefinitionalRepresentation(DefinitionalRepresentation_<'a>),
    DegeneratePcurve(DegeneratePcurve_<'a>),
    DegenerateToroidalSurface(DegenerateToroidalSurface_<'a>),
    DerivedShapeAspect(DerivedShapeAspect_<'a>),
    DerivedUnit(DerivedUnit_<'a>),
    DerivedUnitElement(DerivedUnitElement_<'a>),
    DerivedUnitVariable(DerivedUnitVariable_<'a>),
    DescriptionAttribute(DescriptionAttribute_<'a>),
    DescriptiveRepresentationItem(DescriptiveRepresentationItem_<'a>),
    DiameterDimension(DiameterDimension_<'a>),
    DimensionCallout(DimensionCallout_<'a>),
    DimensionCalloutComponentRelationship(DimensionCalloutComponentRelationship_<'a>),
    DimensionCalloutRelationship(DimensionCalloutRelationship_<'a>),
    DimensionCurve(DimensionCurve_<'a>),
    DimensionCurveDirectedCallout(DimensionCurveDirectedCallout_<'a>),
    DimensionCurveTerminator(DimensionCurveTerminator_<'a>),
    DimensionPair(DimensionPair_<'a>),
    DimensionRelatedToleranceZoneElement(DimensionRelatedToleranceZoneElement_<'a>),
    DimensionTextAssociativity(DimensionTextAssociativity_<'a>),
    DimensionalCharacteristicRepresentation(DimensionalCharacteristicRepresentation_<'a>),
    DimensionalExponents(DimensionalExponents_<'a>),
    DimensionalLocation(DimensionalLocation_<'a>),
    DimensionalLocationWithPath(DimensionalLocationWithPath_<'a>),
    DimensionalSize(DimensionalSize_<'a>),
    DimensionalSizeWithPath(DimensionalSizeWithPath_<'a>),
    DirectedAction(DirectedAction_<'a>),
    DirectedAngle(DirectedAngle_<'a>),
    DirectedDimensionalLocation(DirectedDimensionalLocation_<'a>),
    Direction(Direction_<'a>),
    DirectionShapeRepresentation(DirectionShapeRepresentation_<'a>),
    DivExpression(DivExpression_<'a>),
    Document(Document_<'a>),
    DocumentFile(DocumentFile_<'a>),
    DocumentProductAssociation(DocumentProductAssociation_<'a>),
    DocumentProductEquivalence(DocumentProductEquivalence_<'a>),
    DocumentReference(DocumentReference_<'a>),
    DocumentRelationship(DocumentRelationship_<'a>),
    DocumentRepresentationType(DocumentRepresentationType_<'a>),
    DocumentType(DocumentType_<'a>),
    DocumentUsageConstraint(DocumentUsageConstraint_<'a>),
    DocumentUsageConstraintAssignment(DocumentUsageConstraintAssignment_<'a>),
    DocumentUsageRole(DocumentUsageRole_<'a>),
    DraughtingAnnotationOccurrence(DraughtingAnnotationOccurrence_<'a>),
    DraughtingCallout(DraughtingCallout_<'a>),
    DraughtingCalloutRelationship(DraughtingCalloutRelationship_<'a>),
    DraughtingElements(DraughtingElements_<'a>),
    DraughtingModel(DraughtingModel_<'a>),
    DraughtingModelItemAssociation(DraughtingModelItemAssociation_<'a>),
    DraughtingPreDefinedColour(DraughtingPreDefinedColour_<'a>),
    DraughtingPreDefinedCurveFont(DraughtingPreDefinedCurveFont_<'a>),
    DraughtingPreDefinedTextFont(DraughtingPreDefinedTextFont_<'a>),
    DraughtingSpecificationReference(DraughtingSpecificationReference_<'a>),
    DraughtingSubfigureRepresentation(DraughtingSubfigureRepresentation_<'a>),
    DraughtingSymbolRepresentation(DraughtingSymbolRepresentation_<'a>),
    DraughtingTextLiteralWithDelineation(DraughtingTextLiteralWithDelineation_<'a>),
    DraughtingTitle(DraughtingTitle_<'a>),
    DrawingDefinition(DrawingDefinition_<'a>),
    DrawingRevision(DrawingRevision_<'a>),
    DrawingRevisionSequence(DrawingRevisionSequence_<'a>),
    DrawingSheetLayout(DrawingSheetLayout_<'a>),
    DrawingSheetRevision(DrawingSheetRevision_<'a>),
    DrawingSheetRevisionUsage(DrawingSheetRevisionUsage_<'a>),
    Edge(Edge_<'a>),
    EdgeBasedWireframeModel(EdgeBasedWireframeModel_<'a>),
    EdgeBasedWireframeShapeRepresentation(EdgeBasedWireframeShapeRepresentation_<'a>),
    EdgeCurve(EdgeCurve_<'a>),
    EdgeLoop(EdgeLoop_<'a>),
    EdgeRound(EdgeRound_<'a>),
    Effectivity(Effectivity_<'a>),
    EffectivityAssignment(EffectivityAssignment_<'a>),
    EffectivityContextAssignment(EffectivityContextAssignment_<'a>),
    EffectivityContextRole(EffectivityContextRole_<'a>),
    EffectivityRelationship(EffectivityRelationship_<'a>),
    ElectricCurrentMeasureWithUnit(ElectricCurrentMeasureWithUnit_<'a>),
    ElectricCurrentUnit(ElectricCurrentUnit_<'a>),
    ElementDelivery(ElementDelivery_<'a>),
    ElementarySurface(ElementarySurface_<'a>),
    Ellipse(Ellipse_<'a>),
    Environment(Environment_<'a>),
    EqualsExpression(EqualsExpression_<'a>),
    EvaluatedDegeneratePcurve(EvaluatedDegeneratePcurve_<'a>),
    EventOccurrence(EventOccurrence_<'a>),
    EventOccurrenceAssignment(EventOccurrenceAssignment_<'a>),
    EventOccurrenceContextAssignment(EventOccurrenceContextAssignment_<'a>),
    EventOccurrenceContextRole(EventOccurrenceContextRole_<'a>),
    EventOccurrenceRole(EventOccurrenceRole_<'a>),
    ExclusiveProductConceptFeatureCategory(ExclusiveProductConceptFeatureCategory_<'a>),
    ExecutedAction(ExecutedAction_<'a>),
    ExpFunction(ExpFunction_<'a>),
    Expression(Expression_<'a>),
    ExpressionConversionBasedUnit(ExpressionConversionBasedUnit_<'a>),
    Extension(Extension_<'a>),
    ExternalIdentificationAssignment(ExternalIdentificationAssignment_<'a>),
    ExternalSource(ExternalSource_<'a>),
    ExternallyDefinedCharacterGlyph(ExternallyDefinedCharacterGlyph_<'a>),
    ExternallyDefinedClass(ExternallyDefinedClass_<'a>),
    ExternallyDefinedCurveFont(ExternallyDefinedCurveFont_<'a>),
    ExternallyDefinedDimensionDefinition(ExternallyDefinedDimensionDefinition_<'a>),
    ExternallyDefinedFeatureDefinition(ExternallyDefinedFeatureDefinition_<'a>),
    ExternallyDefinedGeneralProperty(ExternallyDefinedGeneralProperty_<'a>),
    ExternallyDefinedHatchStyle(ExternallyDefinedHatchStyle_<'a>),
    ExternallyDefinedItem(ExternallyDefinedItem_<'a>),
    ExternallyDefinedItemRelationship(ExternallyDefinedItemRelationship_<'a>),
    ExternallyDefinedStyle(ExternallyDefinedStyle_<'a>),
    ExternallyDefinedSymbol(ExternallyDefinedSymbol_<'a>),
    ExternallyDefinedTextFont(ExternallyDefinedTextFont_<'a>),
    ExternallyDefinedTileStyle(ExternallyDefinedTileStyle_<'a>),
    ExtrudedAreaSolid(ExtrudedAreaSolid_<'a>),
    ExtrudedFaceSolid(ExtrudedFaceSolid_<'a>),
    Face(Face_<'a>),
    FaceBasedSurfaceModel(FaceBasedSurfaceModel_<'a>),
    FaceBound(FaceBound_<'a>),
    FaceOuterBound(FaceOuterBound_<'a>),
    FaceShapeRepresentation(FaceShapeRepresentation_<'a>),
    FaceSurface(FaceSurface_<'a>),
    FacetedBrep(FacetedBrep_<'a>),
    FacetedBrepShapeRepresentation(FacetedBrepShapeRepresentation_<'a>),
    FeatureComponentDefinition(FeatureComponentDefinition_<'a>),
    FeatureComponentRelationship(FeatureComponentRelationship_<'a>),
    FeatureDefinition(FeatureDefinition_<'a>),
    FeatureInPanel(FeatureInPanel_<'a>),
    FeaturePattern(FeaturePattern_<'a>),
    FeaturedShape(FeaturedShape_<'a>),
    FillAreaStyle(FillAreaStyle_<'a>),
    FillAreaStyleColour(FillAreaStyleColour_<'a>),
    FillAreaStyleHatching(FillAreaStyleHatching_<'a>),
    FillAreaStyleTileSymbolWithStyle(FillAreaStyleTileSymbolWithStyle_<'a>),
    FillAreaStyleTiles(FillAreaStyleTiles_<'a>),
    Fillet(Fillet_<'a>),
    FlatnessTolerance(FlatnessTolerance_<'a>),
    FormatFunction(FormatFunction_<'a>),
    FoundedItem(FoundedItem_<'a>),
    FoundedKinematicPath(FoundedKinematicPath_<'a>),
    FullyConstrainedPair(FullyConstrainedPair_<'a>),
    FunctionallyDefinedTransformation(FunctionallyDefinedTransformation_<'a>),
    GearPair(GearPair_<'a>),
    GearPairRange(GearPairRange_<'a>),
    GearPairValue(GearPairValue_<'a>),
    GeneralFeature(GeneralFeature_<'a>),
    GeneralMaterialProperty(GeneralMaterialProperty_<'a>),
    GeneralProperty(GeneralProperty_<'a>),
    GeneralPropertyAssociation(GeneralPropertyAssociation_<'a>),
    GeneralPropertyRelationship(GeneralPropertyRelationship_<'a>),
    GenericCharacterGlyphSymbol(GenericCharacterGlyphSymbol_<'a>),
    GenericExpression(GenericExpression_<'a>),
    GenericLiteral(GenericLiteral_<'a>),
    GenericVariable(GenericVariable_<'a>),
    GeometricAlignment(GeometricAlignment_<'a>),
    GeometricCurveSet(GeometricCurveSet_<'a>),
    GeometricIntersection(GeometricIntersection_<'a>),
    GeometricItemSpecificUsage(GeometricItemSpecificUsage_<'a>),
    GeometricRepresentationContext(GeometricRepresentationContext_<'a>),
    GeometricRepresentationItem(GeometricRepresentationItem_<'a>),
    GeometricSet(GeometricSet_<'a>),
    GeometricTolerance(GeometricTolerance_<'a>),
    GeometricToleranceRelationship(GeometricToleranceRelationship_<'a>),
    GeometricToleranceWithDatumReference(GeometricToleranceWithDatumReference_<'a>),
    GeometricToleranceWithDefinedUnit(GeometricToleranceWithDefinedUnit_<'a>),
    GeometricalToleranceCallout(GeometricalToleranceCallout_<'a>),
    GeometricallyBounded2dWireframeRepresentation(GeometricallyBounded2dWireframeRepresentation_<'a>),
    GeometricallyBoundedSurfaceShapeRepresentation(GeometricallyBoundedSurfaceShapeRepresentation_<'a>),
    GeometricallyBoundedWireframeShapeRepresentation(GeometricallyBoundedWireframeShapeRepresentation_<'a>),
    GlobalUncertaintyAssignedContext(GlobalUncertaintyAssignedContext_<'a>),
    GlobalUnitAssignedContext(GlobalUnitAssignedContext_<'a>),
    Group(Group_<'a>),
    GroupAssignment(GroupAssignment_<'a>),
    GroupRelationship(GroupRelationship_<'a>),
    HalfSpaceSolid(HalfSpaceSolid_<'a>),
    HardnessRepresentation(HardnessRepresentation_<'a>),
    HiddenElementOverRidingStyledItem(HiddenElementOverRidingStyledItem_<'a>),
    HoleBottom(HoleBottom_<'a>),
    HoleInPanel(HoleInPanel_<'a>),
    HomokineticPair(HomokineticPair_<'a>),
    Hyperbola(Hyperbola_<'a>),
    IdAttribute(IdAttribute_<'a>),
    IdentificationAssignment(IdentificationAssignment_<'a>),
    IdentificationRole(IdentificationRole_<'a>),
    InclusionProductConceptFeature(InclusionProductConceptFeature_<'a>),
    IndexExpression(IndexExpression_<'a>),
    InitialState(InitialState_<'a>),
    InstancedFeature(InstancedFeature_<'a>),
    IntLiteral(IntLiteral_<'a>),
    IntNumericVariable(IntNumericVariable_<'a>),
    IntValueFunction(IntValueFunction_<'a>),
    IntegerDefinedFunction(IntegerDefinedFunction_<'a>),
    InterpolatedConfigurationSequence(InterpolatedConfigurationSequence_<'a>),
    IntersectionCurve(IntersectionCurve_<'a>),
    IntervalExpression(IntervalExpression_<'a>),
    Invisibility(Invisibility_<'a>),
    ItemDefinedTransformation(ItemDefinedTransformation_<'a>),
    ItemIdentifiedRepresentationUsage(ItemIdentifiedRepresentationUsage_<'a>),
    Joggle(Joggle_<'a>),
    JoggleTermination(JoggleTermination_<'a>),
    KinematicAnalysisConsistency(KinematicAnalysisConsistency_<'a>),
    KinematicAnalysisResult(KinematicAnalysisResult_<'a>),
    KinematicControl(KinematicControl_<'a>),
    KinematicFrameBackgroundRepresentation(KinematicFrameBackgroundRepresentation_<'a>),
    KinematicFrameBackgroundRepresentationAssociation(KinematicFrameBackgroundRepresentationAssociation_<'a>),
    KinematicFrameBasedTransformation(KinematicFrameBasedTransformation_<'a>),
    KinematicGroundRepresentation(KinematicGroundRepresentation_<'a>),
    KinematicJoint(KinematicJoint_<'a>),
    KinematicLink(KinematicLink_<'a>),
    KinematicLinkRepresentation(KinematicLinkRepresentation_<'a>),
    KinematicLinkRepresentationAssociation(KinematicLinkRepresentationAssociation_<'a>),
    KinematicLinkRepresentationRelation(KinematicLinkRepresentationRelation_<'a>),
    KinematicPair(KinematicPair_<'a>),
    KinematicPath(KinematicPath_<'a>),
    KinematicPropertyDefinition(KinematicPropertyDefinition_<'a>),
    KinematicPropertyRepresentationRelation(KinematicPropertyRepresentationRelation_<'a>),
    KinematicStructure(KinematicStructure_<'a>),
    KnownSource(KnownSource_<'a>),
    Language(Language_<'a>),
    LanguageAssignment(LanguageAssignment_<'a>),
    LeaderCurve(LeaderCurve_<'a>),
    LeaderDirectedCallout(LeaderDirectedCallout_<'a>),
    LeaderDirectedDimension(LeaderDirectedDimension_<'a>),
    LeaderTerminator(LeaderTerminator_<'a>),
    LengthFunction(LengthFunction_<'a>),
    LengthMeasureWithUnit(LengthMeasureWithUnit_<'a>),
    LengthUnit(LengthUnit_<'a>),
    LightSource(LightSource_<'a>),
    LightSourceAmbient(LightSourceAmbient_<'a>),
    LightSourceDirectional(LightSourceDirectional_<'a>),
    LightSourcePositional(LightSourcePositional_<'a>),
    LightSourceSpot(LightSourceSpot_<'a>),
    LikeExpression(LikeExpression_<'a>),
    LimitsAndFits(LimitsAndFits_<'a>),
    Line(Line_<'a>),
    LineProfileTolerance(LineProfileTolerance_<'a>),
    LinearDimension(LinearDimension_<'a>),
    LiteralNumber(LiteralNumber_<'a>),
    LocalTime(LocalTime_<'a>),
    LocationShapeRepresentation(LocationShapeRepresentation_<'a>),
    Locator(Locator_<'a>),
    Log10Function(Log10Function_<'a>),
    Log2Function(Log2Function_<'a>),
    LogFunction(LogFunction_<'a>),
    Loop(Loop_<'a>),
    LotEffectivity(LotEffectivity_<'a>),
    LuminousIntensityMeasureWithUnit(LuminousIntensityMeasureWithUnit_<'a>),
    LuminousIntensityUnit(LuminousIntensityUnit_<'a>),
    MakeFromUsageOption(MakeFromUsageOption_<'a>),
    ManifoldSolidBrep(ManifoldSolidBrep_<'a>),
    ManifoldSubsurfaceShapeRepresentation(ManifoldSubsurfaceShapeRepresentation_<'a>),
    ManifoldSurfaceShapeRepresentation(ManifoldSurfaceShapeRepresentation_<'a>),
    MappedItem(MappedItem_<'a>),
    MassMeasureWithUnit(MassMeasureWithUnit_<'a>),
    MassUnit(MassUnit_<'a>),
    MaterialDesignation(MaterialDesignation_<'a>),
    MaterialDesignationCharacterization(MaterialDesignationCharacterization_<'a>),
    MaterialProperty(MaterialProperty_<'a>),
    MaterialPropertyRepresentation(MaterialPropertyRepresentation_<'a>),
    MaximumFunction(MaximumFunction_<'a>),
    MeasureQualification(MeasureQualification_<'a>),
    MeasureRepresentationItem(MeasureRepresentationItem_<'a>),
    MeasureWithUnit(MeasureWithUnit_<'a>),
    MechanicalDesignGeometricPresentationArea(MechanicalDesignGeometricPresentationArea_<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation_<'a>),
    Mechanism(Mechanism_<'a>),
    MechanismBasePlacement(MechanismBasePlacement_<'a>),
    MinimumFunction(MinimumFunction_<'a>),
    MinusExpression(MinusExpression_<'a>),
    MinusFunction(MinusFunction_<'a>),
    ModExpression(ModExpression_<'a>),
    ModifiedGeometricTolerance(ModifiedGeometricTolerance_<'a>),
    ModifiedPattern(ModifiedPattern_<'a>),
    MomentsOfInertiaRepresentation(MomentsOfInertiaRepresentation_<'a>),
    MotionLinkRelationship(MotionLinkRelationship_<'a>),
    MultExpression(MultExpression_<'a>),
    MultiLanguageAttributeAssignment(MultiLanguageAttributeAssignment_<'a>),
    MultipleArityBooleanExpression(MultipleArityBooleanExpression_<'a>),
    MultipleArityFunctionCall(MultipleArityFunctionCall_<'a>),
    MultipleArityGenericExpression(MultipleArityGenericExpression_<'a>),
    MultipleArityNumericExpression(MultipleArityNumericExpression_<'a>),
    NameAssignment(NameAssignment_<'a>),
    NameAttribute(NameAttribute_<'a>),
    NamedUnit(NamedUnit_<'a>),
    NamedUnitVariable(NamedUnitVariable_<'a>),
    NextAssemblyUsageOccurrence(NextAssemblyUsageOccurrence_<'a>),
    NgonClosedProfile(NgonClosedProfile_<'a>),
    NonManifoldSurfaceShapeRepresentation(NonManifoldSurfaceShapeRepresentation_<'a>),
    NotExpression(NotExpression_<'a>),
    NumericDefinedFunction(NumericDefinedFunction_<'a>),
    NumericExpression(NumericExpression_<'a>),
    NumericVariable(NumericVariable_<'a>),
    ObjectRole(ObjectRole_<'a>),
    OddFunction(OddFunction_<'a>),
    OffsetCurve2d(OffsetCurve2d_<'a>),
    OffsetCurve3d(OffsetCurve3d_<'a>),
    OffsetSurface(OffsetSurface_<'a>),
    OneDirectionRepeatFactor(OneDirectionRepeatFactor_<'a>),
    OpenPathProfile(OpenPathProfile_<'a>),
    OpenShell(OpenShell_<'a>),
    OrExpression(OrExpression_<'a>),
    OrdinateDimension(OrdinateDimension_<'a>),
    Organization(Organization_<'a>),
    OrganizationAssignment(OrganizationAssignment_<'a>),
    OrganizationRelationship(OrganizationRelationship_<'a>),
    OrganizationRole(OrganizationRole_<'a>),
    OrganizationalAddress(OrganizationalAddress_<'a>),
    OrganizationalProject(OrganizationalProject_<'a>),
    OrganizationalProjectAssignment(OrganizationalProjectAssignment_<'a>),
    OrganizationalProjectRelationship(OrganizationalProjectRelationship_<'a>),
    OrganizationalProjectRole(OrganizationalProjectRole_<'a>),
    OrientedClosedShell(OrientedClosedShell_<'a>),
    OrientedEdge(OrientedEdge_<'a>),
    OrientedFace(OrientedFace_<'a>),
    OrientedOpenShell(OrientedOpenShell_<'a>),
    OrientedPath(OrientedPath_<'a>),
    OrientedSurface(OrientedSurface_<'a>),
    OuterBoundaryCurve(OuterBoundaryCurve_<'a>),
    OverRidingStyledItem(OverRidingStyledItem_<'a>),
    PackageProductConceptFeature(PackageProductConceptFeature_<'a>),
    PairActuator(PairActuator_<'a>),
    PairValue(PairValue_<'a>),
    Parabola(Parabola_<'a>),
    ParallelOffset(ParallelOffset_<'a>),
    ParallelismTolerance(ParallelismTolerance_<'a>),
    ParametricRepresentationContext(ParametricRepresentationContext_<'a>),
    PartialCircularProfile(PartialCircularProfile_<'a>),
    Path(Path_<'a>),
    PathFeatureComponent(PathFeatureComponent_<'a>),
    PathShapeRepresentation(PathShapeRepresentation_<'a>),
    PatternOffsetMembership(PatternOffsetMembership_<'a>),
    PatternOmitMembership(PatternOmitMembership_<'a>),
    Pcurve(Pcurve_<'a>),
    PerpendicularTo(PerpendicularTo_<'a>),
    PerpendicularityTolerance(PerpendicularityTolerance_<'a>),
    Person(Person_<'a>),
    PersonAndOrganization(PersonAndOrganization_<'a>),
    PersonAndOrganizationAddress(PersonAndOrganizationAddress_<'a>),
    PersonAndOrganizationAssignment(PersonAndOrganizationAssignment_<'a>),
    PersonAndOrganizationRole(PersonAndOrganizationRole_<'a>),
    PersonalAddress(PersonalAddress_<'a>),
    PhysicallyModelledProductDefinition(PhysicallyModelledProductDefinition_<'a>),
    PlacedDatumTargetFeature(PlacedDatumTargetFeature_<'a>),
    PlacedFeature(PlacedFeature_<'a>),
    Placement(Placement_<'a>),
    PlanarBox(PlanarBox_<'a>),
    PlanarCurvePair(PlanarCurvePair_<'a>),
    PlanarCurvePairRange(PlanarCurvePairRange_<'a>),
    PlanarExtent(PlanarExtent_<'a>),
    PlanarPair(PlanarPair_<'a>),
    PlanarPairRange(PlanarPairRange_<'a>),
    PlanarPairValue(PlanarPairValue_<'a>),
    PlanarShapeRepresentation(PlanarShapeRepresentation_<'a>),
    Plane(Plane_<'a>),
    PlaneAngleMeasureWithUnit(PlaneAngleMeasureWithUnit_<'a>),
    PlaneAngleUnit(PlaneAngleUnit_<'a>),
    PlusExpression(PlusExpression_<'a>),
    PlusMinusTolerance(PlusMinusTolerance_<'a>),
    Pocket(Pocket_<'a>),
    PocketBottom(PocketBottom_<'a>),
    Point(Point_<'a>),
    PointOnCurve(PointOnCurve_<'a>),
    PointOnPlanarCurvePair(PointOnPlanarCurvePair_<'a>),
    PointOnPlanarCurvePairRange(PointOnPlanarCurvePairRange_<'a>),
    PointOnPlanarCurvePairValue(PointOnPlanarCurvePairValue_<'a>),
    PointOnSurface(PointOnSurface_<'a>),
    PointOnSurfacePair(PointOnSurfacePair_<'a>),
    PointOnSurfacePairRange(PointOnSurfacePairRange_<'a>),
    PointOnSurfacePairValue(PointOnSurfacePairValue_<'a>),
    PointPlacementShapeRepresentation(PointPlacementShapeRepresentation_<'a>),
    PointReplica(PointReplica_<'a>),
    PointStyle(PointStyle_<'a>),
    PolyLoop(PolyLoop_<'a>),
    Polyline(Polyline_<'a>),
    PositionTolerance(PositionTolerance_<'a>),
    PowerExpression(PowerExpression_<'a>),
    PreDefinedColour(PreDefinedColour_<'a>),
    PreDefinedCurveFont(PreDefinedCurveFont_<'a>),
    PreDefinedDimensionSymbol(PreDefinedDimensionSymbol_<'a>),
    PreDefinedGeometricalToleranceSymbol(PreDefinedGeometricalToleranceSymbol_<'a>),
    PreDefinedItem(PreDefinedItem_<'a>),
    PreDefinedMarker(PreDefinedMarker_<'a>),
    PreDefinedPointMarkerSymbol(PreDefinedPointMarkerSymbol_<'a>),
    PreDefinedPresentationStyle(PreDefinedPresentationStyle_<'a>),
    PreDefinedSurfaceConditionSymbol(PreDefinedSurfaceConditionSymbol_<'a>),
    PreDefinedSymbol(PreDefinedSymbol_<'a>),
    PreDefinedTerminatorSymbol(PreDefinedTerminatorSymbol_<'a>),
    PreDefinedTextFont(PreDefinedTextFont_<'a>),
    PrecisionQualifier(PrecisionQualifier_<'a>),
    PresentationArea(PresentationArea_<'a>),
    PresentationLayerAssignment(PresentationLayerAssignment_<'a>),
    PresentationRepresentation(PresentationRepresentation_<'a>),
    PresentationSet(PresentationSet_<'a>),
    PresentationSize(PresentationSize_<'a>),
    PresentationStyleAssignment(PresentationStyleAssignment_<'a>),
    PresentationStyleByContext(PresentationStyleByContext_<'a>),
    PresentationView(PresentationView_<'a>),
    PresentedItem(PresentedItem_<'a>),
    PresentedItemRepresentation(PresentedItemRepresentation_<'a>),
    PrismaticPair(PrismaticPair_<'a>),
    PrismaticPairRange(PrismaticPairRange_<'a>),
    PrismaticPairValue(PrismaticPairValue_<'a>),
    ProcessOperation(ProcessOperation_<'a>),
    ProcessPlan(ProcessPlan_<'a>),
    ProcessProductAssociation(ProcessProductAssociation_<'a>),
    ProcessPropertyAssociation(ProcessPropertyAssociation_<'a>),
    Product(Product_<'a>),
    ProductCategory(ProductCategory_<'a>),
    ProductCategoryRelationship(ProductCategoryRelationship_<'a>),
    ProductClass(ProductClass_<'a>),
    ProductConcept(ProductConcept_<'a>),
    ProductConceptContext(ProductConceptContext_<'a>),
    ProductConceptFeature(ProductConceptFeature_<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation_<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory_<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage_<'a>),
    ProductConceptRelationship(ProductConceptRelationship_<'a>),
    ProductContext(ProductContext_<'a>),
    ProductDefinition(ProductDefinition_<'a>),
    ProductDefinitionContext(ProductDefinitionContext_<'a>),
    ProductDefinitionContextAssociation(ProductDefinitionContextAssociation_<'a>),
    ProductDefinitionContextRole(ProductDefinitionContextRole_<'a>),
    ProductDefinitionEffectivity(ProductDefinitionEffectivity_<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation_<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship_<'a>),
    ProductDefinitionFormationWithSpecifiedSource(ProductDefinitionFormationWithSpecifiedSource_<'a>),
    ProductDefinitionOccurrenceRelationship(ProductDefinitionOccurrenceRelationship_<'a>),
    ProductDefinitionProcess(ProductDefinitionProcess_<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship_<'a>),
    ProductDefinitionResource(ProductDefinitionResource_<'a>),
    ProductDefinitionShape(ProductDefinitionShape_<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute_<'a>),
    ProductDefinitionUsage(ProductDefinitionUsage_<'a>),
    ProductDefinitionWithAssociatedDocuments(ProductDefinitionWithAssociatedDocuments_<'a>),
    ProductIdentification(ProductIdentification_<'a>),
    ProductProcessPlan(ProductProcessPlan_<'a>),
    ProductRelatedProductCategory(ProductRelatedProductCategory_<'a>),
    ProductSpecification(ProductSpecification_<'a>),
    ProjectedZoneDefinition(ProjectedZoneDefinition_<'a>),
    ProjectionCurve(ProjectionCurve_<'a>),
    ProjectionDirectedCallout(ProjectionDirectedCallout_<'a>),
    PromissoryUsageOccurrence(PromissoryUsageOccurrence_<'a>),
    PropertyDefinition(PropertyDefinition_<'a>),
    PropertyDefinitionRelationship(PropertyDefinitionRelationship_<'a>),
    PropertyDefinitionRepresentation(PropertyDefinitionRepresentation_<'a>),
    PropertyProcess(PropertyProcess_<'a>),
    QualifiedRepresentationItem(QualifiedRepresentationItem_<'a>),
    QualitativeUncertainty(QualitativeUncertainty_<'a>),
    QuantifiedAssemblyComponentUsage(QuantifiedAssemblyComponentUsage_<'a>),
    QuasiUniformCurve(QuasiUniformCurve_<'a>),
    QuasiUniformSurface(QuasiUniformSurface_<'a>),
    RackAndPinionPair(RackAndPinionPair_<'a>),
    RackAndPinionPairRange(RackAndPinionPairRange_<'a>),
    RackAndPinionPairValue(RackAndPinionPairValue_<'a>),
    RadiusDimension(RadiusDimension_<'a>),
    RatioMeasureWithUnit(RatioMeasureWithUnit_<'a>),
    RatioUnit(RatioUnit_<'a>),
    RationalBSplineCurve(RationalBSplineCurve_<'a>),
    RationalBSplineSurface(RationalBSplineSurface_<'a>),
    RealDefinedFunction(RealDefinedFunction_<'a>),
    RealLiteral(RealLiteral_<'a>),
    RealNumericVariable(RealNumericVariable_<'a>),
    RectangularClosedProfile(RectangularClosedProfile_<'a>),
    RectangularCompositeSurface(RectangularCompositeSurface_<'a>),
    RectangularPattern(RectangularPattern_<'a>),
    RectangularTrimmedSurface(RectangularTrimmedSurface_<'a>),
    ReferencedModifiedDatum(ReferencedModifiedDatum_<'a>),
    RelativeEventOccurrence(RelativeEventOccurrence_<'a>),
    RepItemGroup(RepItemGroup_<'a>),
    ReparametrisedCompositeCurveSegment(ReparametrisedCompositeCurveSegment_<'a>),
    ReplicateFeature(ReplicateFeature_<'a>),
    Representation(Representation_<'a>),
    RepresentationContext(RepresentationContext_<'a>),
    RepresentationItem(RepresentationItem_<'a>),
    RepresentationMap(RepresentationMap_<'a>),
    RepresentationRelationship(RepresentationRelationship_<'a>),
    RepresentationRelationshipWithTransformation(RepresentationRelationshipWithTransformation_<'a>),
    RequirementForActionResource(RequirementForActionResource_<'a>),
    ResourceProperty(ResourceProperty_<'a>),
    ResourcePropertyRepresentation(ResourcePropertyRepresentation_<'a>),
    ResourceRequirementType(ResourceRequirementType_<'a>),
    ResultingPath(ResultingPath_<'a>),
    Retention(Retention_<'a>),
    RevolutePair(RevolutePair_<'a>),
    RevolutePairRange(RevolutePairRange_<'a>),
    RevolutePairValue(RevolutePairValue_<'a>),
    RevolvedAreaSolid(RevolvedAreaSolid_<'a>),
    RevolvedFaceSolid(RevolvedFaceSolid_<'a>),
    Rib(Rib_<'a>),
    RightAngularWedge(RightAngularWedge_<'a>),
    RightCircularCone(RightCircularCone_<'a>),
    RightCircularCylinder(RightCircularCylinder_<'a>),
    RoleAssociation(RoleAssociation_<'a>),
    RollingCurvePair(RollingCurvePair_<'a>),
    RollingCurvePairValue(RollingCurvePairValue_<'a>),
    RollingSurfacePair(RollingSurfacePair_<'a>),
    RollingSurfacePairValue(RollingSurfacePairValue_<'a>),
    RotationAboutDirection(RotationAboutDirection_<'a>),
    RoundHole(RoundHole_<'a>),
    RoundedUProfile(RoundedUProfile_<'a>),
    RoundnessTolerance(RoundnessTolerance_<'a>),
    RuledSurfaceSweptAreaSolid(RuledSurfaceSweptAreaSolid_<'a>),
    RunoutZoneDefinition(RunoutZoneDefinition_<'a>),
    RunoutZoneOrientation(RunoutZoneOrientation_<'a>),
    RunoutZoneOrientationReferenceDirection(RunoutZoneOrientationReferenceDirection_<'a>),
    ScrewPair(ScrewPair_<'a>),
    ScrewPairRange(ScrewPairRange_<'a>),
    ScrewPairValue(ScrewPairValue_<'a>),
    SeamCurve(SeamCurve_<'a>),
    SeamEdge(SeamEdge_<'a>),
    SecurityClassification(SecurityClassification_<'a>),
    SecurityClassificationAssignment(SecurityClassificationAssignment_<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel_<'a>),
    SerialNumberedEffectivity(SerialNumberedEffectivity_<'a>),
    ShapeAspect(ShapeAspect_<'a>),
    ShapeAspectAssociativity(ShapeAspectAssociativity_<'a>),
    ShapeAspectDerivingRelationship(ShapeAspectDerivingRelationship_<'a>),
    ShapeAspectRelationship(ShapeAspectRelationship_<'a>),
    ShapeAspectTransition(ShapeAspectTransition_<'a>),
    ShapeDefiningRelationship(ShapeDefiningRelationship_<'a>),
    ShapeDefinitionRepresentation(ShapeDefinitionRepresentation_<'a>),
    ShapeDimensionRepresentation(ShapeDimensionRepresentation_<'a>),
    ShapeRepresentation(ShapeRepresentation_<'a>),
    ShapeRepresentationRelationship(ShapeRepresentationRelationship_<'a>),
    ShapeRepresentationWithParameters(ShapeRepresentationWithParameters_<'a>),
    ShellBasedSurfaceModel(ShellBasedSurfaceModel_<'a>),
    SiUnit(SiUnit_<'a>),
    SimpleBooleanExpression(SimpleBooleanExpression_<'a>),
    SimpleGenericExpression(SimpleGenericExpression_<'a>),
    SimpleNumericExpression(SimpleNumericExpression_<'a>),
    SimplePairRange(SimplePairRange_<'a>),
    SimpleStringExpression(SimpleStringExpression_<'a>),
    SinFunction(SinFunction_<'a>),
    SlashExpression(SlashExpression_<'a>),
    SlidingCurvePair(SlidingCurvePair_<'a>),
    SlidingCurvePairValue(SlidingCurvePairValue_<'a>),
    SlidingSurfacePair(SlidingSurfacePair_<'a>),
    SlidingSurfacePairValue(SlidingSurfacePairValue_<'a>),
    Slot(Slot_<'a>),
    SlotEnd(SlotEnd_<'a>),
    SolidAngleMeasureWithUnit(SolidAngleMeasureWithUnit_<'a>),
    SolidAngleUnit(SolidAngleUnit_<'a>),
    SolidModel(SolidModel_<'a>),
    SolidReplica(SolidReplica_<'a>),
    SpecifiedHigherUsageOccurrence(SpecifiedHigherUsageOccurrence_<'a>),
    Sphere(Sphere_<'a>),
    SphericalPair(SphericalPair_<'a>),
    SphericalPairRange(SphericalPairRange_<'a>),
    SphericalPairValue(SphericalPairValue_<'a>),
    SphericalSurface(SphericalSurface_<'a>),
    SqlMappableDefinedFunction(SqlMappableDefinedFunction_<'a>),
    SquareRootFunction(SquareRootFunction_<'a>),
    SquareUProfile(SquareUProfile_<'a>),
    StandardUncertainty(StandardUncertainty_<'a>),
    StraightnessTolerance(StraightnessTolerance_<'a>),
    StringDefinedFunction(StringDefinedFunction_<'a>),
    StringExpression(StringExpression_<'a>),
    StringLiteral(StringLiteral_<'a>),
    StringVariable(StringVariable_<'a>),
    StructuredDimensionCallout(StructuredDimensionCallout_<'a>),
    StyledItem(StyledItem_<'a>),
    Subedge(Subedge_<'a>),
    Subface(Subface_<'a>),
    SubstringExpression(SubstringExpression_<'a>),
    Surface(Surface_<'a>),
    SurfaceConditionCallout(SurfaceConditionCallout_<'a>),
    SurfaceCurve(SurfaceCurve_<'a>),
    SurfaceCurveSweptAreaSolid(SurfaceCurveSweptAreaSolid_<'a>),
    SurfaceOfLinearExtrusion(SurfaceOfLinearExtrusion_<'a>),
    SurfaceOfRevolution(SurfaceOfRevolution_<'a>),
    SurfacePair(SurfacePair_<'a>),
    SurfacePairRange(SurfacePairRange_<'a>),
    SurfacePatch(SurfacePatch_<'a>),
    SurfaceProfileTolerance(SurfaceProfileTolerance_<'a>),
    SurfaceRenderingProperties(SurfaceRenderingProperties_<'a>),
    SurfaceReplica(SurfaceReplica_<'a>),
    SurfaceSideStyle(SurfaceSideStyle_<'a>),
    SurfaceStyleBoundary(SurfaceStyleBoundary_<'a>),
    SurfaceStyleControlGrid(SurfaceStyleControlGrid_<'a>),
    SurfaceStyleFillArea(SurfaceStyleFillArea_<'a>),
    SurfaceStyleParameterLine(SurfaceStyleParameterLine_<'a>),
    SurfaceStyleReflectanceAmbient(SurfaceStyleReflectanceAmbient_<'a>),
    SurfaceStyleReflectanceAmbientDiffuse(SurfaceStyleReflectanceAmbientDiffuse_<'a>),
    SurfaceStyleReflectanceAmbientDiffuseSpecular(SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a>),
    SurfaceStyleRendering(SurfaceStyleRendering_<'a>),
    SurfaceStyleRenderingWithProperties(SurfaceStyleRenderingWithProperties_<'a>),
    SurfaceStyleSegmentationCurve(SurfaceStyleSegmentationCurve_<'a>),
    SurfaceStyleSilhouette(SurfaceStyleSilhouette_<'a>),
    SurfaceStyleTransparent(SurfaceStyleTransparent_<'a>),
    SurfaceStyleUsage(SurfaceStyleUsage_<'a>),
    SurfaceTextureRepresentation(SurfaceTextureRepresentation_<'a>),
    SweptAreaSolid(SweptAreaSolid_<'a>),
    SweptDiskSolid(SweptDiskSolid_<'a>),
    SweptFaceSolid(SweptFaceSolid_<'a>),
    SweptSurface(SweptSurface_<'a>),
    SymbolColour(SymbolColour_<'a>),
    SymbolRepresentation(SymbolRepresentation_<'a>),
    SymbolRepresentationMap(SymbolRepresentationMap_<'a>),
    SymbolStyle(SymbolStyle_<'a>),
    SymbolTarget(SymbolTarget_<'a>),
    SymmetricShapeAspect(SymmetricShapeAspect_<'a>),
    SymmetryTolerance(SymmetryTolerance_<'a>),
    TactileAppearanceRepresentation(TactileAppearanceRepresentation_<'a>),
    TanFunction(TanFunction_<'a>),
    Tangent(Tangent_<'a>),
    Taper(Taper_<'a>),
    TeeProfile(TeeProfile_<'a>),
    TerminatorSymbol(TerminatorSymbol_<'a>),
    TextLiteral(TextLiteral_<'a>),
    TextLiteralWithAssociatedCurves(TextLiteralWithAssociatedCurves_<'a>),
    TextLiteralWithBlankingBox(TextLiteralWithBlankingBox_<'a>),
    TextLiteralWithDelineation(TextLiteralWithDelineation_<'a>),
    TextLiteralWithExtent(TextLiteralWithExtent_<'a>),
    TextStringRepresentation(TextStringRepresentation_<'a>),
    TextStyle(TextStyle_<'a>),
    TextStyleForDefinedFont(TextStyleForDefinedFont_<'a>),
    TextStyleWithBoxCharacteristics(TextStyleWithBoxCharacteristics_<'a>),
    TextStyleWithMirror(TextStyleWithMirror_<'a>),
    TextStyleWithSpacing(TextStyleWithSpacing_<'a>),
    ThermodynamicTemperatureMeasureWithUnit(ThermodynamicTemperatureMeasureWithUnit_<'a>),
    ThermodynamicTemperatureUnit(ThermodynamicTemperatureUnit_<'a>),
    Thread(Thread_<'a>),
    TimeInterval(TimeInterval_<'a>),
    TimeIntervalAssignment(TimeIntervalAssignment_<'a>),
    TimeIntervalBasedEffectivity(TimeIntervalBasedEffectivity_<'a>),
    TimeIntervalRole(TimeIntervalRole_<'a>),
    TimeIntervalWithBounds(TimeIntervalWithBounds_<'a>),
    TimeMeasureWithUnit(TimeMeasureWithUnit_<'a>),
    TimeUnit(TimeUnit_<'a>),
    ToleranceValue(ToleranceValue_<'a>),
    ToleranceZone(ToleranceZone_<'a>),
    ToleranceZoneDefinition(ToleranceZoneDefinition_<'a>),
    ToleranceZoneForm(ToleranceZoneForm_<'a>),
    TopologicalRepresentationItem(TopologicalRepresentationItem_<'a>),
    ToroidalSurface(ToroidalSurface_<'a>),
    Torus(Torus_<'a>),
    TotalRunoutTolerance(TotalRunoutTolerance_<'a>),
    TransitionFeature(TransitionFeature_<'a>),
    TrimmedCurve(TrimmedCurve_<'a>),
    TwoDirectionRepeatFactor(TwoDirectionRepeatFactor_<'a>),
    TypeQualifier(TypeQualifier_<'a>),
    UnaryBooleanExpression(UnaryBooleanExpression_<'a>),
    UnaryFunctionCall(UnaryFunctionCall_<'a>),
    UnaryGenericExpression(UnaryGenericExpression_<'a>),
    UnaryNumericExpression(UnaryNumericExpression_<'a>),
    UncertaintyAssignedRepresentation(UncertaintyAssignedRepresentation_<'a>),
    UncertaintyMeasureWithUnit(UncertaintyMeasureWithUnit_<'a>),
    UncertaintyQualifier(UncertaintyQualifier_<'a>),
    UnconstrainedPair(UnconstrainedPair_<'a>),
    UnconstrainedPairValue(UnconstrainedPairValue_<'a>),
    UniformCurve(UniformCurve_<'a>),
    UniformSurface(UniformSurface_<'a>),
    UniversalPair(UniversalPair_<'a>),
    UniversalPairRange(UniversalPairRange_<'a>),
    UniversalPairValue(UniversalPairValue_<'a>),
    ValueFunction(ValueFunction_<'a>),
    ValueRange(ValueRange_<'a>),
    ValueRepresentationItem(ValueRepresentationItem_<'a>),
    Variable(Variable_<'a>),
    VariableSemantics(VariableSemantics_<'a>),
    Vector(Vector_<'a>),
    VectorStyle(VectorStyle_<'a>),
    VeeProfile(VeeProfile_<'a>),
    VersionedActionRequest(VersionedActionRequest_<'a>),
    VersionedActionRequestRelationship(VersionedActionRequestRelationship_<'a>),
    Vertex(Vertex_<'a>),
    VertexLoop(VertexLoop_<'a>),
    VertexPoint(VertexPoint_<'a>),
    ViewVolume(ViewVolume_<'a>),
    VisualAppearanceRepresentation(VisualAppearanceRepresentation_<'a>),
    VolumeMeasureWithUnit(VolumeMeasureWithUnit_<'a>),
    VolumeUnit(VolumeUnit_<'a>),
    XorExpression(XorExpression_<'a>),
    _ComplexMapping,
    _FailedToParse,
    _EmptySlot,
}
impl<'a> ParseFromChunks<'a> for Entity<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (_, r) = recognize(pair(
            alt((alpha0, tag("_"))),
            many0(alt((alphanumeric1, tag("_")))),
        ))(strs[0])?;
        match r {
            "ABS_FUNCTION" => AbsFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::AbsFunction(v))),
            "ACOS_FUNCTION" => AcosFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::AcosFunction(v))),
            "ACTION" => Action_::parse_chunks(strs).map(|(s, v)| (s, Entity::Action(v))),
            "ACTION_ASSIGNMENT" => ActionAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionAssignment(v))),
            "ACTION_DIRECTIVE" => ActionDirective_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionDirective(v))),
            "ACTION_METHOD" => ActionMethod_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionMethod(v))),
            "ACTION_METHOD_RELATIONSHIP" => ActionMethodRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionMethodRelationship(v))),
            "ACTION_PROPERTY" => ActionProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionProperty(v))),
            "ACTION_PROPERTY_REPRESENTATION" => ActionPropertyRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionPropertyRepresentation(v))),
            "ACTION_RELATIONSHIP" => ActionRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionRelationship(v))),
            "ACTION_REQUEST_ASSIGNMENT" => ActionRequestAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionRequestAssignment(v))),
            "ACTION_REQUEST_SOLUTION" => ActionRequestSolution_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionRequestSolution(v))),
            "ACTION_REQUEST_STATUS" => ActionRequestStatus_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionRequestStatus(v))),
            "ACTION_RESOURCE" => ActionResource_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionResource(v))),
            "ACTION_RESOURCE_REQUIREMENT" => ActionResourceRequirement_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionResourceRequirement(v))),
            "ACTION_RESOURCE_TYPE" => ActionResourceType_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionResourceType(v))),
            "ACTION_STATUS" => ActionStatus_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionStatus(v))),
            "ADDRESS" => Address_::parse_chunks(strs).map(|(s, v)| (s, Entity::Address(v))),
            "ADVANCED_BREP_SHAPE_REPRESENTATION" => AdvancedBrepShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::AdvancedBrepShapeRepresentation(v))),
            "ADVANCED_FACE" => AdvancedFace_::parse_chunks(strs).map(|(s, v)| (s, Entity::AdvancedFace(v))),
            "ALTERNATE_PRODUCT_RELATIONSHIP" => AlternateProductRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::AlternateProductRelationship(v))),
            "AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT" => AmountOfSubstanceMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::AmountOfSubstanceMeasureWithUnit(v))),
            "AMOUNT_OF_SUBSTANCE_UNIT" => AmountOfSubstanceUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::AmountOfSubstanceUnit(v))),
            "AND_EXPRESSION" => AndExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::AndExpression(v))),
            "ANGULAR_DIMENSION" => AngularDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::AngularDimension(v))),
            "ANGULAR_LOCATION" => AngularLocation_::parse_chunks(strs).map(|(s, v)| (s, Entity::AngularLocation(v))),
            "ANGULAR_SIZE" => AngularSize_::parse_chunks(strs).map(|(s, v)| (s, Entity::AngularSize(v))),
            "ANGULARITY_TOLERANCE" => AngularityTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::AngularityTolerance(v))),
            "ANNOTATION_CURVE_OCCURRENCE" => AnnotationCurveOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationCurveOccurrence(v))),
            "ANNOTATION_FILL_AREA" => AnnotationFillArea_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationFillArea(v))),
            "ANNOTATION_FILL_AREA_OCCURRENCE" => AnnotationFillAreaOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationFillAreaOccurrence(v))),
            "ANNOTATION_OCCURRENCE" => AnnotationOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationOccurrence(v))),
            "ANNOTATION_OCCURRENCE_ASSOCIATIVITY" => AnnotationOccurrenceAssociativity_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationOccurrenceAssociativity(v))),
            "ANNOTATION_OCCURRENCE_RELATIONSHIP" => AnnotationOccurrenceRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationOccurrenceRelationship(v))),
            "ANNOTATION_PLANE" => AnnotationPlane_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationPlane(v))),
            "ANNOTATION_SUBFIGURE_OCCURRENCE" => AnnotationSubfigureOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationSubfigureOccurrence(v))),
            "ANNOTATION_SYMBOL" => AnnotationSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationSymbol(v))),
            "ANNOTATION_SYMBOL_OCCURRENCE" => AnnotationSymbolOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationSymbolOccurrence(v))),
            "ANNOTATION_TEXT" => AnnotationText_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationText(v))),
            "ANNOTATION_TEXT_CHARACTER" => AnnotationTextCharacter_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationTextCharacter(v))),
            "ANNOTATION_TEXT_OCCURRENCE" => AnnotationTextOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationTextOccurrence(v))),
            "APEX" => Apex_::parse_chunks(strs).map(|(s, v)| (s, Entity::Apex(v))),
            "APPLICATION_CONTEXT" => ApplicationContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApplicationContext(v))),
            "APPLICATION_CONTEXT_ELEMENT" => ApplicationContextElement_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApplicationContextElement(v))),
            "APPLICATION_CONTEXT_RELATIONSHIP" => ApplicationContextRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApplicationContextRelationship(v))),
            "APPLICATION_PROTOCOL_DEFINITION" => ApplicationProtocolDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApplicationProtocolDefinition(v))),
            "APPLIED_ACTION_ASSIGNMENT" => AppliedActionAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedActionAssignment(v))),
            "APPLIED_ACTION_REQUEST_ASSIGNMENT" => AppliedActionRequestAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedActionRequestAssignment(v))),
            "APPLIED_APPROVAL_ASSIGNMENT" => AppliedApprovalAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedApprovalAssignment(v))),
            "APPLIED_AREA" => AppliedArea_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedArea(v))),
            "APPLIED_CERTIFICATION_ASSIGNMENT" => AppliedCertificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedCertificationAssignment(v))),
            "APPLIED_CLASSIFICATION_ASSIGNMENT" => AppliedClassificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedClassificationAssignment(v))),
            "APPLIED_CONTRACT_ASSIGNMENT" => AppliedContractAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedContractAssignment(v))),
            "APPLIED_DATE_AND_TIME_ASSIGNMENT" => AppliedDateAndTimeAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedDateAndTimeAssignment(v))),
            "APPLIED_DATE_ASSIGNMENT" => AppliedDateAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedDateAssignment(v))),
            "APPLIED_DOCUMENT_REFERENCE" => AppliedDocumentReference_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedDocumentReference(v))),
            "APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => AppliedDocumentUsageConstraintAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedDocumentUsageConstraintAssignment(v))),
            "APPLIED_EFFECTIVITY_ASSIGNMENT" => AppliedEffectivityAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedEffectivityAssignment(v))),
            "APPLIED_EVENT_OCCURRENCE_ASSIGNMENT" => AppliedEventOccurrenceAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedEventOccurrenceAssignment(v))),
            "APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT" => AppliedExternalIdentificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedExternalIdentificationAssignment(v))),
            "APPLIED_GROUP_ASSIGNMENT" => AppliedGroupAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedGroupAssignment(v))),
            "APPLIED_IDENTIFICATION_ASSIGNMENT" => AppliedIdentificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedIdentificationAssignment(v))),
            "APPLIED_INEFFECTIVITY_ASSIGNMENT" => AppliedIneffectivityAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedIneffectivityAssignment(v))),
            "APPLIED_NAME_ASSIGNMENT" => AppliedNameAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedNameAssignment(v))),
            "APPLIED_ORGANIZATION_ASSIGNMENT" => AppliedOrganizationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedOrganizationAssignment(v))),
            "APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT" => AppliedOrganizationalProjectAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedOrganizationalProjectAssignment(v))),
            "APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT" => AppliedPersonAndOrganizationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedPersonAndOrganizationAssignment(v))),
            "APPLIED_PRESENTED_ITEM" => AppliedPresentedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedPresentedItem(v))),
            "APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT" => AppliedSecurityClassificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedSecurityClassificationAssignment(v))),
            "APPLIED_TIME_INTERVAL_ASSIGNMENT" => AppliedTimeIntervalAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedTimeIntervalAssignment(v))),
            "APPROVAL" => Approval_::parse_chunks(strs).map(|(s, v)| (s, Entity::Approval(v))),
            "APPROVAL_ASSIGNMENT" => ApprovalAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalAssignment(v))),
            "APPROVAL_DATE_TIME" => ApprovalDateTime_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalDateTime(v))),
            "APPROVAL_PERSON_ORGANIZATION" => ApprovalPersonOrganization_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalPersonOrganization(v))),
            "APPROVAL_RELATIONSHIP" => ApprovalRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalRelationship(v))),
            "APPROVAL_ROLE" => ApprovalRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalRole(v))),
            "APPROVAL_STATUS" => ApprovalStatus_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalStatus(v))),
            "APPROXIMATION_TOLERANCE" => ApproximationTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApproximationTolerance(v))),
            "APPROXIMATION_TOLERANCE_DEVIATION" => ApproximationToleranceDeviation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApproximationToleranceDeviation(v))),
            "APPROXIMATION_TOLERANCE_PARAMETER" => ApproximationToleranceParameter_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApproximationToleranceParameter(v))),
            "AREA_IN_SET" => AreaInSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::AreaInSet(v))),
            "AREA_MEASURE_WITH_UNIT" => AreaMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::AreaMeasureWithUnit(v))),
            "AREA_UNIT" => AreaUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::AreaUnit(v))),
            "ASIN_FUNCTION" => AsinFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::AsinFunction(v))),
            "ASSEMBLY_COMPONENT_USAGE" => AssemblyComponentUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::AssemblyComponentUsage(v))),
            "ASSEMBLY_COMPONENT_USAGE_SUBSTITUTE" => AssemblyComponentUsageSubstitute_::parse_chunks(strs).map(|(s, v)| (s, Entity::AssemblyComponentUsageSubstitute(v))),
            "ATAN_FUNCTION" => AtanFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::AtanFunction(v))),
            "ATTRIBUTE_CLASSIFICATION_ASSIGNMENT" => AttributeClassificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AttributeClassificationAssignment(v))),
            "ATTRIBUTE_LANGUAGE_ASSIGNMENT" => AttributeLanguageAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AttributeLanguageAssignment(v))),
            "ATTRIBUTE_VALUE_ASSIGNMENT" => AttributeValueAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AttributeValueAssignment(v))),
            "ATTRIBUTE_VALUE_ROLE" => AttributeValueRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::AttributeValueRole(v))),
            "AXIS1_PLACEMENT" => Axis1Placement_::parse_chunks(strs).map(|(s, v)| (s, Entity::Axis1Placement(v))),
            "AXIS2_PLACEMENT_2D" => Axis2Placement2d_::parse_chunks(strs).map(|(s, v)| (s, Entity::Axis2Placement2d(v))),
            "AXIS2_PLACEMENT_3D" => Axis2Placement3d_::parse_chunks(strs).map(|(s, v)| (s, Entity::Axis2Placement3d(v))),
            "B_SPLINE_CURVE" => BSplineCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BSplineCurve(v))),
            "B_SPLINE_CURVE_WITH_KNOTS" => BSplineCurveWithKnots_::parse_chunks(strs).map(|(s, v)| (s, Entity::BSplineCurveWithKnots(v))),
            "B_SPLINE_SURFACE" => BSplineSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::BSplineSurface(v))),
            "B_SPLINE_SURFACE_WITH_KNOTS" => BSplineSurfaceWithKnots_::parse_chunks(strs).map(|(s, v)| (s, Entity::BSplineSurfaceWithKnots(v))),
            "BACKGROUND_COLOUR" => BackgroundColour_::parse_chunks(strs).map(|(s, v)| (s, Entity::BackgroundColour(v))),
            "BARRING_HOLE" => BarringHole_::parse_chunks(strs).map(|(s, v)| (s, Entity::BarringHole(v))),
            "BEAD" => Bead_::parse_chunks(strs).map(|(s, v)| (s, Entity::Bead(v))),
            "BEAD_END" => BeadEnd_::parse_chunks(strs).map(|(s, v)| (s, Entity::BeadEnd(v))),
            "BEZIER_CURVE" => BezierCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BezierCurve(v))),
            "BEZIER_SURFACE" => BezierSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::BezierSurface(v))),
            "BINARY_BOOLEAN_EXPRESSION" => BinaryBooleanExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::BinaryBooleanExpression(v))),
            "BINARY_FUNCTION_CALL" => BinaryFunctionCall_::parse_chunks(strs).map(|(s, v)| (s, Entity::BinaryFunctionCall(v))),
            "BINARY_GENERIC_EXPRESSION" => BinaryGenericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::BinaryGenericExpression(v))),
            "BINARY_NUMERIC_EXPRESSION" => BinaryNumericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::BinaryNumericExpression(v))),
            "BLOCK" => Block_::parse_chunks(strs).map(|(s, v)| (s, Entity::Block(v))),
            "BOOLEAN_DEFINED_FUNCTION" => BooleanDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::BooleanDefinedFunction(v))),
            "BOOLEAN_EXPRESSION" => BooleanExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::BooleanExpression(v))),
            "BOOLEAN_LITERAL" => BooleanLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::BooleanLiteral(v))),
            "BOOLEAN_RESULT" => BooleanResult_::parse_chunks(strs).map(|(s, v)| (s, Entity::BooleanResult(v))),
            "BOOLEAN_VARIABLE" => BooleanVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::BooleanVariable(v))),
            "BOSS" => Boss_::parse_chunks(strs).map(|(s, v)| (s, Entity::Boss(v))),
            "BOSS_TOP" => BossTop_::parse_chunks(strs).map(|(s, v)| (s, Entity::BossTop(v))),
            "BOUNDARY_CURVE" => BoundaryCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoundaryCurve(v))),
            "BOUNDED_CURVE" => BoundedCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoundedCurve(v))),
            "BOUNDED_PCURVE" => BoundedPcurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoundedPcurve(v))),
            "BOUNDED_SURFACE" => BoundedSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoundedSurface(v))),
            "BOUNDED_SURFACE_CURVE" => BoundedSurfaceCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoundedSurfaceCurve(v))),
            "BOX_DOMAIN" => BoxDomain_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoxDomain(v))),
            "BOXED_HALF_SPACE" => BoxedHalfSpace_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoxedHalfSpace(v))),
            "BREP_WITH_VOIDS" => BrepWithVoids_::parse_chunks(strs).map(|(s, v)| (s, Entity::BrepWithVoids(v))),
            "CALENDAR_DATE" => CalendarDate_::parse_chunks(strs).map(|(s, v)| (s, Entity::CalendarDate(v))),
            "CAMERA_IMAGE" => CameraImage_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraImage(v))),
            "CAMERA_IMAGE_2D_WITH_SCALE" => CameraImage2dWithScale_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraImage2dWithScale(v))),
            "CAMERA_IMAGE_3D_WITH_SCALE" => CameraImage3dWithScale_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraImage3dWithScale(v))),
            "CAMERA_MODEL" => CameraModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraModel(v))),
            "CAMERA_MODEL_D2" => CameraModelD2_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraModelD2(v))),
            "CAMERA_MODEL_D3" => CameraModelD3_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraModelD3(v))),
            "CAMERA_MODEL_D3_WITH_HLHSR" => CameraModelD3WithHlhsr_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraModelD3WithHlhsr(v))),
            "CAMERA_USAGE" => CameraUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraUsage(v))),
            "CARTESIAN_POINT" => CartesianPoint_::parse_chunks(strs).map(|(s, v)| (s, Entity::CartesianPoint(v))),
            "CARTESIAN_TRANSFORMATION_OPERATOR" => CartesianTransformationOperator_::parse_chunks(strs).map(|(s, v)| (s, Entity::CartesianTransformationOperator(v))),
            "CARTESIAN_TRANSFORMATION_OPERATOR_2D" => CartesianTransformationOperator2d_::parse_chunks(strs).map(|(s, v)| (s, Entity::CartesianTransformationOperator2d(v))),
            "CARTESIAN_TRANSFORMATION_OPERATOR_3D" => CartesianTransformationOperator3d_::parse_chunks(strs).map(|(s, v)| (s, Entity::CartesianTransformationOperator3d(v))),
            "CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT" => CelsiusTemperatureMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::CelsiusTemperatureMeasureWithUnit(v))),
            "CENTRE_OF_SYMMETRY" => CentreOfSymmetry_::parse_chunks(strs).map(|(s, v)| (s, Entity::CentreOfSymmetry(v))),
            "CERTIFICATION" => Certification_::parse_chunks(strs).map(|(s, v)| (s, Entity::Certification(v))),
            "CERTIFICATION_ASSIGNMENT" => CertificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::CertificationAssignment(v))),
            "CERTIFICATION_TYPE" => CertificationType_::parse_chunks(strs).map(|(s, v)| (s, Entity::CertificationType(v))),
            "CHAMFER" => Chamfer_::parse_chunks(strs).map(|(s, v)| (s, Entity::Chamfer(v))),
            "CHAMFER_OFFSET" => ChamferOffset_::parse_chunks(strs).map(|(s, v)| (s, Entity::ChamferOffset(v))),
            "CHARACTER_GLYPH_SYMBOL" => CharacterGlyphSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::CharacterGlyphSymbol(v))),
            "CHARACTERIZED_CLASS" => CharacterizedClass_::parse_chunks(strs).map(|(s, v)| (s, Entity::CharacterizedClass(v))),
            "CHARACTERIZED_OBJECT" => CharacterizedObject_::parse_chunks(strs).map(|(s, v)| (s, Entity::CharacterizedObject(v))),
            "CIRCLE" => Circle_::parse_chunks(strs).map(|(s, v)| (s, Entity::Circle(v))),
            "CIRCULAR_CLOSED_PROFILE" => CircularClosedProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::CircularClosedProfile(v))),
            "CIRCULAR_PATTERN" => CircularPattern_::parse_chunks(strs).map(|(s, v)| (s, Entity::CircularPattern(v))),
            "CIRCULAR_RUNOUT_TOLERANCE" => CircularRunoutTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::CircularRunoutTolerance(v))),
            "CLASS" => Class_::parse_chunks(strs).map(|(s, v)| (s, Entity::Class(v))),
            "CLASS_SYSTEM" => ClassSystem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClassSystem(v))),
            "CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT" => ClassUsageEffectivityContextAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClassUsageEffectivityContextAssignment(v))),
            "CLASSIFICATION_ASSIGNMENT" => ClassificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClassificationAssignment(v))),
            "CLASSIFICATION_ROLE" => ClassificationRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClassificationRole(v))),
            "CLOSED_PATH_PROFILE" => ClosedPathProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClosedPathProfile(v))),
            "CLOSED_SHELL" => ClosedShell_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClosedShell(v))),
            "COAXIALITY_TOLERANCE" => CoaxialityTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::CoaxialityTolerance(v))),
            "COLOUR" => Colour_::parse_chunks(strs).map(|(s, v)| (s, Entity::Colour(v))),
            "COLOUR_RGB" => ColourRgb_::parse_chunks(strs).map(|(s, v)| (s, Entity::ColourRgb(v))),
            "COLOUR_SPECIFICATION" => ColourSpecification_::parse_chunks(strs).map(|(s, v)| (s, Entity::ColourSpecification(v))),
            "COMMON_DATUM" => CommonDatum_::parse_chunks(strs).map(|(s, v)| (s, Entity::CommonDatum(v))),
            "COMPARISON_EQUAL" => ComparisonEqual_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonEqual(v))),
            "COMPARISON_EXPRESSION" => ComparisonExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonExpression(v))),
            "COMPARISON_GREATER" => ComparisonGreater_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonGreater(v))),
            "COMPARISON_GREATER_EQUAL" => ComparisonGreaterEqual_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonGreaterEqual(v))),
            "COMPARISON_LESS" => ComparisonLess_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonLess(v))),
            "COMPARISON_LESS_EQUAL" => ComparisonLessEqual_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonLessEqual(v))),
            "COMPARISON_NOT_EQUAL" => ComparisonNotEqual_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonNotEqual(v))),
            "COMPOSITE_CURVE" => CompositeCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeCurve(v))),
            "COMPOSITE_CURVE_ON_SURFACE" => CompositeCurveOnSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeCurveOnSurface(v))),
            "COMPOSITE_CURVE_SEGMENT" => CompositeCurveSegment_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeCurveSegment(v))),
            "COMPOSITE_HOLE" => CompositeHole_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeHole(v))),
            "COMPOSITE_SHAPE_ASPECT" => CompositeShapeAspect_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeShapeAspect(v))),
            "COMPOSITE_TEXT" => CompositeText_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeText(v))),
            "COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES" => CompositeTextWithAssociatedCurves_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeTextWithAssociatedCurves(v))),
            "COMPOSITE_TEXT_WITH_BLANKING_BOX" => CompositeTextWithBlankingBox_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeTextWithBlankingBox(v))),
            "COMPOSITE_TEXT_WITH_EXTENT" => CompositeTextWithExtent_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeTextWithExtent(v))),
            "COMPOUND_FEATURE" => CompoundFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompoundFeature(v))),
            "COMPOUND_REPRESENTATION_ITEM" => CompoundRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompoundRepresentationItem(v))),
            "COMPOUND_SHAPE_REPRESENTATION" => CompoundShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompoundShapeRepresentation(v))),
            "CONCAT_EXPRESSION" => ConcatExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConcatExpression(v))),
            "CONCENTRICITY_TOLERANCE" => ConcentricityTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConcentricityTolerance(v))),
            "CONCEPT_FEATURE_OPERATOR" => ConceptFeatureOperator_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConceptFeatureOperator(v))),
            "CONCEPT_FEATURE_RELATIONSHIP" => ConceptFeatureRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConceptFeatureRelationship(v))),
            "CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION" => ConceptFeatureRelationshipWithCondition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConceptFeatureRelationshipWithCondition(v))),
            "CONDITIONAL_CONCEPT_FEATURE" => ConditionalConceptFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConditionalConceptFeature(v))),
            "CONFIGURABLE_ITEM" => ConfigurableItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurableItem(v))),
            "CONFIGURATION_DEFINITION" => ConfigurationDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurationDefinition(v))),
            "CONFIGURATION_DESIGN" => ConfigurationDesign_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurationDesign(v))),
            "CONFIGURATION_EFFECTIVITY" => ConfigurationEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurationEffectivity(v))),
            "CONFIGURATION_INTERPOLATION" => ConfigurationInterpolation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurationInterpolation(v))),
            "CONFIGURATION_ITEM" => ConfigurationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurationItem(v))),
            "CONFIGURED_EFFECTIVITY_ASSIGNMENT" => ConfiguredEffectivityAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfiguredEffectivityAssignment(v))),
            "CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT" => ConfiguredEffectivityContextAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfiguredEffectivityContextAssignment(v))),
            "CONIC" => Conic_::parse_chunks(strs).map(|(s, v)| (s, Entity::Conic(v))),
            "CONICAL_SURFACE" => ConicalSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConicalSurface(v))),
            "CONNECTED_EDGE_SET" => ConnectedEdgeSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConnectedEdgeSet(v))),
            "CONNECTED_FACE_SET" => ConnectedFaceSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConnectedFaceSet(v))),
            "CONNECTED_FACE_SUB_SET" => ConnectedFaceSubSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConnectedFaceSubSet(v))),
            "CONSTRUCTIVE_GEOMETRY_REPRESENTATION" => ConstructiveGeometryRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConstructiveGeometryRepresentation(v))),
            "CONSTRUCTIVE_GEOMETRY_REPRESENTATION_RELATIONSHIP" => ConstructiveGeometryRepresentationRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConstructiveGeometryRepresentationRelationship(v))),
            "CONTACT_RATIO_REPRESENTATION" => ContactRatioRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContactRatioRepresentation(v))),
            "CONTEXT_DEPENDENT_INVISIBILITY" => ContextDependentInvisibility_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContextDependentInvisibility(v))),
            "CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM" => ContextDependentOverRidingStyledItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContextDependentOverRidingStyledItem(v))),
            "CONTEXT_DEPENDENT_SHAPE_REPRESENTATION" => ContextDependentShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContextDependentShapeRepresentation(v))),
            "CONTEXT_DEPENDENT_UNIT" => ContextDependentUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContextDependentUnit(v))),
            "CONTRACT" => Contract_::parse_chunks(strs).map(|(s, v)| (s, Entity::Contract(v))),
            "CONTRACT_ASSIGNMENT" => ContractAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContractAssignment(v))),
            "CONTRACT_TYPE" => ContractType_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContractType(v))),
            "CONVERSION_BASED_UNIT" => ConversionBasedUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConversionBasedUnit(v))),
            "COORDINATED_UNIVERSAL_TIME_OFFSET" => CoordinatedUniversalTimeOffset_::parse_chunks(strs).map(|(s, v)| (s, Entity::CoordinatedUniversalTimeOffset(v))),
            "COS_FUNCTION" => CosFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::CosFunction(v))),
            "CSG_SHAPE_REPRESENTATION" => CsgShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::CsgShapeRepresentation(v))),
            "CSG_SOLID" => CsgSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::CsgSolid(v))),
            "CURVE" => Curve_::parse_chunks(strs).map(|(s, v)| (s, Entity::Curve(v))),
            "CURVE_BOUNDED_SURFACE" => CurveBoundedSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveBoundedSurface(v))),
            "CURVE_DIMENSION" => CurveDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveDimension(v))),
            "CURVE_REPLICA" => CurveReplica_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveReplica(v))),
            "CURVE_STYLE" => CurveStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveStyle(v))),
            "CURVE_STYLE_FONT" => CurveStyleFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveStyleFont(v))),
            "CURVE_STYLE_FONT_PATTERN" => CurveStyleFontPattern_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveStyleFontPattern(v))),
            "CURVE_STYLE_RENDERING" => CurveStyleRendering_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveStyleRendering(v))),
            "CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION" => CurveSweptSolidShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveSweptSolidShapeRepresentation(v))),
            "CYLINDRICAL_PAIR" => CylindricalPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::CylindricalPair(v))),
            "CYLINDRICAL_PAIR_RANGE" => CylindricalPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::CylindricalPairRange(v))),
            "CYLINDRICAL_PAIR_VALUE" => CylindricalPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::CylindricalPairValue(v))),
            "CYLINDRICAL_SURFACE" => CylindricalSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::CylindricalSurface(v))),
            "CYLINDRICITY_TOLERANCE" => CylindricityTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::CylindricityTolerance(v))),
            "DATA_ENVIRONMENT" => DataEnvironment_::parse_chunks(strs).map(|(s, v)| (s, Entity::DataEnvironment(v))),
            "DATE" => Date_::parse_chunks(strs).map(|(s, v)| (s, Entity::Date(v))),
            "DATE_AND_TIME" => DateAndTime_::parse_chunks(strs).map(|(s, v)| (s, Entity::DateAndTime(v))),
            "DATE_AND_TIME_ASSIGNMENT" => DateAndTimeAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::DateAndTimeAssignment(v))),
            "DATE_ASSIGNMENT" => DateAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::DateAssignment(v))),
            "DATE_ROLE" => DateRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::DateRole(v))),
            "DATE_TIME_ROLE" => DateTimeRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::DateTimeRole(v))),
            "DATED_EFFECTIVITY" => DatedEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatedEffectivity(v))),
            "DATUM" => Datum_::parse_chunks(strs).map(|(s, v)| (s, Entity::Datum(v))),
            "DATUM_FEATURE" => DatumFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatumFeature(v))),
            "DATUM_FEATURE_CALLOUT" => DatumFeatureCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatumFeatureCallout(v))),
            "DATUM_REFERENCE" => DatumReference_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatumReference(v))),
            "DATUM_TARGET" => DatumTarget_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatumTarget(v))),
            "DATUM_TARGET_CALLOUT" => DatumTargetCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatumTargetCallout(v))),
            "DEFAULT_TOLERANCE_TABLE" => DefaultToleranceTable_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefaultToleranceTable(v))),
            "DEFAULT_TOLERANCE_TABLE_CELL" => DefaultToleranceTableCell_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefaultToleranceTableCell(v))),
            "DEFINED_CHARACTER_GLYPH" => DefinedCharacterGlyph_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefinedCharacterGlyph(v))),
            "DEFINED_FUNCTION" => DefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefinedFunction(v))),
            "DEFINED_SYMBOL" => DefinedSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefinedSymbol(v))),
            "DEFINITIONAL_REPRESENTATION" => DefinitionalRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefinitionalRepresentation(v))),
            "DEGENERATE_PCURVE" => DegeneratePcurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::DegeneratePcurve(v))),
            "DEGENERATE_TOROIDAL_SURFACE" => DegenerateToroidalSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::DegenerateToroidalSurface(v))),
            "DERIVED_SHAPE_ASPECT" => DerivedShapeAspect_::parse_chunks(strs).map(|(s, v)| (s, Entity::DerivedShapeAspect(v))),
            "DERIVED_UNIT" => DerivedUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::DerivedUnit(v))),
            "DERIVED_UNIT_ELEMENT" => DerivedUnitElement_::parse_chunks(strs).map(|(s, v)| (s, Entity::DerivedUnitElement(v))),
            "DERIVED_UNIT_VARIABLE" => DerivedUnitVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::DerivedUnitVariable(v))),
            "DESCRIPTION_ATTRIBUTE" => DescriptionAttribute_::parse_chunks(strs).map(|(s, v)| (s, Entity::DescriptionAttribute(v))),
            "DESCRIPTIVE_REPRESENTATION_ITEM" => DescriptiveRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::DescriptiveRepresentationItem(v))),
            "DIAMETER_DIMENSION" => DiameterDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::DiameterDimension(v))),
            "DIMENSION_CALLOUT" => DimensionCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCallout(v))),
            "DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP" => DimensionCalloutComponentRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCalloutComponentRelationship(v))),
            "DIMENSION_CALLOUT_RELATIONSHIP" => DimensionCalloutRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCalloutRelationship(v))),
            "DIMENSION_CURVE" => DimensionCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCurve(v))),
            "DIMENSION_CURVE_DIRECTED_CALLOUT" => DimensionCurveDirectedCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCurveDirectedCallout(v))),
            "DIMENSION_CURVE_TERMINATOR" => DimensionCurveTerminator_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCurveTerminator(v))),
            "DIMENSION_PAIR" => DimensionPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionPair(v))),
            "DIMENSION_RELATED_TOLERANCE_ZONE_ELEMENT" => DimensionRelatedToleranceZoneElement_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionRelatedToleranceZoneElement(v))),
            "DIMENSION_TEXT_ASSOCIATIVITY" => DimensionTextAssociativity_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionTextAssociativity(v))),
            "DIMENSIONAL_CHARACTERISTIC_REPRESENTATION" => DimensionalCharacteristicRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalCharacteristicRepresentation(v))),
            "DIMENSIONAL_EXPONENTS" => DimensionalExponents_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalExponents(v))),
            "DIMENSIONAL_LOCATION" => DimensionalLocation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalLocation(v))),
            "DIMENSIONAL_LOCATION_WITH_PATH" => DimensionalLocationWithPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalLocationWithPath(v))),
            "DIMENSIONAL_SIZE" => DimensionalSize_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalSize(v))),
            "DIMENSIONAL_SIZE_WITH_PATH" => DimensionalSizeWithPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalSizeWithPath(v))),
            "DIRECTED_ACTION" => DirectedAction_::parse_chunks(strs).map(|(s, v)| (s, Entity::DirectedAction(v))),
            "DIRECTED_ANGLE" => DirectedAngle_::parse_chunks(strs).map(|(s, v)| (s, Entity::DirectedAngle(v))),
            "DIRECTED_DIMENSIONAL_LOCATION" => DirectedDimensionalLocation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DirectedDimensionalLocation(v))),
            "DIRECTION" => Direction_::parse_chunks(strs).map(|(s, v)| (s, Entity::Direction(v))),
            "DIRECTION_SHAPE_REPRESENTATION" => DirectionShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DirectionShapeRepresentation(v))),
            "DIV_EXPRESSION" => DivExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::DivExpression(v))),
            "DOCUMENT" => Document_::parse_chunks(strs).map(|(s, v)| (s, Entity::Document(v))),
            "DOCUMENT_FILE" => DocumentFile_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentFile(v))),
            "DOCUMENT_PRODUCT_ASSOCIATION" => DocumentProductAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentProductAssociation(v))),
            "DOCUMENT_PRODUCT_EQUIVALENCE" => DocumentProductEquivalence_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentProductEquivalence(v))),
            "DOCUMENT_REFERENCE" => DocumentReference_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentReference(v))),
            "DOCUMENT_RELATIONSHIP" => DocumentRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentRelationship(v))),
            "DOCUMENT_REPRESENTATION_TYPE" => DocumentRepresentationType_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentRepresentationType(v))),
            "DOCUMENT_TYPE" => DocumentType_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentType(v))),
            "DOCUMENT_USAGE_CONSTRAINT" => DocumentUsageConstraint_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentUsageConstraint(v))),
            "DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => DocumentUsageConstraintAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentUsageConstraintAssignment(v))),
            "DOCUMENT_USAGE_ROLE" => DocumentUsageRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentUsageRole(v))),
            "DRAUGHTING_ANNOTATION_OCCURRENCE" => DraughtingAnnotationOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingAnnotationOccurrence(v))),
            "DRAUGHTING_CALLOUT" => DraughtingCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingCallout(v))),
            "DRAUGHTING_CALLOUT_RELATIONSHIP" => DraughtingCalloutRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingCalloutRelationship(v))),
            "DRAUGHTING_ELEMENTS" => DraughtingElements_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingElements(v))),
            "DRAUGHTING_MODEL" => DraughtingModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingModel(v))),
            "DRAUGHTING_MODEL_ITEM_ASSOCIATION" => DraughtingModelItemAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingModelItemAssociation(v))),
            "DRAUGHTING_PRE_DEFINED_COLOUR" => DraughtingPreDefinedColour_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingPreDefinedColour(v))),
            "DRAUGHTING_PRE_DEFINED_CURVE_FONT" => DraughtingPreDefinedCurveFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingPreDefinedCurveFont(v))),
            "DRAUGHTING_PRE_DEFINED_TEXT_FONT" => DraughtingPreDefinedTextFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingPreDefinedTextFont(v))),
            "DRAUGHTING_SPECIFICATION_REFERENCE" => DraughtingSpecificationReference_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingSpecificationReference(v))),
            "DRAUGHTING_SUBFIGURE_REPRESENTATION" => DraughtingSubfigureRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingSubfigureRepresentation(v))),
            "DRAUGHTING_SYMBOL_REPRESENTATION" => DraughtingSymbolRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingSymbolRepresentation(v))),
            "DRAUGHTING_TEXT_LITERAL_WITH_DELINEATION" => DraughtingTextLiteralWithDelineation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingTextLiteralWithDelineation(v))),
            "DRAUGHTING_TITLE" => DraughtingTitle_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingTitle(v))),
            "DRAWING_DEFINITION" => DrawingDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingDefinition(v))),
            "DRAWING_REVISION" => DrawingRevision_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingRevision(v))),
            "DRAWING_REVISION_SEQUENCE" => DrawingRevisionSequence_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingRevisionSequence(v))),
            "DRAWING_SHEET_LAYOUT" => DrawingSheetLayout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingSheetLayout(v))),
            "DRAWING_SHEET_REVISION" => DrawingSheetRevision_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingSheetRevision(v))),
            "DRAWING_SHEET_REVISION_USAGE" => DrawingSheetRevisionUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingSheetRevisionUsage(v))),
            "EDGE" => Edge_::parse_chunks(strs).map(|(s, v)| (s, Entity::Edge(v))),
            "EDGE_BASED_WIREFRAME_MODEL" => EdgeBasedWireframeModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::EdgeBasedWireframeModel(v))),
            "EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION" => EdgeBasedWireframeShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::EdgeBasedWireframeShapeRepresentation(v))),
            "EDGE_CURVE" => EdgeCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::EdgeCurve(v))),
            "EDGE_LOOP" => EdgeLoop_::parse_chunks(strs).map(|(s, v)| (s, Entity::EdgeLoop(v))),
            "EDGE_ROUND" => EdgeRound_::parse_chunks(strs).map(|(s, v)| (s, Entity::EdgeRound(v))),
            "EFFECTIVITY" => Effectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::Effectivity(v))),
            "EFFECTIVITY_ASSIGNMENT" => EffectivityAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::EffectivityAssignment(v))),
            "EFFECTIVITY_CONTEXT_ASSIGNMENT" => EffectivityContextAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::EffectivityContextAssignment(v))),
            "EFFECTIVITY_CONTEXT_ROLE" => EffectivityContextRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::EffectivityContextRole(v))),
            "EFFECTIVITY_RELATIONSHIP" => EffectivityRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::EffectivityRelationship(v))),
            "ELECTRIC_CURRENT_MEASURE_WITH_UNIT" => ElectricCurrentMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ElectricCurrentMeasureWithUnit(v))),
            "ELECTRIC_CURRENT_UNIT" => ElectricCurrentUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ElectricCurrentUnit(v))),
            "ELEMENT_DELIVERY" => ElementDelivery_::parse_chunks(strs).map(|(s, v)| (s, Entity::ElementDelivery(v))),
            "ELEMENTARY_SURFACE" => ElementarySurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::ElementarySurface(v))),
            "ELLIPSE" => Ellipse_::parse_chunks(strs).map(|(s, v)| (s, Entity::Ellipse(v))),
            "ENVIRONMENT" => Environment_::parse_chunks(strs).map(|(s, v)| (s, Entity::Environment(v))),
            "EQUALS_EXPRESSION" => EqualsExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::EqualsExpression(v))),
            "EVALUATED_DEGENERATE_PCURVE" => EvaluatedDegeneratePcurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::EvaluatedDegeneratePcurve(v))),
            "EVENT_OCCURRENCE" => EventOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::EventOccurrence(v))),
            "EVENT_OCCURRENCE_ASSIGNMENT" => EventOccurrenceAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::EventOccurrenceAssignment(v))),
            "EVENT_OCCURRENCE_CONTEXT_ASSIGNMENT" => EventOccurrenceContextAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::EventOccurrenceContextAssignment(v))),
            "EVENT_OCCURRENCE_CONTEXT_ROLE" => EventOccurrenceContextRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::EventOccurrenceContextRole(v))),
            "EVENT_OCCURRENCE_ROLE" => EventOccurrenceRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::EventOccurrenceRole(v))),
            "EXCLUSIVE_PRODUCT_CONCEPT_FEATURE_CATEGORY" => ExclusiveProductConceptFeatureCategory_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExclusiveProductConceptFeatureCategory(v))),
            "EXECUTED_ACTION" => ExecutedAction_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExecutedAction(v))),
            "EXP_FUNCTION" => ExpFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExpFunction(v))),
            "EXPRESSION" => Expression_::parse_chunks(strs).map(|(s, v)| (s, Entity::Expression(v))),
            "EXPRESSION_CONVERSION_BASED_UNIT" => ExpressionConversionBasedUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExpressionConversionBasedUnit(v))),
            "EXTENSION" => Extension_::parse_chunks(strs).map(|(s, v)| (s, Entity::Extension(v))),
            "EXTERNAL_IDENTIFICATION_ASSIGNMENT" => ExternalIdentificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternalIdentificationAssignment(v))),
            "EXTERNAL_SOURCE" => ExternalSource_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternalSource(v))),
            "EXTERNALLY_DEFINED_CHARACTER_GLYPH" => ExternallyDefinedCharacterGlyph_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedCharacterGlyph(v))),
            "EXTERNALLY_DEFINED_CLASS" => ExternallyDefinedClass_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedClass(v))),
            "EXTERNALLY_DEFINED_CURVE_FONT" => ExternallyDefinedCurveFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedCurveFont(v))),
            "EXTERNALLY_DEFINED_DIMENSION_DEFINITION" => ExternallyDefinedDimensionDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedDimensionDefinition(v))),
            "EXTERNALLY_DEFINED_FEATURE_DEFINITION" => ExternallyDefinedFeatureDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedFeatureDefinition(v))),
            "EXTERNALLY_DEFINED_GENERAL_PROPERTY" => ExternallyDefinedGeneralProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedGeneralProperty(v))),
            "EXTERNALLY_DEFINED_HATCH_STYLE" => ExternallyDefinedHatchStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedHatchStyle(v))),
            "EXTERNALLY_DEFINED_ITEM" => ExternallyDefinedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedItem(v))),
            "EXTERNALLY_DEFINED_ITEM_RELATIONSHIP" => ExternallyDefinedItemRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedItemRelationship(v))),
            "EXTERNALLY_DEFINED_STYLE" => ExternallyDefinedStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedStyle(v))),
            "EXTERNALLY_DEFINED_SYMBOL" => ExternallyDefinedSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedSymbol(v))),
            "EXTERNALLY_DEFINED_TEXT_FONT" => ExternallyDefinedTextFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedTextFont(v))),
            "EXTERNALLY_DEFINED_TILE_STYLE" => ExternallyDefinedTileStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedTileStyle(v))),
            "EXTRUDED_AREA_SOLID" => ExtrudedAreaSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExtrudedAreaSolid(v))),
            "EXTRUDED_FACE_SOLID" => ExtrudedFaceSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExtrudedFaceSolid(v))),
            "FACE" => Face_::parse_chunks(strs).map(|(s, v)| (s, Entity::Face(v))),
            "FACE_BASED_SURFACE_MODEL" => FaceBasedSurfaceModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::FaceBasedSurfaceModel(v))),
            "FACE_BOUND" => FaceBound_::parse_chunks(strs).map(|(s, v)| (s, Entity::FaceBound(v))),
            "FACE_OUTER_BOUND" => FaceOuterBound_::parse_chunks(strs).map(|(s, v)| (s, Entity::FaceOuterBound(v))),
            "FACE_SHAPE_REPRESENTATION" => FaceShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::FaceShapeRepresentation(v))),
            "FACE_SURFACE" => FaceSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::FaceSurface(v))),
            "FACETED_BREP" => FacetedBrep_::parse_chunks(strs).map(|(s, v)| (s, Entity::FacetedBrep(v))),
            "FACETED_BREP_SHAPE_REPRESENTATION" => FacetedBrepShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::FacetedBrepShapeRepresentation(v))),
            "FEATURE_COMPONENT_DEFINITION" => FeatureComponentDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeatureComponentDefinition(v))),
            "FEATURE_COMPONENT_RELATIONSHIP" => FeatureComponentRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeatureComponentRelationship(v))),
            "FEATURE_DEFINITION" => FeatureDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeatureDefinition(v))),
            "FEATURE_IN_PANEL" => FeatureInPanel_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeatureInPanel(v))),
            "FEATURE_PATTERN" => FeaturePattern_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeaturePattern(v))),
            "FEATURED_SHAPE" => FeaturedShape_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeaturedShape(v))),
            "FILL_AREA_STYLE" => FillAreaStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::FillAreaStyle(v))),
            "FILL_AREA_STYLE_COLOUR" => FillAreaStyleColour_::parse_chunks(strs).map(|(s, v)| (s, Entity::FillAreaStyleColour(v))),
            "FILL_AREA_STYLE_HATCHING" => FillAreaStyleHatching_::parse_chunks(strs).map(|(s, v)| (s, Entity::FillAreaStyleHatching(v))),
            "FILL_AREA_STYLE_TILE_SYMBOL_WITH_STYLE" => FillAreaStyleTileSymbolWithStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::FillAreaStyleTileSymbolWithStyle(v))),
            "FILL_AREA_STYLE_TILES" => FillAreaStyleTiles_::parse_chunks(strs).map(|(s, v)| (s, Entity::FillAreaStyleTiles(v))),
            "FILLET" => Fillet_::parse_chunks(strs).map(|(s, v)| (s, Entity::Fillet(v))),
            "FLATNESS_TOLERANCE" => FlatnessTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::FlatnessTolerance(v))),
            "FORMAT_FUNCTION" => FormatFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::FormatFunction(v))),
            "FOUNDED_ITEM" => FoundedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::FoundedItem(v))),
            "FOUNDED_KINEMATIC_PATH" => FoundedKinematicPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::FoundedKinematicPath(v))),
            "FULLY_CONSTRAINED_PAIR" => FullyConstrainedPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::FullyConstrainedPair(v))),
            "FUNCTIONALLY_DEFINED_TRANSFORMATION" => FunctionallyDefinedTransformation_::parse_chunks(strs).map(|(s, v)| (s, Entity::FunctionallyDefinedTransformation(v))),
            "GEAR_PAIR" => GearPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::GearPair(v))),
            "GEAR_PAIR_RANGE" => GearPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::GearPairRange(v))),
            "GEAR_PAIR_VALUE" => GearPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::GearPairValue(v))),
            "GENERAL_FEATURE" => GeneralFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeneralFeature(v))),
            "GENERAL_MATERIAL_PROPERTY" => GeneralMaterialProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeneralMaterialProperty(v))),
            "GENERAL_PROPERTY" => GeneralProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeneralProperty(v))),
            "GENERAL_PROPERTY_ASSOCIATION" => GeneralPropertyAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeneralPropertyAssociation(v))),
            "GENERAL_PROPERTY_RELATIONSHIP" => GeneralPropertyRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeneralPropertyRelationship(v))),
            "GENERIC_CHARACTER_GLYPH_SYMBOL" => GenericCharacterGlyphSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::GenericCharacterGlyphSymbol(v))),
            "GENERIC_EXPRESSION" => GenericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::GenericExpression(v))),
            "GENERIC_LITERAL" => GenericLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::GenericLiteral(v))),
            "GENERIC_VARIABLE" => GenericVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::GenericVariable(v))),
            "GEOMETRIC_ALIGNMENT" => GeometricAlignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricAlignment(v))),
            "GEOMETRIC_CURVE_SET" => GeometricCurveSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricCurveSet(v))),
            "GEOMETRIC_INTERSECTION" => GeometricIntersection_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricIntersection(v))),
            "GEOMETRIC_ITEM_SPECIFIC_USAGE" => GeometricItemSpecificUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricItemSpecificUsage(v))),
            "GEOMETRIC_REPRESENTATION_CONTEXT" => GeometricRepresentationContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricRepresentationContext(v))),
            "GEOMETRIC_REPRESENTATION_ITEM" => GeometricRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricRepresentationItem(v))),
            "GEOMETRIC_SET" => GeometricSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricSet(v))),
            "GEOMETRIC_TOLERANCE" => GeometricTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricTolerance(v))),
            "GEOMETRIC_TOLERANCE_RELATIONSHIP" => GeometricToleranceRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricToleranceRelationship(v))),
            "GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE" => GeometricToleranceWithDatumReference_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricToleranceWithDatumReference(v))),
            "GEOMETRIC_TOLERANCE_WITH_DEFINED_UNIT" => GeometricToleranceWithDefinedUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricToleranceWithDefinedUnit(v))),
            "GEOMETRICAL_TOLERANCE_CALLOUT" => GeometricalToleranceCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricalToleranceCallout(v))),
            "GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION" => GeometricallyBounded2dWireframeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricallyBounded2dWireframeRepresentation(v))),
            "GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION" => GeometricallyBoundedSurfaceShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricallyBoundedSurfaceShapeRepresentation(v))),
            "GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION" => GeometricallyBoundedWireframeShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricallyBoundedWireframeShapeRepresentation(v))),
            "GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT" => GlobalUncertaintyAssignedContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::GlobalUncertaintyAssignedContext(v))),
            "GLOBAL_UNIT_ASSIGNED_CONTEXT" => GlobalUnitAssignedContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::GlobalUnitAssignedContext(v))),
            "GROUP" => Group_::parse_chunks(strs).map(|(s, v)| (s, Entity::Group(v))),
            "GROUP_ASSIGNMENT" => GroupAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::GroupAssignment(v))),
            "GROUP_RELATIONSHIP" => GroupRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::GroupRelationship(v))),
            "HALF_SPACE_SOLID" => HalfSpaceSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::HalfSpaceSolid(v))),
            "HARDNESS_REPRESENTATION" => HardnessRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::HardnessRepresentation(v))),
            "HIDDEN_ELEMENT_OVER_RIDING_STYLED_ITEM" => HiddenElementOverRidingStyledItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::HiddenElementOverRidingStyledItem(v))),
            "HOLE_BOTTOM" => HoleBottom_::parse_chunks(strs).map(|(s, v)| (s, Entity::HoleBottom(v))),
            "HOLE_IN_PANEL" => HoleInPanel_::parse_chunks(strs).map(|(s, v)| (s, Entity::HoleInPanel(v))),
            "HOMOKINETIC_PAIR" => HomokineticPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::HomokineticPair(v))),
            "HYPERBOLA" => Hyperbola_::parse_chunks(strs).map(|(s, v)| (s, Entity::Hyperbola(v))),
            "ID_ATTRIBUTE" => IdAttribute_::parse_chunks(strs).map(|(s, v)| (s, Entity::IdAttribute(v))),
            "IDENTIFICATION_ASSIGNMENT" => IdentificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::IdentificationAssignment(v))),
            "IDENTIFICATION_ROLE" => IdentificationRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::IdentificationRole(v))),
            "INCLUSION_PRODUCT_CONCEPT_FEATURE" => InclusionProductConceptFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::InclusionProductConceptFeature(v))),
            "INDEX_EXPRESSION" => IndexExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::IndexExpression(v))),
            "INITIAL_STATE" => InitialState_::parse_chunks(strs).map(|(s, v)| (s, Entity::InitialState(v))),
            "INSTANCED_FEATURE" => InstancedFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::InstancedFeature(v))),
            "INT_LITERAL" => IntLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntLiteral(v))),
            "INT_NUMERIC_VARIABLE" => IntNumericVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntNumericVariable(v))),
            "INT_VALUE_FUNCTION" => IntValueFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntValueFunction(v))),
            "INTEGER_DEFINED_FUNCTION" => IntegerDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntegerDefinedFunction(v))),
            "INTERPOLATED_CONFIGURATION_SEQUENCE" => InterpolatedConfigurationSequence_::parse_chunks(strs).map(|(s, v)| (s, Entity::InterpolatedConfigurationSequence(v))),
            "INTERSECTION_CURVE" => IntersectionCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntersectionCurve(v))),
            "INTERVAL_EXPRESSION" => IntervalExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntervalExpression(v))),
            "INVISIBILITY" => Invisibility_::parse_chunks(strs).map(|(s, v)| (s, Entity::Invisibility(v))),
            "ITEM_DEFINED_TRANSFORMATION" => ItemDefinedTransformation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ItemDefinedTransformation(v))),
            "ITEM_IDENTIFIED_REPRESENTATION_USAGE" => ItemIdentifiedRepresentationUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::ItemIdentifiedRepresentationUsage(v))),
            "JOGGLE" => Joggle_::parse_chunks(strs).map(|(s, v)| (s, Entity::Joggle(v))),
            "JOGGLE_TERMINATION" => JoggleTermination_::parse_chunks(strs).map(|(s, v)| (s, Entity::JoggleTermination(v))),
            "KINEMATIC_ANALYSIS_CONSISTENCY" => KinematicAnalysisConsistency_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicAnalysisConsistency(v))),
            "KINEMATIC_ANALYSIS_RESULT" => KinematicAnalysisResult_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicAnalysisResult(v))),
            "KINEMATIC_CONTROL" => KinematicControl_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicControl(v))),
            "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION" => KinematicFrameBackgroundRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicFrameBackgroundRepresentation(v))),
            "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION_ASSOCIATION" => KinematicFrameBackgroundRepresentationAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicFrameBackgroundRepresentationAssociation(v))),
            "KINEMATIC_FRAME_BASED_TRANSFORMATION" => KinematicFrameBasedTransformation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicFrameBasedTransformation(v))),
            "KINEMATIC_GROUND_REPRESENTATION" => KinematicGroundRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicGroundRepresentation(v))),
            "KINEMATIC_JOINT" => KinematicJoint_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicJoint(v))),
            "KINEMATIC_LINK" => KinematicLink_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicLink(v))),
            "KINEMATIC_LINK_REPRESENTATION" => KinematicLinkRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicLinkRepresentation(v))),
            "KINEMATIC_LINK_REPRESENTATION_ASSOCIATION" => KinematicLinkRepresentationAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicLinkRepresentationAssociation(v))),
            "KINEMATIC_LINK_REPRESENTATION_RELATION" => KinematicLinkRepresentationRelation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicLinkRepresentationRelation(v))),
            "KINEMATIC_PAIR" => KinematicPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicPair(v))),
            "KINEMATIC_PATH" => KinematicPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicPath(v))),
            "KINEMATIC_PROPERTY_DEFINITION" => KinematicPropertyDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicPropertyDefinition(v))),
            "KINEMATIC_PROPERTY_REPRESENTATION_RELATION" => KinematicPropertyRepresentationRelation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicPropertyRepresentationRelation(v))),
            "KINEMATIC_STRUCTURE" => KinematicStructure_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicStructure(v))),
            "KNOWN_SOURCE" => KnownSource_::parse_chunks(strs).map(|(s, v)| (s, Entity::KnownSource(v))),
            "LANGUAGE" => Language_::parse_chunks(strs).map(|(s, v)| (s, Entity::Language(v))),
            "LANGUAGE_ASSIGNMENT" => LanguageAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::LanguageAssignment(v))),
            "LEADER_CURVE" => LeaderCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::LeaderCurve(v))),
            "LEADER_DIRECTED_CALLOUT" => LeaderDirectedCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::LeaderDirectedCallout(v))),
            "LEADER_DIRECTED_DIMENSION" => LeaderDirectedDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::LeaderDirectedDimension(v))),
            "LEADER_TERMINATOR" => LeaderTerminator_::parse_chunks(strs).map(|(s, v)| (s, Entity::LeaderTerminator(v))),
            "LENGTH_FUNCTION" => LengthFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::LengthFunction(v))),
            "LENGTH_MEASURE_WITH_UNIT" => LengthMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::LengthMeasureWithUnit(v))),
            "LENGTH_UNIT" => LengthUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::LengthUnit(v))),
            "LIGHT_SOURCE" => LightSource_::parse_chunks(strs).map(|(s, v)| (s, Entity::LightSource(v))),
            "LIGHT_SOURCE_AMBIENT" => LightSourceAmbient_::parse_chunks(strs).map(|(s, v)| (s, Entity::LightSourceAmbient(v))),
            "LIGHT_SOURCE_DIRECTIONAL" => LightSourceDirectional_::parse_chunks(strs).map(|(s, v)| (s, Entity::LightSourceDirectional(v))),
            "LIGHT_SOURCE_POSITIONAL" => LightSourcePositional_::parse_chunks(strs).map(|(s, v)| (s, Entity::LightSourcePositional(v))),
            "LIGHT_SOURCE_SPOT" => LightSourceSpot_::parse_chunks(strs).map(|(s, v)| (s, Entity::LightSourceSpot(v))),
            "LIKE_EXPRESSION" => LikeExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::LikeExpression(v))),
            "LIMITS_AND_FITS" => LimitsAndFits_::parse_chunks(strs).map(|(s, v)| (s, Entity::LimitsAndFits(v))),
            "LINE" => Line_::parse_chunks(strs).map(|(s, v)| (s, Entity::Line(v))),
            "LINE_PROFILE_TOLERANCE" => LineProfileTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::LineProfileTolerance(v))),
            "LINEAR_DIMENSION" => LinearDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::LinearDimension(v))),
            "LITERAL_NUMBER" => LiteralNumber_::parse_chunks(strs).map(|(s, v)| (s, Entity::LiteralNumber(v))),
            "LOCAL_TIME" => LocalTime_::parse_chunks(strs).map(|(s, v)| (s, Entity::LocalTime(v))),
            "LOCATION_SHAPE_REPRESENTATION" => LocationShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::LocationShapeRepresentation(v))),
            "LOCATOR" => Locator_::parse_chunks(strs).map(|(s, v)| (s, Entity::Locator(v))),
            "LOG10_FUNCTION" => Log10Function_::parse_chunks(strs).map(|(s, v)| (s, Entity::Log10Function(v))),
            "LOG2_FUNCTION" => Log2Function_::parse_chunks(strs).map(|(s, v)| (s, Entity::Log2Function(v))),
            "LOG_FUNCTION" => LogFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::LogFunction(v))),
            "LOOP" => Loop_::parse_chunks(strs).map(|(s, v)| (s, Entity::Loop(v))),
            "LOT_EFFECTIVITY" => LotEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::LotEffectivity(v))),
            "LUMINOUS_INTENSITY_MEASURE_WITH_UNIT" => LuminousIntensityMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::LuminousIntensityMeasureWithUnit(v))),
            "LUMINOUS_INTENSITY_UNIT" => LuminousIntensityUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::LuminousIntensityUnit(v))),
            "MAKE_FROM_USAGE_OPTION" => MakeFromUsageOption_::parse_chunks(strs).map(|(s, v)| (s, Entity::MakeFromUsageOption(v))),
            "MANIFOLD_SOLID_BREP" => ManifoldSolidBrep_::parse_chunks(strs).map(|(s, v)| (s, Entity::ManifoldSolidBrep(v))),
            "MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION" => ManifoldSubsurfaceShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ManifoldSubsurfaceShapeRepresentation(v))),
            "MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => ManifoldSurfaceShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ManifoldSurfaceShapeRepresentation(v))),
            "MAPPED_ITEM" => MappedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::MappedItem(v))),
            "MASS_MEASURE_WITH_UNIT" => MassMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::MassMeasureWithUnit(v))),
            "MASS_UNIT" => MassUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::MassUnit(v))),
            "MATERIAL_DESIGNATION" => MaterialDesignation_::parse_chunks(strs).map(|(s, v)| (s, Entity::MaterialDesignation(v))),
            "MATERIAL_DESIGNATION_CHARACTERIZATION" => MaterialDesignationCharacterization_::parse_chunks(strs).map(|(s, v)| (s, Entity::MaterialDesignationCharacterization(v))),
            "MATERIAL_PROPERTY" => MaterialProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::MaterialProperty(v))),
            "MATERIAL_PROPERTY_REPRESENTATION" => MaterialPropertyRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::MaterialPropertyRepresentation(v))),
            "MAXIMUM_FUNCTION" => MaximumFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::MaximumFunction(v))),
            "MEASURE_QUALIFICATION" => MeasureQualification_::parse_chunks(strs).map(|(s, v)| (s, Entity::MeasureQualification(v))),
            "MEASURE_REPRESENTATION_ITEM" => MeasureRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::MeasureRepresentationItem(v))),
            "MEASURE_WITH_UNIT" => MeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::MeasureWithUnit(v))),
            "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_AREA" => MechanicalDesignGeometricPresentationArea_::parse_chunks(strs).map(|(s, v)| (s, Entity::MechanicalDesignGeometricPresentationArea(v))),
            "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION" => MechanicalDesignGeometricPresentationRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::MechanicalDesignGeometricPresentationRepresentation(v))),
            "MECHANISM" => Mechanism_::parse_chunks(strs).map(|(s, v)| (s, Entity::Mechanism(v))),
            "MECHANISM_BASE_PLACEMENT" => MechanismBasePlacement_::parse_chunks(strs).map(|(s, v)| (s, Entity::MechanismBasePlacement(v))),
            "MINIMUM_FUNCTION" => MinimumFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::MinimumFunction(v))),
            "MINUS_EXPRESSION" => MinusExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::MinusExpression(v))),
            "MINUS_FUNCTION" => MinusFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::MinusFunction(v))),
            "MOD_EXPRESSION" => ModExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::ModExpression(v))),
            "MODIFIED_GEOMETRIC_TOLERANCE" => ModifiedGeometricTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::ModifiedGeometricTolerance(v))),
            "MODIFIED_PATTERN" => ModifiedPattern_::parse_chunks(strs).map(|(s, v)| (s, Entity::ModifiedPattern(v))),
            "MOMENTS_OF_INERTIA_REPRESENTATION" => MomentsOfInertiaRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::MomentsOfInertiaRepresentation(v))),
            "MOTION_LINK_RELATIONSHIP" => MotionLinkRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::MotionLinkRelationship(v))),
            "MULT_EXPRESSION" => MultExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultExpression(v))),
            "MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT" => MultiLanguageAttributeAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultiLanguageAttributeAssignment(v))),
            "MULTIPLE_ARITY_BOOLEAN_EXPRESSION" => MultipleArityBooleanExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultipleArityBooleanExpression(v))),
            "MULTIPLE_ARITY_FUNCTION_CALL" => MultipleArityFunctionCall_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultipleArityFunctionCall(v))),
            "MULTIPLE_ARITY_GENERIC_EXPRESSION" => MultipleArityGenericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultipleArityGenericExpression(v))),
            "MULTIPLE_ARITY_NUMERIC_EXPRESSION" => MultipleArityNumericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultipleArityNumericExpression(v))),
            "NAME_ASSIGNMENT" => NameAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::NameAssignment(v))),
            "NAME_ATTRIBUTE" => NameAttribute_::parse_chunks(strs).map(|(s, v)| (s, Entity::NameAttribute(v))),
            "NAMED_UNIT" => NamedUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::NamedUnit(v))),
            "NAMED_UNIT_VARIABLE" => NamedUnitVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::NamedUnitVariable(v))),
            "NEXT_ASSEMBLY_USAGE_OCCURRENCE" => NextAssemblyUsageOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::NextAssemblyUsageOccurrence(v))),
            "NGON_CLOSED_PROFILE" => NgonClosedProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::NgonClosedProfile(v))),
            "NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => NonManifoldSurfaceShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::NonManifoldSurfaceShapeRepresentation(v))),
            "NOT_EXPRESSION" => NotExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::NotExpression(v))),
            "NUMERIC_DEFINED_FUNCTION" => NumericDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::NumericDefinedFunction(v))),
            "NUMERIC_EXPRESSION" => NumericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::NumericExpression(v))),
            "NUMERIC_VARIABLE" => NumericVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::NumericVariable(v))),
            "OBJECT_ROLE" => ObjectRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::ObjectRole(v))),
            "ODD_FUNCTION" => OddFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::OddFunction(v))),
            "OFFSET_CURVE_2D" => OffsetCurve2d_::parse_chunks(strs).map(|(s, v)| (s, Entity::OffsetCurve2d(v))),
            "OFFSET_CURVE_3D" => OffsetCurve3d_::parse_chunks(strs).map(|(s, v)| (s, Entity::OffsetCurve3d(v))),
            "OFFSET_SURFACE" => OffsetSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::OffsetSurface(v))),
            "ONE_DIRECTION_REPEAT_FACTOR" => OneDirectionRepeatFactor_::parse_chunks(strs).map(|(s, v)| (s, Entity::OneDirectionRepeatFactor(v))),
            "OPEN_PATH_PROFILE" => OpenPathProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::OpenPathProfile(v))),
            "OPEN_SHELL" => OpenShell_::parse_chunks(strs).map(|(s, v)| (s, Entity::OpenShell(v))),
            "OR_EXPRESSION" => OrExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrExpression(v))),
            "ORDINATE_DIMENSION" => OrdinateDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrdinateDimension(v))),
            "ORGANIZATION" => Organization_::parse_chunks(strs).map(|(s, v)| (s, Entity::Organization(v))),
            "ORGANIZATION_ASSIGNMENT" => OrganizationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationAssignment(v))),
            "ORGANIZATION_RELATIONSHIP" => OrganizationRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationRelationship(v))),
            "ORGANIZATION_ROLE" => OrganizationRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationRole(v))),
            "ORGANIZATIONAL_ADDRESS" => OrganizationalAddress_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationalAddress(v))),
            "ORGANIZATIONAL_PROJECT" => OrganizationalProject_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationalProject(v))),
            "ORGANIZATIONAL_PROJECT_ASSIGNMENT" => OrganizationalProjectAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationalProjectAssignment(v))),
            "ORGANIZATIONAL_PROJECT_RELATIONSHIP" => OrganizationalProjectRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationalProjectRelationship(v))),
            "ORGANIZATIONAL_PROJECT_ROLE" => OrganizationalProjectRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationalProjectRole(v))),
            "ORIENTED_CLOSED_SHELL" => OrientedClosedShell_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedClosedShell(v))),
            "ORIENTED_EDGE" => OrientedEdge_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedEdge(v))),
            "ORIENTED_FACE" => OrientedFace_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedFace(v))),
            "ORIENTED_OPEN_SHELL" => OrientedOpenShell_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedOpenShell(v))),
            "ORIENTED_PATH" => OrientedPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedPath(v))),
            "ORIENTED_SURFACE" => OrientedSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedSurface(v))),
            "OUTER_BOUNDARY_CURVE" => OuterBoundaryCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::OuterBoundaryCurve(v))),
            "OVER_RIDING_STYLED_ITEM" => OverRidingStyledItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::OverRidingStyledItem(v))),
            "PACKAGE_PRODUCT_CONCEPT_FEATURE" => PackageProductConceptFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::PackageProductConceptFeature(v))),
            "PAIR_ACTUATOR" => PairActuator_::parse_chunks(strs).map(|(s, v)| (s, Entity::PairActuator(v))),
            "PAIR_VALUE" => PairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::PairValue(v))),
            "PARABOLA" => Parabola_::parse_chunks(strs).map(|(s, v)| (s, Entity::Parabola(v))),
            "PARALLEL_OFFSET" => ParallelOffset_::parse_chunks(strs).map(|(s, v)| (s, Entity::ParallelOffset(v))),
            "PARALLELISM_TOLERANCE" => ParallelismTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::ParallelismTolerance(v))),
            "PARAMETRIC_REPRESENTATION_CONTEXT" => ParametricRepresentationContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::ParametricRepresentationContext(v))),
            "PARTIAL_CIRCULAR_PROFILE" => PartialCircularProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::PartialCircularProfile(v))),
            "PATH" => Path_::parse_chunks(strs).map(|(s, v)| (s, Entity::Path(v))),
            "PATH_FEATURE_COMPONENT" => PathFeatureComponent_::parse_chunks(strs).map(|(s, v)| (s, Entity::PathFeatureComponent(v))),
            "PATH_SHAPE_REPRESENTATION" => PathShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PathShapeRepresentation(v))),
            "PATTERN_OFFSET_MEMBERSHIP" => PatternOffsetMembership_::parse_chunks(strs).map(|(s, v)| (s, Entity::PatternOffsetMembership(v))),
            "PATTERN_OMIT_MEMBERSHIP" => PatternOmitMembership_::parse_chunks(strs).map(|(s, v)| (s, Entity::PatternOmitMembership(v))),
            "PCURVE" => Pcurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::Pcurve(v))),
            "PERPENDICULAR_TO" => PerpendicularTo_::parse_chunks(strs).map(|(s, v)| (s, Entity::PerpendicularTo(v))),
            "PERPENDICULARITY_TOLERANCE" => PerpendicularityTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::PerpendicularityTolerance(v))),
            "PERSON" => Person_::parse_chunks(strs).map(|(s, v)| (s, Entity::Person(v))),
            "PERSON_AND_ORGANIZATION" => PersonAndOrganization_::parse_chunks(strs).map(|(s, v)| (s, Entity::PersonAndOrganization(v))),
            "PERSON_AND_ORGANIZATION_ADDRESS" => PersonAndOrganizationAddress_::parse_chunks(strs).map(|(s, v)| (s, Entity::PersonAndOrganizationAddress(v))),
            "PERSON_AND_ORGANIZATION_ASSIGNMENT" => PersonAndOrganizationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::PersonAndOrganizationAssignment(v))),
            "PERSON_AND_ORGANIZATION_ROLE" => PersonAndOrganizationRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::PersonAndOrganizationRole(v))),
            "PERSONAL_ADDRESS" => PersonalAddress_::parse_chunks(strs).map(|(s, v)| (s, Entity::PersonalAddress(v))),
            "PHYSICALLY_MODELLED_PRODUCT_DEFINITION" => PhysicallyModelledProductDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::PhysicallyModelledProductDefinition(v))),
            "PLACED_DATUM_TARGET_FEATURE" => PlacedDatumTargetFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlacedDatumTargetFeature(v))),
            "PLACED_FEATURE" => PlacedFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlacedFeature(v))),
            "PLACEMENT" => Placement_::parse_chunks(strs).map(|(s, v)| (s, Entity::Placement(v))),
            "PLANAR_BOX" => PlanarBox_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarBox(v))),
            "PLANAR_CURVE_PAIR" => PlanarCurvePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarCurvePair(v))),
            "PLANAR_CURVE_PAIR_RANGE" => PlanarCurvePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarCurvePairRange(v))),
            "PLANAR_EXTENT" => PlanarExtent_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarExtent(v))),
            "PLANAR_PAIR" => PlanarPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarPair(v))),
            "PLANAR_PAIR_RANGE" => PlanarPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarPairRange(v))),
            "PLANAR_PAIR_VALUE" => PlanarPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarPairValue(v))),
            "PLANAR_SHAPE_REPRESENTATION" => PlanarShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarShapeRepresentation(v))),
            "PLANE" => Plane_::parse_chunks(strs).map(|(s, v)| (s, Entity::Plane(v))),
            "PLANE_ANGLE_MEASURE_WITH_UNIT" => PlaneAngleMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlaneAngleMeasureWithUnit(v))),
            "PLANE_ANGLE_UNIT" => PlaneAngleUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlaneAngleUnit(v))),
            "PLUS_EXPRESSION" => PlusExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlusExpression(v))),
            "PLUS_MINUS_TOLERANCE" => PlusMinusTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlusMinusTolerance(v))),
            "POCKET" => Pocket_::parse_chunks(strs).map(|(s, v)| (s, Entity::Pocket(v))),
            "POCKET_BOTTOM" => PocketBottom_::parse_chunks(strs).map(|(s, v)| (s, Entity::PocketBottom(v))),
            "POINT" => Point_::parse_chunks(strs).map(|(s, v)| (s, Entity::Point(v))),
            "POINT_ON_CURVE" => PointOnCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnCurve(v))),
            "POINT_ON_PLANAR_CURVE_PAIR" => PointOnPlanarCurvePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnPlanarCurvePair(v))),
            "POINT_ON_PLANAR_CURVE_PAIR_RANGE" => PointOnPlanarCurvePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnPlanarCurvePairRange(v))),
            "POINT_ON_PLANAR_CURVE_PAIR_VALUE" => PointOnPlanarCurvePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnPlanarCurvePairValue(v))),
            "POINT_ON_SURFACE" => PointOnSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnSurface(v))),
            "POINT_ON_SURFACE_PAIR" => PointOnSurfacePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnSurfacePair(v))),
            "POINT_ON_SURFACE_PAIR_RANGE" => PointOnSurfacePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnSurfacePairRange(v))),
            "POINT_ON_SURFACE_PAIR_VALUE" => PointOnSurfacePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnSurfacePairValue(v))),
            "POINT_PLACEMENT_SHAPE_REPRESENTATION" => PointPlacementShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointPlacementShapeRepresentation(v))),
            "POINT_REPLICA" => PointReplica_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointReplica(v))),
            "POINT_STYLE" => PointStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointStyle(v))),
            "POLY_LOOP" => PolyLoop_::parse_chunks(strs).map(|(s, v)| (s, Entity::PolyLoop(v))),
            "POLYLINE" => Polyline_::parse_chunks(strs).map(|(s, v)| (s, Entity::Polyline(v))),
            "POSITION_TOLERANCE" => PositionTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::PositionTolerance(v))),
            "POWER_EXPRESSION" => PowerExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::PowerExpression(v))),
            "PRE_DEFINED_COLOUR" => PreDefinedColour_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedColour(v))),
            "PRE_DEFINED_CURVE_FONT" => PreDefinedCurveFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedCurveFont(v))),
            "PRE_DEFINED_DIMENSION_SYMBOL" => PreDefinedDimensionSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedDimensionSymbol(v))),
            "PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL" => PreDefinedGeometricalToleranceSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedGeometricalToleranceSymbol(v))),
            "PRE_DEFINED_ITEM" => PreDefinedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedItem(v))),
            "PRE_DEFINED_MARKER" => PreDefinedMarker_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedMarker(v))),
            "PRE_DEFINED_POINT_MARKER_SYMBOL" => PreDefinedPointMarkerSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedPointMarkerSymbol(v))),
            "PRE_DEFINED_PRESENTATION_STYLE" => PreDefinedPresentationStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedPresentationStyle(v))),
            "PRE_DEFINED_SURFACE_CONDITION_SYMBOL" => PreDefinedSurfaceConditionSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedSurfaceConditionSymbol(v))),
            "PRE_DEFINED_SYMBOL" => PreDefinedSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedSymbol(v))),
            "PRE_DEFINED_TERMINATOR_SYMBOL" => PreDefinedTerminatorSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedTerminatorSymbol(v))),
            "PRE_DEFINED_TEXT_FONT" => PreDefinedTextFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedTextFont(v))),
            "PRECISION_QUALIFIER" => PrecisionQualifier_::parse_chunks(strs).map(|(s, v)| (s, Entity::PrecisionQualifier(v))),
            "PRESENTATION_AREA" => PresentationArea_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationArea(v))),
            "PRESENTATION_LAYER_ASSIGNMENT" => PresentationLayerAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationLayerAssignment(v))),
            "PRESENTATION_REPRESENTATION" => PresentationRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationRepresentation(v))),
            "PRESENTATION_SET" => PresentationSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationSet(v))),
            "PRESENTATION_SIZE" => PresentationSize_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationSize(v))),
            "PRESENTATION_STYLE_ASSIGNMENT" => PresentationStyleAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationStyleAssignment(v))),
            "PRESENTATION_STYLE_BY_CONTEXT" => PresentationStyleByContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationStyleByContext(v))),
            "PRESENTATION_VIEW" => PresentationView_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationView(v))),
            "PRESENTED_ITEM" => PresentedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentedItem(v))),
            "PRESENTED_ITEM_REPRESENTATION" => PresentedItemRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentedItemRepresentation(v))),
            "PRISMATIC_PAIR" => PrismaticPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::PrismaticPair(v))),
            "PRISMATIC_PAIR_RANGE" => PrismaticPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::PrismaticPairRange(v))),
            "PRISMATIC_PAIR_VALUE" => PrismaticPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::PrismaticPairValue(v))),
            "PROCESS_OPERATION" => ProcessOperation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProcessOperation(v))),
            "PROCESS_PLAN" => ProcessPlan_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProcessPlan(v))),
            "PROCESS_PRODUCT_ASSOCIATION" => ProcessProductAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProcessProductAssociation(v))),
            "PROCESS_PROPERTY_ASSOCIATION" => ProcessPropertyAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProcessPropertyAssociation(v))),
            "PRODUCT" => Product_::parse_chunks(strs).map(|(s, v)| (s, Entity::Product(v))),
            "PRODUCT_CATEGORY" => ProductCategory_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductCategory(v))),
            "PRODUCT_CATEGORY_RELATIONSHIP" => ProductCategoryRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductCategoryRelationship(v))),
            "PRODUCT_CLASS" => ProductClass_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductClass(v))),
            "PRODUCT_CONCEPT" => ProductConcept_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConcept(v))),
            "PRODUCT_CONCEPT_CONTEXT" => ProductConceptContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptContext(v))),
            "PRODUCT_CONCEPT_FEATURE" => ProductConceptFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptFeature(v))),
            "PRODUCT_CONCEPT_FEATURE_ASSOCIATION" => ProductConceptFeatureAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptFeatureAssociation(v))),
            "PRODUCT_CONCEPT_FEATURE_CATEGORY" => ProductConceptFeatureCategory_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptFeatureCategory(v))),
            "PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE" => ProductConceptFeatureCategoryUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptFeatureCategoryUsage(v))),
            "PRODUCT_CONCEPT_RELATIONSHIP" => ProductConceptRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptRelationship(v))),
            "PRODUCT_CONTEXT" => ProductContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductContext(v))),
            "PRODUCT_DEFINITION" => ProductDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinition(v))),
            "PRODUCT_DEFINITION_CONTEXT" => ProductDefinitionContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionContext(v))),
            "PRODUCT_DEFINITION_CONTEXT_ASSOCIATION" => ProductDefinitionContextAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionContextAssociation(v))),
            "PRODUCT_DEFINITION_CONTEXT_ROLE" => ProductDefinitionContextRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionContextRole(v))),
            "PRODUCT_DEFINITION_EFFECTIVITY" => ProductDefinitionEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionEffectivity(v))),
            "PRODUCT_DEFINITION_FORMATION" => ProductDefinitionFormation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionFormation(v))),
            "PRODUCT_DEFINITION_FORMATION_RELATIONSHIP" => ProductDefinitionFormationRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionFormationRelationship(v))),
            "PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE" => ProductDefinitionFormationWithSpecifiedSource_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionFormationWithSpecifiedSource(v))),
            "PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP" => ProductDefinitionOccurrenceRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionOccurrenceRelationship(v))),
            "PRODUCT_DEFINITION_PROCESS" => ProductDefinitionProcess_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionProcess(v))),
            "PRODUCT_DEFINITION_RELATIONSHIP" => ProductDefinitionRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionRelationship(v))),
            "PRODUCT_DEFINITION_RESOURCE" => ProductDefinitionResource_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionResource(v))),
            "PRODUCT_DEFINITION_SHAPE" => ProductDefinitionShape_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionShape(v))),
            "PRODUCT_DEFINITION_SUBSTITUTE" => ProductDefinitionSubstitute_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionSubstitute(v))),
            "PRODUCT_DEFINITION_USAGE" => ProductDefinitionUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionUsage(v))),
            "PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS" => ProductDefinitionWithAssociatedDocuments_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionWithAssociatedDocuments(v))),
            "PRODUCT_IDENTIFICATION" => ProductIdentification_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductIdentification(v))),
            "PRODUCT_PROCESS_PLAN" => ProductProcessPlan_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductProcessPlan(v))),
            "PRODUCT_RELATED_PRODUCT_CATEGORY" => ProductRelatedProductCategory_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductRelatedProductCategory(v))),
            "PRODUCT_SPECIFICATION" => ProductSpecification_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductSpecification(v))),
            "PROJECTED_ZONE_DEFINITION" => ProjectedZoneDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProjectedZoneDefinition(v))),
            "PROJECTION_CURVE" => ProjectionCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProjectionCurve(v))),
            "PROJECTION_DIRECTED_CALLOUT" => ProjectionDirectedCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProjectionDirectedCallout(v))),
            "PROMISSORY_USAGE_OCCURRENCE" => PromissoryUsageOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::PromissoryUsageOccurrence(v))),
            "PROPERTY_DEFINITION" => PropertyDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::PropertyDefinition(v))),
            "PROPERTY_DEFINITION_RELATIONSHIP" => PropertyDefinitionRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::PropertyDefinitionRelationship(v))),
            "PROPERTY_DEFINITION_REPRESENTATION" => PropertyDefinitionRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PropertyDefinitionRepresentation(v))),
            "PROPERTY_PROCESS" => PropertyProcess_::parse_chunks(strs).map(|(s, v)| (s, Entity::PropertyProcess(v))),
            "QUALIFIED_REPRESENTATION_ITEM" => QualifiedRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::QualifiedRepresentationItem(v))),
            "QUALITATIVE_UNCERTAINTY" => QualitativeUncertainty_::parse_chunks(strs).map(|(s, v)| (s, Entity::QualitativeUncertainty(v))),
            "QUANTIFIED_ASSEMBLY_COMPONENT_USAGE" => QuantifiedAssemblyComponentUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::QuantifiedAssemblyComponentUsage(v))),
            "QUASI_UNIFORM_CURVE" => QuasiUniformCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::QuasiUniformCurve(v))),
            "QUASI_UNIFORM_SURFACE" => QuasiUniformSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::QuasiUniformSurface(v))),
            "RACK_AND_PINION_PAIR" => RackAndPinionPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::RackAndPinionPair(v))),
            "RACK_AND_PINION_PAIR_RANGE" => RackAndPinionPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::RackAndPinionPairRange(v))),
            "RACK_AND_PINION_PAIR_VALUE" => RackAndPinionPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::RackAndPinionPairValue(v))),
            "RADIUS_DIMENSION" => RadiusDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::RadiusDimension(v))),
            "RATIO_MEASURE_WITH_UNIT" => RatioMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::RatioMeasureWithUnit(v))),
            "RATIO_UNIT" => RatioUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::RatioUnit(v))),
            "RATIONAL_B_SPLINE_CURVE" => RationalBSplineCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::RationalBSplineCurve(v))),
            "RATIONAL_B_SPLINE_SURFACE" => RationalBSplineSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::RationalBSplineSurface(v))),
            "REAL_DEFINED_FUNCTION" => RealDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::RealDefinedFunction(v))),
            "REAL_LITERAL" => RealLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::RealLiteral(v))),
            "REAL_NUMERIC_VARIABLE" => RealNumericVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::RealNumericVariable(v))),
            "RECTANGULAR_CLOSED_PROFILE" => RectangularClosedProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::RectangularClosedProfile(v))),
            "RECTANGULAR_COMPOSITE_SURFACE" => RectangularCompositeSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::RectangularCompositeSurface(v))),
            "RECTANGULAR_PATTERN" => RectangularPattern_::parse_chunks(strs).map(|(s, v)| (s, Entity::RectangularPattern(v))),
            "RECTANGULAR_TRIMMED_SURFACE" => RectangularTrimmedSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::RectangularTrimmedSurface(v))),
            "REFERENCED_MODIFIED_DATUM" => ReferencedModifiedDatum_::parse_chunks(strs).map(|(s, v)| (s, Entity::ReferencedModifiedDatum(v))),
            "RELATIVE_EVENT_OCCURRENCE" => RelativeEventOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::RelativeEventOccurrence(v))),
            "REP_ITEM_GROUP" => RepItemGroup_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepItemGroup(v))),
            "REPARAMETRISED_COMPOSITE_CURVE_SEGMENT" => ReparametrisedCompositeCurveSegment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ReparametrisedCompositeCurveSegment(v))),
            "REPLICATE_FEATURE" => ReplicateFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::ReplicateFeature(v))),
            "REPRESENTATION" => Representation_::parse_chunks(strs).map(|(s, v)| (s, Entity::Representation(v))),
            "REPRESENTATION_CONTEXT" => RepresentationContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepresentationContext(v))),
            "REPRESENTATION_ITEM" => RepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepresentationItem(v))),
            "REPRESENTATION_MAP" => RepresentationMap_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepresentationMap(v))),
            "REPRESENTATION_RELATIONSHIP" => RepresentationRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepresentationRelationship(v))),
            "REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION" => RepresentationRelationshipWithTransformation_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepresentationRelationshipWithTransformation(v))),
            "REQUIREMENT_FOR_ACTION_RESOURCE" => RequirementForActionResource_::parse_chunks(strs).map(|(s, v)| (s, Entity::RequirementForActionResource(v))),
            "RESOURCE_PROPERTY" => ResourceProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::ResourceProperty(v))),
            "RESOURCE_PROPERTY_REPRESENTATION" => ResourcePropertyRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ResourcePropertyRepresentation(v))),
            "RESOURCE_REQUIREMENT_TYPE" => ResourceRequirementType_::parse_chunks(strs).map(|(s, v)| (s, Entity::ResourceRequirementType(v))),
            "RESULTING_PATH" => ResultingPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::ResultingPath(v))),
            "RETENTION" => Retention_::parse_chunks(strs).map(|(s, v)| (s, Entity::Retention(v))),
            "REVOLUTE_PAIR" => RevolutePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::RevolutePair(v))),
            "REVOLUTE_PAIR_RANGE" => RevolutePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::RevolutePairRange(v))),
            "REVOLUTE_PAIR_VALUE" => RevolutePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::RevolutePairValue(v))),
            "REVOLVED_AREA_SOLID" => RevolvedAreaSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::RevolvedAreaSolid(v))),
            "REVOLVED_FACE_SOLID" => RevolvedFaceSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::RevolvedFaceSolid(v))),
            "RIB" => Rib_::parse_chunks(strs).map(|(s, v)| (s, Entity::Rib(v))),
            "RIGHT_ANGULAR_WEDGE" => RightAngularWedge_::parse_chunks(strs).map(|(s, v)| (s, Entity::RightAngularWedge(v))),
            "RIGHT_CIRCULAR_CONE" => RightCircularCone_::parse_chunks(strs).map(|(s, v)| (s, Entity::RightCircularCone(v))),
            "RIGHT_CIRCULAR_CYLINDER" => RightCircularCylinder_::parse_chunks(strs).map(|(s, v)| (s, Entity::RightCircularCylinder(v))),
            "ROLE_ASSOCIATION" => RoleAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::RoleAssociation(v))),
            "ROLLING_CURVE_PAIR" => RollingCurvePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::RollingCurvePair(v))),
            "ROLLING_CURVE_PAIR_VALUE" => RollingCurvePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::RollingCurvePairValue(v))),
            "ROLLING_SURFACE_PAIR" => RollingSurfacePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::RollingSurfacePair(v))),
            "ROLLING_SURFACE_PAIR_VALUE" => RollingSurfacePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::RollingSurfacePairValue(v))),
            "ROTATION_ABOUT_DIRECTION" => RotationAboutDirection_::parse_chunks(strs).map(|(s, v)| (s, Entity::RotationAboutDirection(v))),
            "ROUND_HOLE" => RoundHole_::parse_chunks(strs).map(|(s, v)| (s, Entity::RoundHole(v))),
            "ROUNDED_U_PROFILE" => RoundedUProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::RoundedUProfile(v))),
            "ROUNDNESS_TOLERANCE" => RoundnessTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::RoundnessTolerance(v))),
            "RULED_SURFACE_SWEPT_AREA_SOLID" => RuledSurfaceSweptAreaSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::RuledSurfaceSweptAreaSolid(v))),
            "RUNOUT_ZONE_DEFINITION" => RunoutZoneDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::RunoutZoneDefinition(v))),
            "RUNOUT_ZONE_ORIENTATION" => RunoutZoneOrientation_::parse_chunks(strs).map(|(s, v)| (s, Entity::RunoutZoneOrientation(v))),
            "RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION" => RunoutZoneOrientationReferenceDirection_::parse_chunks(strs).map(|(s, v)| (s, Entity::RunoutZoneOrientationReferenceDirection(v))),
            "SCREW_PAIR" => ScrewPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::ScrewPair(v))),
            "SCREW_PAIR_RANGE" => ScrewPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::ScrewPairRange(v))),
            "SCREW_PAIR_VALUE" => ScrewPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::ScrewPairValue(v))),
            "SEAM_CURVE" => SeamCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::SeamCurve(v))),
            "SEAM_EDGE" => SeamEdge_::parse_chunks(strs).map(|(s, v)| (s, Entity::SeamEdge(v))),
            "SECURITY_CLASSIFICATION" => SecurityClassification_::parse_chunks(strs).map(|(s, v)| (s, Entity::SecurityClassification(v))),
            "SECURITY_CLASSIFICATION_ASSIGNMENT" => SecurityClassificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::SecurityClassificationAssignment(v))),
            "SECURITY_CLASSIFICATION_LEVEL" => SecurityClassificationLevel_::parse_chunks(strs).map(|(s, v)| (s, Entity::SecurityClassificationLevel(v))),
            "SERIAL_NUMBERED_EFFECTIVITY" => SerialNumberedEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::SerialNumberedEffectivity(v))),
            "SHAPE_ASPECT" => ShapeAspect_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeAspect(v))),
            "SHAPE_ASPECT_ASSOCIATIVITY" => ShapeAspectAssociativity_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeAspectAssociativity(v))),
            "SHAPE_ASPECT_DERIVING_RELATIONSHIP" => ShapeAspectDerivingRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeAspectDerivingRelationship(v))),
            "SHAPE_ASPECT_RELATIONSHIP" => ShapeAspectRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeAspectRelationship(v))),
            "SHAPE_ASPECT_TRANSITION" => ShapeAspectTransition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeAspectTransition(v))),
            "SHAPE_DEFINING_RELATIONSHIP" => ShapeDefiningRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeDefiningRelationship(v))),
            "SHAPE_DEFINITION_REPRESENTATION" => ShapeDefinitionRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeDefinitionRepresentation(v))),
            "SHAPE_DIMENSION_REPRESENTATION" => ShapeDimensionRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeDimensionRepresentation(v))),
            "SHAPE_REPRESENTATION" => ShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeRepresentation(v))),
            "SHAPE_REPRESENTATION_RELATIONSHIP" => ShapeRepresentationRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeRepresentationRelationship(v))),
            "SHAPE_REPRESENTATION_WITH_PARAMETERS" => ShapeRepresentationWithParameters_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeRepresentationWithParameters(v))),
            "SHELL_BASED_SURFACE_MODEL" => ShellBasedSurfaceModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShellBasedSurfaceModel(v))),
            "SI_UNIT" => SiUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::SiUnit(v))),
            "SIMPLE_BOOLEAN_EXPRESSION" => SimpleBooleanExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SimpleBooleanExpression(v))),
            "SIMPLE_GENERIC_EXPRESSION" => SimpleGenericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SimpleGenericExpression(v))),
            "SIMPLE_NUMERIC_EXPRESSION" => SimpleNumericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SimpleNumericExpression(v))),
            "SIMPLE_PAIR_RANGE" => SimplePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::SimplePairRange(v))),
            "SIMPLE_STRING_EXPRESSION" => SimpleStringExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SimpleStringExpression(v))),
            "SIN_FUNCTION" => SinFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::SinFunction(v))),
            "SLASH_EXPRESSION" => SlashExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlashExpression(v))),
            "SLIDING_CURVE_PAIR" => SlidingCurvePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlidingCurvePair(v))),
            "SLIDING_CURVE_PAIR_VALUE" => SlidingCurvePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlidingCurvePairValue(v))),
            "SLIDING_SURFACE_PAIR" => SlidingSurfacePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlidingSurfacePair(v))),
            "SLIDING_SURFACE_PAIR_VALUE" => SlidingSurfacePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlidingSurfacePairValue(v))),
            "SLOT" => Slot_::parse_chunks(strs).map(|(s, v)| (s, Entity::Slot(v))),
            "SLOT_END" => SlotEnd_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlotEnd(v))),
            "SOLID_ANGLE_MEASURE_WITH_UNIT" => SolidAngleMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::SolidAngleMeasureWithUnit(v))),
            "SOLID_ANGLE_UNIT" => SolidAngleUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::SolidAngleUnit(v))),
            "SOLID_MODEL" => SolidModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::SolidModel(v))),
            "SOLID_REPLICA" => SolidReplica_::parse_chunks(strs).map(|(s, v)| (s, Entity::SolidReplica(v))),
            "SPECIFIED_HIGHER_USAGE_OCCURRENCE" => SpecifiedHigherUsageOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::SpecifiedHigherUsageOccurrence(v))),
            "SPHERE" => Sphere_::parse_chunks(strs).map(|(s, v)| (s, Entity::Sphere(v))),
            "SPHERICAL_PAIR" => SphericalPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::SphericalPair(v))),
            "SPHERICAL_PAIR_RANGE" => SphericalPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::SphericalPairRange(v))),
            "SPHERICAL_PAIR_VALUE" => SphericalPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::SphericalPairValue(v))),
            "SPHERICAL_SURFACE" => SphericalSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::SphericalSurface(v))),
            "SQL_MAPPABLE_DEFINED_FUNCTION" => SqlMappableDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::SqlMappableDefinedFunction(v))),
            "SQUARE_ROOT_FUNCTION" => SquareRootFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::SquareRootFunction(v))),
            "SQUARE_U_PROFILE" => SquareUProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::SquareUProfile(v))),
            "STANDARD_UNCERTAINTY" => StandardUncertainty_::parse_chunks(strs).map(|(s, v)| (s, Entity::StandardUncertainty(v))),
            "STRAIGHTNESS_TOLERANCE" => StraightnessTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::StraightnessTolerance(v))),
            "STRING_DEFINED_FUNCTION" => StringDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::StringDefinedFunction(v))),
            "STRING_EXPRESSION" => StringExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::StringExpression(v))),
            "STRING_LITERAL" => StringLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::StringLiteral(v))),
            "STRING_VARIABLE" => StringVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::StringVariable(v))),
            "STRUCTURED_DIMENSION_CALLOUT" => StructuredDimensionCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::StructuredDimensionCallout(v))),
            "STYLED_ITEM" => StyledItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::StyledItem(v))),
            "SUBEDGE" => Subedge_::parse_chunks(strs).map(|(s, v)| (s, Entity::Subedge(v))),
            "SUBFACE" => Subface_::parse_chunks(strs).map(|(s, v)| (s, Entity::Subface(v))),
            "SUBSTRING_EXPRESSION" => SubstringExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SubstringExpression(v))),
            "SURFACE" => Surface_::parse_chunks(strs).map(|(s, v)| (s, Entity::Surface(v))),
            "SURFACE_CONDITION_CALLOUT" => SurfaceConditionCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceConditionCallout(v))),
            "SURFACE_CURVE" => SurfaceCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceCurve(v))),
            "SURFACE_CURVE_SWEPT_AREA_SOLID" => SurfaceCurveSweptAreaSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceCurveSweptAreaSolid(v))),
            "SURFACE_OF_LINEAR_EXTRUSION" => SurfaceOfLinearExtrusion_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceOfLinearExtrusion(v))),
            "SURFACE_OF_REVOLUTION" => SurfaceOfRevolution_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceOfRevolution(v))),
            "SURFACE_PAIR" => SurfacePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfacePair(v))),
            "SURFACE_PAIR_RANGE" => SurfacePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfacePairRange(v))),
            "SURFACE_PATCH" => SurfacePatch_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfacePatch(v))),
            "SURFACE_PROFILE_TOLERANCE" => SurfaceProfileTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceProfileTolerance(v))),
            "SURFACE_RENDERING_PROPERTIES" => SurfaceRenderingProperties_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceRenderingProperties(v))),
            "SURFACE_REPLICA" => SurfaceReplica_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceReplica(v))),
            "SURFACE_SIDE_STYLE" => SurfaceSideStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceSideStyle(v))),
            "SURFACE_STYLE_BOUNDARY" => SurfaceStyleBoundary_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleBoundary(v))),
            "SURFACE_STYLE_CONTROL_GRID" => SurfaceStyleControlGrid_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleControlGrid(v))),
            "SURFACE_STYLE_FILL_AREA" => SurfaceStyleFillArea_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleFillArea(v))),
            "SURFACE_STYLE_PARAMETER_LINE" => SurfaceStyleParameterLine_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleParameterLine(v))),
            "SURFACE_STYLE_REFLECTANCE_AMBIENT" => SurfaceStyleReflectanceAmbient_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleReflectanceAmbient(v))),
            "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE" => SurfaceStyleReflectanceAmbientDiffuse_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleReflectanceAmbientDiffuse(v))),
            "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE_SPECULAR" => SurfaceStyleReflectanceAmbientDiffuseSpecular_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleReflectanceAmbientDiffuseSpecular(v))),
            "SURFACE_STYLE_RENDERING" => SurfaceStyleRendering_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleRendering(v))),
            "SURFACE_STYLE_RENDERING_WITH_PROPERTIES" => SurfaceStyleRenderingWithProperties_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleRenderingWithProperties(v))),
            "SURFACE_STYLE_SEGMENTATION_CURVE" => SurfaceStyleSegmentationCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleSegmentationCurve(v))),
            "SURFACE_STYLE_SILHOUETTE" => SurfaceStyleSilhouette_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleSilhouette(v))),
            "SURFACE_STYLE_TRANSPARENT" => SurfaceStyleTransparent_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleTransparent(v))),
            "SURFACE_STYLE_USAGE" => SurfaceStyleUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleUsage(v))),
            "SURFACE_TEXTURE_REPRESENTATION" => SurfaceTextureRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceTextureRepresentation(v))),
            "SWEPT_AREA_SOLID" => SweptAreaSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::SweptAreaSolid(v))),
            "SWEPT_DISK_SOLID" => SweptDiskSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::SweptDiskSolid(v))),
            "SWEPT_FACE_SOLID" => SweptFaceSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::SweptFaceSolid(v))),
            "SWEPT_SURFACE" => SweptSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::SweptSurface(v))),
            "SYMBOL_COLOUR" => SymbolColour_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymbolColour(v))),
            "SYMBOL_REPRESENTATION" => SymbolRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymbolRepresentation(v))),
            "SYMBOL_REPRESENTATION_MAP" => SymbolRepresentationMap_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymbolRepresentationMap(v))),
            "SYMBOL_STYLE" => SymbolStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymbolStyle(v))),
            "SYMBOL_TARGET" => SymbolTarget_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymbolTarget(v))),
            "SYMMETRIC_SHAPE_ASPECT" => SymmetricShapeAspect_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymmetricShapeAspect(v))),
            "SYMMETRY_TOLERANCE" => SymmetryTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymmetryTolerance(v))),
            "TACTILE_APPEARANCE_REPRESENTATION" => TactileAppearanceRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::TactileAppearanceRepresentation(v))),
            "TAN_FUNCTION" => TanFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::TanFunction(v))),
            "TANGENT" => Tangent_::parse_chunks(strs).map(|(s, v)| (s, Entity::Tangent(v))),
            "TAPER" => Taper_::parse_chunks(strs).map(|(s, v)| (s, Entity::Taper(v))),
            "TEE_PROFILE" => TeeProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::TeeProfile(v))),
            "TERMINATOR_SYMBOL" => TerminatorSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::TerminatorSymbol(v))),
            "TEXT_LITERAL" => TextLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextLiteral(v))),
            "TEXT_LITERAL_WITH_ASSOCIATED_CURVES" => TextLiteralWithAssociatedCurves_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextLiteralWithAssociatedCurves(v))),
            "TEXT_LITERAL_WITH_BLANKING_BOX" => TextLiteralWithBlankingBox_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextLiteralWithBlankingBox(v))),
            "TEXT_LITERAL_WITH_DELINEATION" => TextLiteralWithDelineation_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextLiteralWithDelineation(v))),
            "TEXT_LITERAL_WITH_EXTENT" => TextLiteralWithExtent_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextLiteralWithExtent(v))),
            "TEXT_STRING_REPRESENTATION" => TextStringRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStringRepresentation(v))),
            "TEXT_STYLE" => TextStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStyle(v))),
            "TEXT_STYLE_FOR_DEFINED_FONT" => TextStyleForDefinedFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStyleForDefinedFont(v))),
            "TEXT_STYLE_WITH_BOX_CHARACTERISTICS" => TextStyleWithBoxCharacteristics_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStyleWithBoxCharacteristics(v))),
            "TEXT_STYLE_WITH_MIRROR" => TextStyleWithMirror_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStyleWithMirror(v))),
            "TEXT_STYLE_WITH_SPACING" => TextStyleWithSpacing_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStyleWithSpacing(v))),
            "THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT" => ThermodynamicTemperatureMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ThermodynamicTemperatureMeasureWithUnit(v))),
            "THERMODYNAMIC_TEMPERATURE_UNIT" => ThermodynamicTemperatureUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ThermodynamicTemperatureUnit(v))),
            "THREAD" => Thread_::parse_chunks(strs).map(|(s, v)| (s, Entity::Thread(v))),
            "TIME_INTERVAL" => TimeInterval_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeInterval(v))),
            "TIME_INTERVAL_ASSIGNMENT" => TimeIntervalAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeIntervalAssignment(v))),
            "TIME_INTERVAL_BASED_EFFECTIVITY" => TimeIntervalBasedEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeIntervalBasedEffectivity(v))),
            "TIME_INTERVAL_ROLE" => TimeIntervalRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeIntervalRole(v))),
            "TIME_INTERVAL_WITH_BOUNDS" => TimeIntervalWithBounds_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeIntervalWithBounds(v))),
            "TIME_MEASURE_WITH_UNIT" => TimeMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeMeasureWithUnit(v))),
            "TIME_UNIT" => TimeUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeUnit(v))),
            "TOLERANCE_VALUE" => ToleranceValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::ToleranceValue(v))),
            "TOLERANCE_ZONE" => ToleranceZone_::parse_chunks(strs).map(|(s, v)| (s, Entity::ToleranceZone(v))),
            "TOLERANCE_ZONE_DEFINITION" => ToleranceZoneDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ToleranceZoneDefinition(v))),
            "TOLERANCE_ZONE_FORM" => ToleranceZoneForm_::parse_chunks(strs).map(|(s, v)| (s, Entity::ToleranceZoneForm(v))),
            "TOPOLOGICAL_REPRESENTATION_ITEM" => TopologicalRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::TopologicalRepresentationItem(v))),
            "TOROIDAL_SURFACE" => ToroidalSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::ToroidalSurface(v))),
            "TORUS" => Torus_::parse_chunks(strs).map(|(s, v)| (s, Entity::Torus(v))),
            "TOTAL_RUNOUT_TOLERANCE" => TotalRunoutTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::TotalRunoutTolerance(v))),
            "TRANSITION_FEATURE" => TransitionFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::TransitionFeature(v))),
            "TRIMMED_CURVE" => TrimmedCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::TrimmedCurve(v))),
            "TWO_DIRECTION_REPEAT_FACTOR" => TwoDirectionRepeatFactor_::parse_chunks(strs).map(|(s, v)| (s, Entity::TwoDirectionRepeatFactor(v))),
            "TYPE_QUALIFIER" => TypeQualifier_::parse_chunks(strs).map(|(s, v)| (s, Entity::TypeQualifier(v))),
            "UNARY_BOOLEAN_EXPRESSION" => UnaryBooleanExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnaryBooleanExpression(v))),
            "UNARY_FUNCTION_CALL" => UnaryFunctionCall_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnaryFunctionCall(v))),
            "UNARY_GENERIC_EXPRESSION" => UnaryGenericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnaryGenericExpression(v))),
            "UNARY_NUMERIC_EXPRESSION" => UnaryNumericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnaryNumericExpression(v))),
            "UNCERTAINTY_ASSIGNED_REPRESENTATION" => UncertaintyAssignedRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::UncertaintyAssignedRepresentation(v))),
            "UNCERTAINTY_MEASURE_WITH_UNIT" => UncertaintyMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::UncertaintyMeasureWithUnit(v))),
            "UNCERTAINTY_QUALIFIER" => UncertaintyQualifier_::parse_chunks(strs).map(|(s, v)| (s, Entity::UncertaintyQualifier(v))),
            "UNCONSTRAINED_PAIR" => UnconstrainedPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnconstrainedPair(v))),
            "UNCONSTRAINED_PAIR_VALUE" => UnconstrainedPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnconstrainedPairValue(v))),
            "UNIFORM_CURVE" => UniformCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::UniformCurve(v))),
            "UNIFORM_SURFACE" => UniformSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::UniformSurface(v))),
            "UNIVERSAL_PAIR" => UniversalPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::UniversalPair(v))),
            "UNIVERSAL_PAIR_RANGE" => UniversalPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::UniversalPairRange(v))),
            "UNIVERSAL_PAIR_VALUE" => UniversalPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::UniversalPairValue(v))),
            "VALUE_FUNCTION" => ValueFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::ValueFunction(v))),
            "VALUE_RANGE" => ValueRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::ValueRange(v))),
            "VALUE_REPRESENTATION_ITEM" => ValueRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ValueRepresentationItem(v))),
            "VARIABLE" => Variable_::parse_chunks(strs).map(|(s, v)| (s, Entity::Variable(v))),
            "VARIABLE_SEMANTICS" => VariableSemantics_::parse_chunks(strs).map(|(s, v)| (s, Entity::VariableSemantics(v))),
            "VECTOR" => Vector_::parse_chunks(strs).map(|(s, v)| (s, Entity::Vector(v))),
            "VECTOR_STYLE" => VectorStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::VectorStyle(v))),
            "VEE_PROFILE" => VeeProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::VeeProfile(v))),
            "VERSIONED_ACTION_REQUEST" => VersionedActionRequest_::parse_chunks(strs).map(|(s, v)| (s, Entity::VersionedActionRequest(v))),
            "VERSIONED_ACTION_REQUEST_RELATIONSHIP" => VersionedActionRequestRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::VersionedActionRequestRelationship(v))),
            "VERTEX" => Vertex_::parse_chunks(strs).map(|(s, v)| (s, Entity::Vertex(v))),
            "VERTEX_LOOP" => VertexLoop_::parse_chunks(strs).map(|(s, v)| (s, Entity::VertexLoop(v))),
            "VERTEX_POINT" => VertexPoint_::parse_chunks(strs).map(|(s, v)| (s, Entity::VertexPoint(v))),
            "VIEW_VOLUME" => ViewVolume_::parse_chunks(strs).map(|(s, v)| (s, Entity::ViewVolume(v))),
            "VISUAL_APPEARANCE_REPRESENTATION" => VisualAppearanceRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::VisualAppearanceRepresentation(v))),
            "VOLUME_MEASURE_WITH_UNIT" => VolumeMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::VolumeMeasureWithUnit(v))),
            "VOLUME_UNIT" => VolumeUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::VolumeUnit(v))),
            "XOR_EXPRESSION" => XorExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::XorExpression(v))),
            "" => parse_complex_mapping(strs[0]),
            _ => panic!("Invalid case"),
        }
    }
}

pub fn superclasses_of(s: &str) -> &[&str] {
    match s {
        "ABS_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "ACOS_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "ADVANCED_BREP_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "ADVANCED_FACE" => &["FACE_SURFACE"],
        "AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "AMOUNT_OF_SUBSTANCE_UNIT" => &["NAMED_UNIT"],
        "AND_EXPRESSION" => &["MULTIPLE_ARITY_BOOLEAN_EXPRESSION"],
        "ANGULAR_DIMENSION" => &["DIMENSION_CURVE_DIRECTED_CALLOUT"],
        "ANGULAR_LOCATION" => &["DIMENSIONAL_LOCATION"],
        "ANGULAR_SIZE" => &["DIMENSIONAL_SIZE"],
        "ANGULARITY_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "ANNOTATION_CURVE_OCCURRENCE" => &["ANNOTATION_OCCURRENCE"],
        "ANNOTATION_FILL_AREA" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "ANNOTATION_FILL_AREA_OCCURRENCE" => &["ANNOTATION_OCCURRENCE"],
        "ANNOTATION_OCCURRENCE" => &["STYLED_ITEM"],
        "ANNOTATION_OCCURRENCE_ASSOCIATIVITY" => &["ANNOTATION_OCCURRENCE_RELATIONSHIP"],
        "ANNOTATION_PLANE" => &["ANNOTATION_OCCURRENCE", "GEOMETRIC_REPRESENTATION_ITEM"],
        "ANNOTATION_SUBFIGURE_OCCURRENCE" => &["ANNOTATION_SYMBOL_OCCURRENCE"],
        "ANNOTATION_SYMBOL" => &["MAPPED_ITEM"],
        "ANNOTATION_SYMBOL_OCCURRENCE" => &["ANNOTATION_OCCURRENCE"],
        "ANNOTATION_TEXT" => &["MAPPED_ITEM"],
        "ANNOTATION_TEXT_CHARACTER" => &["MAPPED_ITEM"],
        "ANNOTATION_TEXT_OCCURRENCE" => &["ANNOTATION_OCCURRENCE"],
        "APEX" => &["DERIVED_SHAPE_ASPECT"],
        "APPLIED_ACTION_ASSIGNMENT" => &["ACTION_ASSIGNMENT"],
        "APPLIED_ACTION_REQUEST_ASSIGNMENT" => &["ACTION_REQUEST_ASSIGNMENT"],
        "APPLIED_APPROVAL_ASSIGNMENT" => &["APPROVAL_ASSIGNMENT"],
        "APPLIED_AREA" => &["SHAPE_ASPECT"],
        "APPLIED_CERTIFICATION_ASSIGNMENT" => &["CERTIFICATION_ASSIGNMENT"],
        "APPLIED_CLASSIFICATION_ASSIGNMENT" => &["CLASSIFICATION_ASSIGNMENT"],
        "APPLIED_CONTRACT_ASSIGNMENT" => &["CONTRACT_ASSIGNMENT"],
        "APPLIED_DATE_AND_TIME_ASSIGNMENT" => &["DATE_AND_TIME_ASSIGNMENT"],
        "APPLIED_DATE_ASSIGNMENT" => &["DATE_ASSIGNMENT"],
        "APPLIED_DOCUMENT_REFERENCE" => &["DOCUMENT_REFERENCE"],
        "APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => &["DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT"],
        "APPLIED_EFFECTIVITY_ASSIGNMENT" => &["EFFECTIVITY_ASSIGNMENT"],
        "APPLIED_EVENT_OCCURRENCE_ASSIGNMENT" => &["EVENT_OCCURRENCE_ASSIGNMENT"],
        "APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT" => &["EXTERNAL_IDENTIFICATION_ASSIGNMENT"],
        "APPLIED_GROUP_ASSIGNMENT" => &["GROUP_ASSIGNMENT"],
        "APPLIED_IDENTIFICATION_ASSIGNMENT" => &["IDENTIFICATION_ASSIGNMENT"],
        "APPLIED_INEFFECTIVITY_ASSIGNMENT" => &["EFFECTIVITY_ASSIGNMENT"],
        "APPLIED_NAME_ASSIGNMENT" => &["NAME_ASSIGNMENT"],
        "APPLIED_ORGANIZATION_ASSIGNMENT" => &["ORGANIZATION_ASSIGNMENT"],
        "APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT" => &["ORGANIZATIONAL_PROJECT_ASSIGNMENT"],
        "APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT" => &["PERSON_AND_ORGANIZATION_ASSIGNMENT"],
        "APPLIED_PRESENTED_ITEM" => &["PRESENTED_ITEM"],
        "APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT" => &["SECURITY_CLASSIFICATION_ASSIGNMENT"],
        "APPLIED_TIME_INTERVAL_ASSIGNMENT" => &["TIME_INTERVAL_ASSIGNMENT"],
        "APPROXIMATION_TOLERANCE" => &["FOUNDED_ITEM"],
        "APPROXIMATION_TOLERANCE_DEVIATION" => &["FOUNDED_ITEM"],
        "APPROXIMATION_TOLERANCE_PARAMETER" => &["FOUNDED_ITEM"],
        "AREA_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "AREA_UNIT" => &["DERIVED_UNIT"],
        "ASIN_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "ASSEMBLY_COMPONENT_USAGE" => &["PRODUCT_DEFINITION_USAGE"],
        "ATAN_FUNCTION" => &["BINARY_FUNCTION_CALL"],
        "ATTRIBUTE_LANGUAGE_ASSIGNMENT" => &["ATTRIBUTE_CLASSIFICATION_ASSIGNMENT"],
        "AXIS1_PLACEMENT" => &["PLACEMENT"],
        "AXIS2_PLACEMENT_2D" => &["PLACEMENT"],
        "AXIS2_PLACEMENT_3D" => &["PLACEMENT"],
        "B_SPLINE_CURVE" => &["BOUNDED_CURVE"],
        "B_SPLINE_CURVE_WITH_KNOTS" => &["B_SPLINE_CURVE"],
        "B_SPLINE_SURFACE" => &["BOUNDED_SURFACE"],
        "B_SPLINE_SURFACE_WITH_KNOTS" => &["B_SPLINE_SURFACE"],
        "BACKGROUND_COLOUR" => &["COLOUR"],
        "BARRING_HOLE" => &["FEATURE_DEFINITION"],
        "BEAD" => &["FEATURE_DEFINITION"],
        "BEAD_END" => &["SHAPE_ASPECT"],
        "BEZIER_CURVE" => &["B_SPLINE_CURVE"],
        "BEZIER_SURFACE" => &["B_SPLINE_SURFACE"],
        "BINARY_BOOLEAN_EXPRESSION" => &["BOOLEAN_EXPRESSION", "BINARY_GENERIC_EXPRESSION"],
        "BINARY_FUNCTION_CALL" => &["BINARY_NUMERIC_EXPRESSION"],
        "BINARY_GENERIC_EXPRESSION" => &["GENERIC_EXPRESSION"],
        "BINARY_NUMERIC_EXPRESSION" => &["NUMERIC_EXPRESSION", "BINARY_GENERIC_EXPRESSION"],
        "BLOCK" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "BOOLEAN_DEFINED_FUNCTION" => &["DEFINED_FUNCTION", "BOOLEAN_EXPRESSION"],
        "BOOLEAN_EXPRESSION" => &["EXPRESSION"],
        "BOOLEAN_LITERAL" => &["SIMPLE_BOOLEAN_EXPRESSION", "GENERIC_LITERAL"],
        "BOOLEAN_RESULT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "BOOLEAN_VARIABLE" => &["SIMPLE_BOOLEAN_EXPRESSION", "VARIABLE"],
        "BOSS" => &["FEATURE_DEFINITION"],
        "BOSS_TOP" => &["SHAPE_ASPECT"],
        "BOUNDARY_CURVE" => &["COMPOSITE_CURVE_ON_SURFACE"],
        "BOUNDED_CURVE" => &["CURVE"],
        "BOUNDED_PCURVE" => &["PCURVE", "BOUNDED_CURVE"],
        "BOUNDED_SURFACE" => &["SURFACE"],
        "BOUNDED_SURFACE_CURVE" => &["SURFACE_CURVE", "BOUNDED_CURVE"],
        "BOX_DOMAIN" => &["FOUNDED_ITEM"],
        "BOXED_HALF_SPACE" => &["HALF_SPACE_SOLID"],
        "BREP_WITH_VOIDS" => &["MANIFOLD_SOLID_BREP"],
        "CALENDAR_DATE" => &["DATE"],
        "CAMERA_IMAGE" => &["MAPPED_ITEM"],
        "CAMERA_IMAGE_2D_WITH_SCALE" => &["CAMERA_IMAGE"],
        "CAMERA_IMAGE_3D_WITH_SCALE" => &["CAMERA_IMAGE"],
        "CAMERA_MODEL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "CAMERA_MODEL_D2" => &["CAMERA_MODEL"],
        "CAMERA_MODEL_D3" => &["CAMERA_MODEL"],
        "CAMERA_MODEL_D3_WITH_HLHSR" => &["CAMERA_MODEL_D3"],
        "CAMERA_USAGE" => &["REPRESENTATION_MAP"],
        "CARTESIAN_POINT" => &["POINT"],
        "CARTESIAN_TRANSFORMATION_OPERATOR" => &["GEOMETRIC_REPRESENTATION_ITEM", "FUNCTIONALLY_DEFINED_TRANSFORMATION"],
        "CARTESIAN_TRANSFORMATION_OPERATOR_2D" => &["CARTESIAN_TRANSFORMATION_OPERATOR"],
        "CARTESIAN_TRANSFORMATION_OPERATOR_3D" => &["CARTESIAN_TRANSFORMATION_OPERATOR"],
        "CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "CENTRE_OF_SYMMETRY" => &["DERIVED_SHAPE_ASPECT"],
        "CHAMFER" => &["TRANSITION_FEATURE"],
        "CHAMFER_OFFSET" => &["SHAPE_ASPECT"],
        "CHARACTER_GLYPH_SYMBOL" => &["GENERIC_CHARACTER_GLYPH_SYMBOL"],
        "CHARACTERIZED_CLASS" => &["CHARACTERIZED_OBJECT", "CLASS"],
        "CIRCLE" => &["CONIC"],
        "CIRCULAR_CLOSED_PROFILE" => &["SHAPE_ASPECT"],
        "CIRCULAR_PATTERN" => &["REPLICATE_FEATURE"],
        "CIRCULAR_RUNOUT_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "CLASS" => &["GROUP"],
        "CLASS_SYSTEM" => &["GROUP"],
        "CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT" => &["EFFECTIVITY_CONTEXT_ASSIGNMENT"],
        "CLOSED_PATH_PROFILE" => &["SHAPE_ASPECT"],
        "CLOSED_SHELL" => &["CONNECTED_FACE_SET"],
        "COAXIALITY_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "COLOUR_RGB" => &["COLOUR_SPECIFICATION"],
        "COLOUR_SPECIFICATION" => &["COLOUR"],
        "COMMON_DATUM" => &["COMPOSITE_SHAPE_ASPECT", "DATUM"],
        "COMPARISON_EQUAL" => &["COMPARISON_EXPRESSION"],
        "COMPARISON_EXPRESSION" => &["BOOLEAN_EXPRESSION", "BINARY_GENERIC_EXPRESSION"],
        "COMPARISON_GREATER" => &["COMPARISON_EXPRESSION"],
        "COMPARISON_GREATER_EQUAL" => &["COMPARISON_EXPRESSION"],
        "COMPARISON_LESS" => &["COMPARISON_EXPRESSION"],
        "COMPARISON_LESS_EQUAL" => &["COMPARISON_EXPRESSION"],
        "COMPARISON_NOT_EQUAL" => &["COMPARISON_EXPRESSION"],
        "COMPOSITE_CURVE" => &["BOUNDED_CURVE"],
        "COMPOSITE_CURVE_ON_SURFACE" => &["COMPOSITE_CURVE"],
        "COMPOSITE_CURVE_SEGMENT" => &["FOUNDED_ITEM"],
        "COMPOSITE_HOLE" => &["COMPOUND_FEATURE"],
        "COMPOSITE_SHAPE_ASPECT" => &["SHAPE_ASPECT"],
        "COMPOSITE_TEXT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES" => &["COMPOSITE_TEXT"],
        "COMPOSITE_TEXT_WITH_BLANKING_BOX" => &["COMPOSITE_TEXT"],
        "COMPOSITE_TEXT_WITH_EXTENT" => &["COMPOSITE_TEXT"],
        "COMPOUND_FEATURE" => &["FEATURE_DEFINITION"],
        "COMPOUND_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "COMPOUND_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "CONCAT_EXPRESSION" => &["STRING_EXPRESSION", "MULTIPLE_ARITY_GENERIC_EXPRESSION"],
        "CONCENTRICITY_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION" => &["CONCEPT_FEATURE_RELATIONSHIP"],
        "CONDITIONAL_CONCEPT_FEATURE" => &["PRODUCT_CONCEPT_FEATURE"],
        "CONFIGURABLE_ITEM" => &["CONFIGURATION_ITEM"],
        "CONFIGURATION_EFFECTIVITY" => &["PRODUCT_DEFINITION_EFFECTIVITY"],
        "CONFIGURED_EFFECTIVITY_ASSIGNMENT" => &["EFFECTIVITY_ASSIGNMENT"],
        "CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT" => &["EFFECTIVITY_CONTEXT_ASSIGNMENT"],
        "CONIC" => &["CURVE"],
        "CONICAL_SURFACE" => &["ELEMENTARY_SURFACE"],
        "CONNECTED_EDGE_SET" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "CONNECTED_FACE_SET" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "CONNECTED_FACE_SUB_SET" => &["CONNECTED_FACE_SET"],
        "CONSTRUCTIVE_GEOMETRY_REPRESENTATION" => &["REPRESENTATION"],
        "CONSTRUCTIVE_GEOMETRY_REPRESENTATION_RELATIONSHIP" => &["REPRESENTATION_RELATIONSHIP"],
        "CONTACT_RATIO_REPRESENTATION" => &["REPRESENTATION"],
        "CONTEXT_DEPENDENT_INVISIBILITY" => &["INVISIBILITY"],
        "CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM" => &["OVER_RIDING_STYLED_ITEM"],
        "CONTEXT_DEPENDENT_UNIT" => &["NAMED_UNIT"],
        "CONVERSION_BASED_UNIT" => &["NAMED_UNIT"],
        "COS_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "CSG_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "CSG_SOLID" => &["SOLID_MODEL"],
        "CURVE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "CURVE_BOUNDED_SURFACE" => &["BOUNDED_SURFACE"],
        "CURVE_DIMENSION" => &["DIMENSION_CURVE_DIRECTED_CALLOUT"],
        "CURVE_REPLICA" => &["CURVE"],
        "CURVE_STYLE" => &["FOUNDED_ITEM"],
        "CURVE_STYLE_FONT" => &["FOUNDED_ITEM"],
        "CURVE_STYLE_FONT_PATTERN" => &["FOUNDED_ITEM"],
        "CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "CYLINDRICAL_PAIR" => &["KINEMATIC_PAIR"],
        "CYLINDRICAL_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "CYLINDRICAL_PAIR_VALUE" => &["PAIR_VALUE"],
        "CYLINDRICAL_SURFACE" => &["ELEMENTARY_SURFACE"],
        "CYLINDRICITY_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "DATED_EFFECTIVITY" => &["EFFECTIVITY"],
        "DATUM" => &["SHAPE_ASPECT"],
        "DATUM_FEATURE" => &["SHAPE_ASPECT"],
        "DATUM_FEATURE_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "DATUM_TARGET" => &["SHAPE_ASPECT"],
        "DATUM_TARGET_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "DEFAULT_TOLERANCE_TABLE" => &["REPRESENTATION"],
        "DEFAULT_TOLERANCE_TABLE_CELL" => &["COMPOUND_REPRESENTATION_ITEM"],
        "DEFINED_CHARACTER_GLYPH" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "DEFINED_SYMBOL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "DEFINITIONAL_REPRESENTATION" => &["REPRESENTATION"],
        "DEGENERATE_PCURVE" => &["POINT"],
        "DEGENERATE_TOROIDAL_SURFACE" => &["TOROIDAL_SURFACE"],
        "DERIVED_SHAPE_ASPECT" => &["SHAPE_ASPECT"],
        "DERIVED_UNIT_VARIABLE" => &["DERIVED_UNIT", "VARIABLE_SEMANTICS"],
        "DESCRIPTIVE_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "DIAMETER_DIMENSION" => &["DIMENSION_CURVE_DIRECTED_CALLOUT"],
        "DIMENSION_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP" => &["DRAUGHTING_CALLOUT_RELATIONSHIP"],
        "DIMENSION_CALLOUT_RELATIONSHIP" => &["DRAUGHTING_CALLOUT_RELATIONSHIP"],
        "DIMENSION_CURVE" => &["ANNOTATION_CURVE_OCCURRENCE"],
        "DIMENSION_CURVE_DIRECTED_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "DIMENSION_CURVE_TERMINATOR" => &["TERMINATOR_SYMBOL"],
        "DIMENSION_PAIR" => &["DRAUGHTING_CALLOUT_RELATIONSHIP"],
        "DIMENSION_TEXT_ASSOCIATIVITY" => &["TEXT_LITERAL", "MAPPED_ITEM"],
        "DIMENSIONAL_LOCATION" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "DIMENSIONAL_LOCATION_WITH_PATH" => &["DIMENSIONAL_LOCATION"],
        "DIMENSIONAL_SIZE_WITH_PATH" => &["DIMENSIONAL_SIZE"],
        "DIRECTED_ACTION" => &["EXECUTED_ACTION"],
        "DIRECTED_ANGLE" => &["SHAPE_ASPECT"],
        "DIRECTED_DIMENSIONAL_LOCATION" => &["DIMENSIONAL_LOCATION"],
        "DIRECTION" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "DIRECTION_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "DIV_EXPRESSION" => &["BINARY_NUMERIC_EXPRESSION"],
        "DOCUMENT_FILE" => &["DOCUMENT", "CHARACTERIZED_OBJECT"],
        "DOCUMENT_PRODUCT_EQUIVALENCE" => &["DOCUMENT_PRODUCT_ASSOCIATION"],
        "DRAUGHTING_ANNOTATION_OCCURRENCE" => &["ANNOTATION_OCCURRENCE"],
        "DRAUGHTING_CALLOUT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "DRAUGHTING_ELEMENTS" => &["DRAUGHTING_CALLOUT"],
        "DRAUGHTING_MODEL" => &["REPRESENTATION"],
        "DRAUGHTING_MODEL_ITEM_ASSOCIATION" => &["ITEM_IDENTIFIED_REPRESENTATION_USAGE"],
        "DRAUGHTING_PRE_DEFINED_COLOUR" => &["PRE_DEFINED_COLOUR"],
        "DRAUGHTING_PRE_DEFINED_CURVE_FONT" => &["PRE_DEFINED_CURVE_FONT"],
        "DRAUGHTING_PRE_DEFINED_TEXT_FONT" => &["PRE_DEFINED_TEXT_FONT"],
        "DRAUGHTING_SPECIFICATION_REFERENCE" => &["DOCUMENT_REFERENCE"],
        "DRAUGHTING_SUBFIGURE_REPRESENTATION" => &["SYMBOL_REPRESENTATION"],
        "DRAUGHTING_SYMBOL_REPRESENTATION" => &["SYMBOL_REPRESENTATION"],
        "DRAUGHTING_TEXT_LITERAL_WITH_DELINEATION" => &["TEXT_LITERAL_WITH_DELINEATION"],
        "DRAWING_REVISION" => &["PRESENTATION_SET"],
        "DRAWING_SHEET_LAYOUT" => &["DRAUGHTING_SYMBOL_REPRESENTATION"],
        "DRAWING_SHEET_REVISION" => &["PRESENTATION_AREA"],
        "DRAWING_SHEET_REVISION_USAGE" => &["AREA_IN_SET"],
        "EDGE" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "EDGE_BASED_WIREFRAME_MODEL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "EDGE_CURVE" => &["EDGE", "GEOMETRIC_REPRESENTATION_ITEM"],
        "EDGE_LOOP" => &["LOOP", "PATH"],
        "EDGE_ROUND" => &["TRANSITION_FEATURE"],
        "ELECTRIC_CURRENT_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "ELECTRIC_CURRENT_UNIT" => &["NAMED_UNIT"],
        "ELEMENT_DELIVERY" => &["ACTION"],
        "ELEMENTARY_SURFACE" => &["SURFACE"],
        "ELLIPSE" => &["CONIC"],
        "EQUALS_EXPRESSION" => &["BINARY_BOOLEAN_EXPRESSION"],
        "EVALUATED_DEGENERATE_PCURVE" => &["DEGENERATE_PCURVE"],
        "EXCLUSIVE_PRODUCT_CONCEPT_FEATURE_CATEGORY" => &["PRODUCT_CONCEPT_FEATURE_CATEGORY"],
        "EXECUTED_ACTION" => &["ACTION"],
        "EXP_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "EXPRESSION" => &["GENERIC_EXPRESSION"],
        "EXPRESSION_CONVERSION_BASED_UNIT" => &["CONTEXT_DEPENDENT_UNIT", "VARIABLE_SEMANTICS"],
        "EXTENSION" => &["DERIVED_SHAPE_ASPECT"],
        "EXTERNAL_IDENTIFICATION_ASSIGNMENT" => &["IDENTIFICATION_ASSIGNMENT"],
        "EXTERNALLY_DEFINED_CHARACTER_GLYPH" => &["EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_CLASS" => &["CLASS", "EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_CURVE_FONT" => &["EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_DIMENSION_DEFINITION" => &["DIMENSIONAL_SIZE", "EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_FEATURE_DEFINITION" => &["FEATURE_DEFINITION", "EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_GENERAL_PROPERTY" => &["GENERAL_PROPERTY", "EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_HATCH_STYLE" => &["EXTERNALLY_DEFINED_ITEM", "GEOMETRIC_REPRESENTATION_ITEM"],
        "EXTERNALLY_DEFINED_STYLE" => &["EXTERNALLY_DEFINED_ITEM", "FOUNDED_ITEM"],
        "EXTERNALLY_DEFINED_SYMBOL" => &["EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_TEXT_FONT" => &["EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_TILE_STYLE" => &["EXTERNALLY_DEFINED_ITEM", "GEOMETRIC_REPRESENTATION_ITEM"],
        "EXTRUDED_AREA_SOLID" => &["SWEPT_AREA_SOLID"],
        "EXTRUDED_FACE_SOLID" => &["SWEPT_FACE_SOLID"],
        "FACE" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "FACE_BASED_SURFACE_MODEL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "FACE_BOUND" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "FACE_OUTER_BOUND" => &["FACE_BOUND"],
        "FACE_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "FACE_SURFACE" => &["FACE", "GEOMETRIC_REPRESENTATION_ITEM"],
        "FACETED_BREP" => &["MANIFOLD_SOLID_BREP"],
        "FACETED_BREP_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "FEATURE_COMPONENT_DEFINITION" => &["CHARACTERIZED_OBJECT"],
        "FEATURE_COMPONENT_RELATIONSHIP" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "FEATURE_DEFINITION" => &["CHARACTERIZED_OBJECT"],
        "FEATURE_IN_PANEL" => &["FEATURE_DEFINITION"],
        "FEATURE_PATTERN" => &["REPLICATE_FEATURE"],
        "FEATURED_SHAPE" => &["PRODUCT_DEFINITION_SHAPE"],
        "FILL_AREA_STYLE" => &["FOUNDED_ITEM"],
        "FILL_AREA_STYLE_HATCHING" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "FILL_AREA_STYLE_TILE_SYMBOL_WITH_STYLE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "FILL_AREA_STYLE_TILES" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "FILLET" => &["TRANSITION_FEATURE"],
        "FLATNESS_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "FORMAT_FUNCTION" => &["STRING_EXPRESSION", "BINARY_GENERIC_EXPRESSION"],
        "FOUNDED_KINEMATIC_PATH" => &["REPRESENTATION"],
        "FULLY_CONSTRAINED_PAIR" => &["KINEMATIC_PAIR"],
        "GEAR_PAIR" => &["KINEMATIC_PAIR"],
        "GEAR_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "GEAR_PAIR_VALUE" => &["PAIR_VALUE"],
        "GENERAL_FEATURE" => &["FEATURE_DEFINITION"],
        "GENERAL_MATERIAL_PROPERTY" => &["GENERAL_PROPERTY"],
        "GENERIC_CHARACTER_GLYPH_SYMBOL" => &["SYMBOL_REPRESENTATION"],
        "GENERIC_LITERAL" => &["SIMPLE_GENERIC_EXPRESSION"],
        "GENERIC_VARIABLE" => &["SIMPLE_GENERIC_EXPRESSION"],
        "GEOMETRIC_ALIGNMENT" => &["DERIVED_SHAPE_ASPECT"],
        "GEOMETRIC_CURVE_SET" => &["GEOMETRIC_SET"],
        "GEOMETRIC_INTERSECTION" => &["DERIVED_SHAPE_ASPECT"],
        "GEOMETRIC_ITEM_SPECIFIC_USAGE" => &["ITEM_IDENTIFIED_REPRESENTATION_USAGE"],
        "GEOMETRIC_REPRESENTATION_CONTEXT" => &["REPRESENTATION_CONTEXT"],
        "GEOMETRIC_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "GEOMETRIC_SET" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE" => &["GEOMETRIC_TOLERANCE"],
        "GEOMETRIC_TOLERANCE_WITH_DEFINED_UNIT" => &["GEOMETRIC_TOLERANCE"],
        "GEOMETRICAL_TOLERANCE_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT" => &["REPRESENTATION_CONTEXT"],
        "GLOBAL_UNIT_ASSIGNED_CONTEXT" => &["REPRESENTATION_CONTEXT"],
        "HALF_SPACE_SOLID" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "HARDNESS_REPRESENTATION" => &["REPRESENTATION"],
        "HIDDEN_ELEMENT_OVER_RIDING_STYLED_ITEM" => &["CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM"],
        "HOLE_BOTTOM" => &["SHAPE_ASPECT"],
        "HOLE_IN_PANEL" => &["FEATURE_DEFINITION"],
        "HOMOKINETIC_PAIR" => &["UNIVERSAL_PAIR"],
        "HYPERBOLA" => &["CONIC"],
        "INCLUSION_PRODUCT_CONCEPT_FEATURE" => &["CONDITIONAL_CONCEPT_FEATURE"],
        "INDEX_EXPRESSION" => &["STRING_EXPRESSION", "BINARY_GENERIC_EXPRESSION"],
        "INSTANCED_FEATURE" => &["SHAPE_ASPECT", "FEATURE_DEFINITION"],
        "INT_LITERAL" => &["LITERAL_NUMBER"],
        "INT_NUMERIC_VARIABLE" => &["NUMERIC_VARIABLE"],
        "INT_VALUE_FUNCTION" => &["VALUE_FUNCTION"],
        "INTEGER_DEFINED_FUNCTION" => &["NUMERIC_DEFINED_FUNCTION"],
        "INTERSECTION_CURVE" => &["SURFACE_CURVE"],
        "INTERVAL_EXPRESSION" => &["BOOLEAN_EXPRESSION", "MULTIPLE_ARITY_GENERIC_EXPRESSION"],
        "JOGGLE" => &["FEATURE_DEFINITION"],
        "JOGGLE_TERMINATION" => &["SHAPE_ASPECT"],
        "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION" => &["REPRESENTATION"],
        "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION_ASSOCIATION" => &["REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION"],
        "KINEMATIC_FRAME_BASED_TRANSFORMATION" => &["GEOMETRIC_REPRESENTATION_ITEM", "FUNCTIONALLY_DEFINED_TRANSFORMATION"],
        "KINEMATIC_GROUND_REPRESENTATION" => &["REPRESENTATION"],
        "KINEMATIC_LINK_REPRESENTATION" => &["REPRESENTATION"],
        "KINEMATIC_LINK_REPRESENTATION_ASSOCIATION" => &["REPRESENTATION_RELATIONSHIP"],
        "KINEMATIC_PAIR" => &["ITEM_DEFINED_TRANSFORMATION"],
        "KINEMATIC_PATH" => &["REPRESENTATION_ITEM"],
        "KINEMATIC_PROPERTY_DEFINITION" => &["PROPERTY_DEFINITION"],
        "KINEMATIC_PROPERTY_REPRESENTATION_RELATION" => &["PROPERTY_DEFINITION_REPRESENTATION"],
        "KNOWN_SOURCE" => &["EXTERNAL_SOURCE", "PRE_DEFINED_ITEM"],
        "LANGUAGE" => &["GROUP"],
        "LANGUAGE_ASSIGNMENT" => &["CLASSIFICATION_ASSIGNMENT"],
        "LEADER_CURVE" => &["ANNOTATION_CURVE_OCCURRENCE"],
        "LEADER_DIRECTED_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "LEADER_DIRECTED_DIMENSION" => &["LEADER_DIRECTED_CALLOUT"],
        "LEADER_TERMINATOR" => &["TERMINATOR_SYMBOL"],
        "LENGTH_FUNCTION" => &["NUMERIC_EXPRESSION", "UNARY_GENERIC_EXPRESSION"],
        "LENGTH_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "LENGTH_UNIT" => &["NAMED_UNIT"],
        "LIGHT_SOURCE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "LIGHT_SOURCE_AMBIENT" => &["LIGHT_SOURCE"],
        "LIGHT_SOURCE_DIRECTIONAL" => &["LIGHT_SOURCE"],
        "LIGHT_SOURCE_POSITIONAL" => &["LIGHT_SOURCE"],
        "LIGHT_SOURCE_SPOT" => &["LIGHT_SOURCE"],
        "LIKE_EXPRESSION" => &["COMPARISON_EXPRESSION"],
        "LINE" => &["CURVE"],
        "LINE_PROFILE_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "LINEAR_DIMENSION" => &["DIMENSION_CURVE_DIRECTED_CALLOUT"],
        "LITERAL_NUMBER" => &["SIMPLE_NUMERIC_EXPRESSION", "GENERIC_LITERAL"],
        "LOCATION_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "LOCATOR" => &["FEATURE_DEFINITION"],
        "LOG10_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "LOG2_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "LOG_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "LOOP" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "LOT_EFFECTIVITY" => &["EFFECTIVITY"],
        "LUMINOUS_INTENSITY_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "LUMINOUS_INTENSITY_UNIT" => &["NAMED_UNIT"],
        "MAKE_FROM_USAGE_OPTION" => &["PRODUCT_DEFINITION_USAGE"],
        "MANIFOLD_SOLID_BREP" => &["SOLID_MODEL"],
        "MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "MAPPED_ITEM" => &["REPRESENTATION_ITEM"],
        "MASS_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "MASS_UNIT" => &["NAMED_UNIT"],
        "MATERIAL_PROPERTY" => &["PROPERTY_DEFINITION"],
        "MATERIAL_PROPERTY_REPRESENTATION" => &["PROPERTY_DEFINITION_REPRESENTATION"],
        "MAXIMUM_FUNCTION" => &["MULTIPLE_ARITY_FUNCTION_CALL"],
        "MEASURE_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM", "MEASURE_WITH_UNIT"],
        "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_AREA" => &["PRESENTATION_AREA"],
        "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION" => &["REPRESENTATION"],
        "MECHANISM_BASE_PLACEMENT" => &["REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION"],
        "MINIMUM_FUNCTION" => &["MULTIPLE_ARITY_FUNCTION_CALL"],
        "MINUS_EXPRESSION" => &["BINARY_NUMERIC_EXPRESSION"],
        "MINUS_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "MOD_EXPRESSION" => &["BINARY_NUMERIC_EXPRESSION"],
        "MODIFIED_GEOMETRIC_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "MODIFIED_PATTERN" => &["REPLICATE_FEATURE"],
        "MOMENTS_OF_INERTIA_REPRESENTATION" => &["REPRESENTATION"],
        "MOTION_LINK_RELATIONSHIP" => &["REPRESENTATION_RELATIONSHIP"],
        "MULT_EXPRESSION" => &["MULTIPLE_ARITY_NUMERIC_EXPRESSION"],
        "MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT" => &["ATTRIBUTE_VALUE_ASSIGNMENT"],
        "MULTIPLE_ARITY_BOOLEAN_EXPRESSION" => &["BOOLEAN_EXPRESSION", "MULTIPLE_ARITY_GENERIC_EXPRESSION"],
        "MULTIPLE_ARITY_FUNCTION_CALL" => &["MULTIPLE_ARITY_NUMERIC_EXPRESSION"],
        "MULTIPLE_ARITY_GENERIC_EXPRESSION" => &["GENERIC_EXPRESSION"],
        "MULTIPLE_ARITY_NUMERIC_EXPRESSION" => &["NUMERIC_EXPRESSION", "MULTIPLE_ARITY_GENERIC_EXPRESSION"],
        "NAMED_UNIT_VARIABLE" => &["NAMED_UNIT", "VARIABLE_SEMANTICS"],
        "NEXT_ASSEMBLY_USAGE_OCCURRENCE" => &["ASSEMBLY_COMPONENT_USAGE"],
        "NGON_CLOSED_PROFILE" => &["SHAPE_ASPECT"],
        "NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "NOT_EXPRESSION" => &["UNARY_BOOLEAN_EXPRESSION"],
        "NUMERIC_DEFINED_FUNCTION" => &["NUMERIC_EXPRESSION", "DEFINED_FUNCTION"],
        "NUMERIC_EXPRESSION" => &["EXPRESSION"],
        "NUMERIC_VARIABLE" => &["SIMPLE_NUMERIC_EXPRESSION", "VARIABLE"],
        "ODD_FUNCTION" => &["UNARY_BOOLEAN_EXPRESSION"],
        "OFFSET_CURVE_2D" => &["CURVE"],
        "OFFSET_CURVE_3D" => &["CURVE"],
        "OFFSET_SURFACE" => &["SURFACE"],
        "ONE_DIRECTION_REPEAT_FACTOR" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "OPEN_PATH_PROFILE" => &["SHAPE_ASPECT"],
        "OPEN_SHELL" => &["CONNECTED_FACE_SET"],
        "OR_EXPRESSION" => &["MULTIPLE_ARITY_BOOLEAN_EXPRESSION"],
        "ORDINATE_DIMENSION" => &["PROJECTION_DIRECTED_CALLOUT"],
        "ORGANIZATIONAL_ADDRESS" => &["ADDRESS"],
        "ORIENTED_CLOSED_SHELL" => &["CLOSED_SHELL"],
        "ORIENTED_EDGE" => &["EDGE"],
        "ORIENTED_FACE" => &["FACE"],
        "ORIENTED_OPEN_SHELL" => &["OPEN_SHELL"],
        "ORIENTED_PATH" => &["PATH"],
        "ORIENTED_SURFACE" => &["SURFACE"],
        "OUTER_BOUNDARY_CURVE" => &["BOUNDARY_CURVE"],
        "OVER_RIDING_STYLED_ITEM" => &["STYLED_ITEM"],
        "PACKAGE_PRODUCT_CONCEPT_FEATURE" => &["PRODUCT_CONCEPT_FEATURE"],
        "PARABOLA" => &["CONIC"],
        "PARALLEL_OFFSET" => &["DERIVED_SHAPE_ASPECT"],
        "PARALLELISM_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "PARAMETRIC_REPRESENTATION_CONTEXT" => &["REPRESENTATION_CONTEXT"],
        "PARTIAL_CIRCULAR_PROFILE" => &["SHAPE_ASPECT"],
        "PATH" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "PATH_FEATURE_COMPONENT" => &["SHAPE_ASPECT"],
        "PATH_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "PATTERN_OFFSET_MEMBERSHIP" => &["FEATURE_COMPONENT_RELATIONSHIP"],
        "PATTERN_OMIT_MEMBERSHIP" => &["FEATURE_COMPONENT_RELATIONSHIP"],
        "PCURVE" => &["CURVE"],
        "PERPENDICULAR_TO" => &["DERIVED_SHAPE_ASPECT"],
        "PERPENDICULARITY_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "PERSON_AND_ORGANIZATION_ADDRESS" => &["ORGANIZATIONAL_ADDRESS", "PERSONAL_ADDRESS"],
        "PERSONAL_ADDRESS" => &["ADDRESS"],
        "PHYSICALLY_MODELLED_PRODUCT_DEFINITION" => &["PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS"],
        "PLACED_DATUM_TARGET_FEATURE" => &["DATUM_TARGET"],
        "PLACED_FEATURE" => &["SHAPE_ASPECT"],
        "PLACEMENT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "PLANAR_BOX" => &["PLANAR_EXTENT"],
        "PLANAR_CURVE_PAIR" => &["KINEMATIC_PAIR"],
        "PLANAR_CURVE_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "PLANAR_EXTENT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "PLANAR_PAIR" => &["KINEMATIC_PAIR"],
        "PLANAR_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "PLANAR_PAIR_VALUE" => &["PAIR_VALUE"],
        "PLANAR_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "PLANE" => &["ELEMENTARY_SURFACE"],
        "PLANE_ANGLE_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "PLANE_ANGLE_UNIT" => &["NAMED_UNIT"],
        "PLUS_EXPRESSION" => &["MULTIPLE_ARITY_NUMERIC_EXPRESSION"],
        "POCKET" => &["FEATURE_DEFINITION"],
        "POCKET_BOTTOM" => &["SHAPE_ASPECT"],
        "POINT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "POINT_ON_CURVE" => &["POINT"],
        "POINT_ON_PLANAR_CURVE_PAIR" => &["KINEMATIC_PAIR"],
        "POINT_ON_PLANAR_CURVE_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "POINT_ON_PLANAR_CURVE_PAIR_VALUE" => &["PAIR_VALUE"],
        "POINT_ON_SURFACE" => &["POINT"],
        "POINT_ON_SURFACE_PAIR" => &["KINEMATIC_PAIR"],
        "POINT_ON_SURFACE_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "POINT_ON_SURFACE_PAIR_VALUE" => &["PAIR_VALUE"],
        "POINT_PLACEMENT_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "POINT_REPLICA" => &["POINT"],
        "POINT_STYLE" => &["FOUNDED_ITEM"],
        "POLY_LOOP" => &["LOOP", "GEOMETRIC_REPRESENTATION_ITEM"],
        "POLYLINE" => &["BOUNDED_CURVE"],
        "POSITION_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "POWER_EXPRESSION" => &["BINARY_NUMERIC_EXPRESSION"],
        "PRE_DEFINED_COLOUR" => &["PRE_DEFINED_ITEM", "COLOUR"],
        "PRE_DEFINED_CURVE_FONT" => &["PRE_DEFINED_ITEM"],
        "PRE_DEFINED_DIMENSION_SYMBOL" => &["PRE_DEFINED_SYMBOL"],
        "PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL" => &["PRE_DEFINED_SYMBOL"],
        "PRE_DEFINED_MARKER" => &["PRE_DEFINED_ITEM"],
        "PRE_DEFINED_POINT_MARKER_SYMBOL" => &["PRE_DEFINED_MARKER", "PRE_DEFINED_SYMBOL"],
        "PRE_DEFINED_PRESENTATION_STYLE" => &["FOUNDED_ITEM", "PRE_DEFINED_ITEM"],
        "PRE_DEFINED_SURFACE_CONDITION_SYMBOL" => &["PRE_DEFINED_SYMBOL"],
        "PRE_DEFINED_SYMBOL" => &["PRE_DEFINED_ITEM"],
        "PRE_DEFINED_TERMINATOR_SYMBOL" => &["PRE_DEFINED_SYMBOL"],
        "PRE_DEFINED_TEXT_FONT" => &["PRE_DEFINED_ITEM"],
        "PRESENTATION_AREA" => &["PRESENTATION_REPRESENTATION"],
        "PRESENTATION_REPRESENTATION" => &["REPRESENTATION"],
        "PRESENTATION_STYLE_ASSIGNMENT" => &["FOUNDED_ITEM"],
        "PRESENTATION_STYLE_BY_CONTEXT" => &["PRESENTATION_STYLE_ASSIGNMENT"],
        "PRESENTATION_VIEW" => &["PRESENTATION_REPRESENTATION"],
        "PRISMATIC_PAIR" => &["KINEMATIC_PAIR"],
        "PRISMATIC_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "PRISMATIC_PAIR_VALUE" => &["PAIR_VALUE"],
        "PROCESS_OPERATION" => &["ACTION_METHOD"],
        "PROCESS_PLAN" => &["ACTION"],
        "PRODUCT_CLASS" => &["PRODUCT_CONCEPT", "CHARACTERIZED_OBJECT"],
        "PRODUCT_CONCEPT_CONTEXT" => &["APPLICATION_CONTEXT_ELEMENT"],
        "PRODUCT_CONCEPT_FEATURE_CATEGORY" => &["GROUP"],
        "PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE" => &["GROUP_ASSIGNMENT"],
        "PRODUCT_CONTEXT" => &["APPLICATION_CONTEXT_ELEMENT"],
        "PRODUCT_DEFINITION_CONTEXT" => &["APPLICATION_CONTEXT_ELEMENT"],
        "PRODUCT_DEFINITION_EFFECTIVITY" => &["EFFECTIVITY"],
        "PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE" => &["PRODUCT_DEFINITION_FORMATION"],
        "PRODUCT_DEFINITION_PROCESS" => &["ACTION"],
        "PRODUCT_DEFINITION_RESOURCE" => &["ACTION_RESOURCE", "PRODUCT_DEFINITION"],
        "PRODUCT_DEFINITION_SHAPE" => &["PROPERTY_DEFINITION"],
        "PRODUCT_DEFINITION_USAGE" => &["PRODUCT_DEFINITION_RELATIONSHIP"],
        "PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS" => &["PRODUCT_DEFINITION"],
        "PRODUCT_IDENTIFICATION" => &["CONFIGURATION_ITEM", "CHARACTERIZED_OBJECT"],
        "PRODUCT_PROCESS_PLAN" => &["PRODUCT_DEFINITION_PROCESS"],
        "PRODUCT_RELATED_PRODUCT_CATEGORY" => &["PRODUCT_CATEGORY"],
        "PRODUCT_SPECIFICATION" => &["PRODUCT_IDENTIFICATION", "CONFIGURABLE_ITEM"],
        "PROJECTED_ZONE_DEFINITION" => &["TOLERANCE_ZONE_DEFINITION"],
        "PROJECTION_CURVE" => &["ANNOTATION_CURVE_OCCURRENCE"],
        "PROJECTION_DIRECTED_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "PROMISSORY_USAGE_OCCURRENCE" => &["ASSEMBLY_COMPONENT_USAGE"],
        "PROPERTY_PROCESS" => &["ACTION"],
        "QUALIFIED_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "QUALITATIVE_UNCERTAINTY" => &["UNCERTAINTY_QUALIFIER"],
        "QUANTIFIED_ASSEMBLY_COMPONENT_USAGE" => &["ASSEMBLY_COMPONENT_USAGE"],
        "QUASI_UNIFORM_CURVE" => &["B_SPLINE_CURVE"],
        "QUASI_UNIFORM_SURFACE" => &["B_SPLINE_SURFACE"],
        "RACK_AND_PINION_PAIR" => &["KINEMATIC_PAIR"],
        "RACK_AND_PINION_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "RACK_AND_PINION_PAIR_VALUE" => &["PAIR_VALUE"],
        "RADIUS_DIMENSION" => &["DIMENSION_CURVE_DIRECTED_CALLOUT"],
        "RATIO_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "RATIO_UNIT" => &["NAMED_UNIT"],
        "RATIONAL_B_SPLINE_CURVE" => &["B_SPLINE_CURVE"],
        "RATIONAL_B_SPLINE_SURFACE" => &["B_SPLINE_SURFACE"],
        "REAL_DEFINED_FUNCTION" => &["NUMERIC_DEFINED_FUNCTION"],
        "REAL_LITERAL" => &["LITERAL_NUMBER"],
        "REAL_NUMERIC_VARIABLE" => &["NUMERIC_VARIABLE"],
        "RECTANGULAR_CLOSED_PROFILE" => &["SHAPE_ASPECT"],
        "RECTANGULAR_COMPOSITE_SURFACE" => &["BOUNDED_SURFACE"],
        "RECTANGULAR_PATTERN" => &["REPLICATE_FEATURE"],
        "RECTANGULAR_TRIMMED_SURFACE" => &["BOUNDED_SURFACE"],
        "REFERENCED_MODIFIED_DATUM" => &["DATUM_REFERENCE"],
        "RELATIVE_EVENT_OCCURRENCE" => &["EVENT_OCCURRENCE"],
        "REP_ITEM_GROUP" => &["GROUP", "REPRESENTATION_ITEM"],
        "REPARAMETRISED_COMPOSITE_CURVE_SEGMENT" => &["COMPOSITE_CURVE_SEGMENT"],
        "REPLICATE_FEATURE" => &["FEATURE_DEFINITION"],
        "REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION" => &["REPRESENTATION_RELATIONSHIP"],
        "REQUIREMENT_FOR_ACTION_RESOURCE" => &["ACTION_RESOURCE_REQUIREMENT"],
        "RESULTING_PATH" => &["MOTION_LINK_RELATIONSHIP"],
        "RETENTION" => &["ACTION"],
        "REVOLUTE_PAIR" => &["KINEMATIC_PAIR"],
        "REVOLUTE_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "REVOLUTE_PAIR_VALUE" => &["PAIR_VALUE"],
        "REVOLVED_AREA_SOLID" => &["SWEPT_AREA_SOLID"],
        "REVOLVED_FACE_SOLID" => &["SWEPT_FACE_SOLID"],
        "RIB" => &["FEATURE_DEFINITION"],
        "RIGHT_ANGULAR_WEDGE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "RIGHT_CIRCULAR_CONE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "RIGHT_CIRCULAR_CYLINDER" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "ROLLING_CURVE_PAIR" => &["PLANAR_CURVE_PAIR"],
        "ROLLING_CURVE_PAIR_VALUE" => &["PAIR_VALUE"],
        "ROLLING_SURFACE_PAIR" => &["SURFACE_PAIR"],
        "ROLLING_SURFACE_PAIR_VALUE" => &["PAIR_VALUE"],
        "ROUND_HOLE" => &["FEATURE_DEFINITION"],
        "ROUNDED_U_PROFILE" => &["SHAPE_ASPECT"],
        "ROUNDNESS_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "RULED_SURFACE_SWEPT_AREA_SOLID" => &["SURFACE_CURVE_SWEPT_AREA_SOLID"],
        "RUNOUT_ZONE_DEFINITION" => &["TOLERANCE_ZONE_DEFINITION"],
        "RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION" => &["RUNOUT_ZONE_ORIENTATION"],
        "SCREW_PAIR" => &["KINEMATIC_PAIR"],
        "SCREW_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "SCREW_PAIR_VALUE" => &["PAIR_VALUE"],
        "SEAM_CURVE" => &["SURFACE_CURVE"],
        "SEAM_EDGE" => &["ORIENTED_EDGE"],
        "SERIAL_NUMBERED_EFFECTIVITY" => &["EFFECTIVITY"],
        "SHAPE_ASPECT_ASSOCIATIVITY" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "SHAPE_ASPECT_DERIVING_RELATIONSHIP" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "SHAPE_ASPECT_TRANSITION" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "SHAPE_DEFINING_RELATIONSHIP" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "SHAPE_DEFINITION_REPRESENTATION" => &["PROPERTY_DEFINITION_REPRESENTATION"],
        "SHAPE_DIMENSION_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "SHAPE_REPRESENTATION" => &["REPRESENTATION"],
        "SHAPE_REPRESENTATION_RELATIONSHIP" => &["REPRESENTATION_RELATIONSHIP"],
        "SHAPE_REPRESENTATION_WITH_PARAMETERS" => &["SHAPE_REPRESENTATION"],
        "SHELL_BASED_SURFACE_MODEL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "SI_UNIT" => &["NAMED_UNIT"],
        "SIMPLE_BOOLEAN_EXPRESSION" => &["BOOLEAN_EXPRESSION", "SIMPLE_GENERIC_EXPRESSION"],
        "SIMPLE_GENERIC_EXPRESSION" => &["GENERIC_EXPRESSION"],
        "SIMPLE_NUMERIC_EXPRESSION" => &["NUMERIC_EXPRESSION", "SIMPLE_GENERIC_EXPRESSION"],
        "SIMPLE_STRING_EXPRESSION" => &["STRING_EXPRESSION", "SIMPLE_GENERIC_EXPRESSION"],
        "SIN_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "SLASH_EXPRESSION" => &["BINARY_NUMERIC_EXPRESSION"],
        "SLIDING_CURVE_PAIR" => &["PLANAR_CURVE_PAIR"],
        "SLIDING_CURVE_PAIR_VALUE" => &["PAIR_VALUE"],
        "SLIDING_SURFACE_PAIR" => &["SURFACE_PAIR"],
        "SLIDING_SURFACE_PAIR_VALUE" => &["PAIR_VALUE"],
        "SLOT" => &["FEATURE_DEFINITION"],
        "SLOT_END" => &["SHAPE_ASPECT"],
        "SOLID_ANGLE_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "SOLID_ANGLE_UNIT" => &["NAMED_UNIT"],
        "SOLID_MODEL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "SOLID_REPLICA" => &["SOLID_MODEL"],
        "SPECIFIED_HIGHER_USAGE_OCCURRENCE" => &["ASSEMBLY_COMPONENT_USAGE"],
        "SPHERE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "SPHERICAL_PAIR" => &["KINEMATIC_PAIR"],
        "SPHERICAL_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "SPHERICAL_PAIR_VALUE" => &["PAIR_VALUE"],
        "SPHERICAL_SURFACE" => &["ELEMENTARY_SURFACE"],
        "SQL_MAPPABLE_DEFINED_FUNCTION" => &["DEFINED_FUNCTION"],
        "SQUARE_ROOT_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "SQUARE_U_PROFILE" => &["SHAPE_ASPECT"],
        "STANDARD_UNCERTAINTY" => &["UNCERTAINTY_QUALIFIER"],
        "STRAIGHTNESS_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "STRING_DEFINED_FUNCTION" => &["DEFINED_FUNCTION", "STRING_EXPRESSION"],
        "STRING_EXPRESSION" => &["EXPRESSION"],
        "STRING_LITERAL" => &["SIMPLE_STRING_EXPRESSION", "GENERIC_LITERAL"],
        "STRING_VARIABLE" => &["SIMPLE_STRING_EXPRESSION", "VARIABLE"],
        "STRUCTURED_DIMENSION_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "STYLED_ITEM" => &["REPRESENTATION_ITEM"],
        "SUBEDGE" => &["EDGE"],
        "SUBFACE" => &["FACE"],
        "SUBSTRING_EXPRESSION" => &["STRING_EXPRESSION", "MULTIPLE_ARITY_GENERIC_EXPRESSION"],
        "SURFACE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "SURFACE_CONDITION_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "SURFACE_CURVE" => &["CURVE"],
        "SURFACE_CURVE_SWEPT_AREA_SOLID" => &["SWEPT_AREA_SOLID"],
        "SURFACE_OF_LINEAR_EXTRUSION" => &["SWEPT_SURFACE"],
        "SURFACE_OF_REVOLUTION" => &["SWEPT_SURFACE"],
        "SURFACE_PAIR" => &["KINEMATIC_PAIR"],
        "SURFACE_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "SURFACE_PATCH" => &["FOUNDED_ITEM"],
        "SURFACE_PROFILE_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "SURFACE_REPLICA" => &["SURFACE"],
        "SURFACE_SIDE_STYLE" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_BOUNDARY" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_CONTROL_GRID" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_FILL_AREA" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_PARAMETER_LINE" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE" => &["SURFACE_STYLE_REFLECTANCE_AMBIENT"],
        "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE_SPECULAR" => &["SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE"],
        "SURFACE_STYLE_RENDERING_WITH_PROPERTIES" => &["SURFACE_STYLE_RENDERING"],
        "SURFACE_STYLE_SEGMENTATION_CURVE" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_SILHOUETTE" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_USAGE" => &["FOUNDED_ITEM"],
        "SURFACE_TEXTURE_REPRESENTATION" => &["REPRESENTATION"],
        "SWEPT_AREA_SOLID" => &["SOLID_MODEL"],
        "SWEPT_DISK_SOLID" => &["SOLID_MODEL"],
        "SWEPT_FACE_SOLID" => &["SOLID_MODEL"],
        "SWEPT_SURFACE" => &["SURFACE"],
        "SYMBOL_REPRESENTATION" => &["REPRESENTATION"],
        "SYMBOL_REPRESENTATION_MAP" => &["REPRESENTATION_MAP"],
        "SYMBOL_STYLE" => &["FOUNDED_ITEM"],
        "SYMBOL_TARGET" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "SYMMETRIC_SHAPE_ASPECT" => &["SHAPE_ASPECT"],
        "SYMMETRY_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "TACTILE_APPEARANCE_REPRESENTATION" => &["REPRESENTATION"],
        "TAN_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "TANGENT" => &["DERIVED_SHAPE_ASPECT"],
        "TAPER" => &["SHAPE_ASPECT"],
        "TEE_PROFILE" => &["SHAPE_ASPECT"],
        "TERMINATOR_SYMBOL" => &["ANNOTATION_SYMBOL_OCCURRENCE"],
        "TEXT_LITERAL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "TEXT_LITERAL_WITH_ASSOCIATED_CURVES" => &["TEXT_LITERAL"],
        "TEXT_LITERAL_WITH_BLANKING_BOX" => &["TEXT_LITERAL"],
        "TEXT_LITERAL_WITH_DELINEATION" => &["TEXT_LITERAL"],
        "TEXT_LITERAL_WITH_EXTENT" => &["TEXT_LITERAL"],
        "TEXT_STRING_REPRESENTATION" => &["REPRESENTATION"],
        "TEXT_STYLE" => &["FOUNDED_ITEM"],
        "TEXT_STYLE_WITH_BOX_CHARACTERISTICS" => &["TEXT_STYLE"],
        "TEXT_STYLE_WITH_MIRROR" => &["TEXT_STYLE"],
        "TEXT_STYLE_WITH_SPACING" => &["TEXT_STYLE"],
        "THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "THERMODYNAMIC_TEMPERATURE_UNIT" => &["NAMED_UNIT"],
        "THREAD" => &["FEATURE_DEFINITION"],
        "TIME_INTERVAL_BASED_EFFECTIVITY" => &["EFFECTIVITY"],
        "TIME_INTERVAL_WITH_BOUNDS" => &["TIME_INTERVAL"],
        "TIME_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "TIME_UNIT" => &["NAMED_UNIT"],
        "TOLERANCE_ZONE" => &["SHAPE_ASPECT"],
        "TOPOLOGICAL_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "TOROIDAL_SURFACE" => &["ELEMENTARY_SURFACE"],
        "TORUS" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "TOTAL_RUNOUT_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "TRANSITION_FEATURE" => &["SHAPE_ASPECT"],
        "TRIMMED_CURVE" => &["BOUNDED_CURVE"],
        "TWO_DIRECTION_REPEAT_FACTOR" => &["ONE_DIRECTION_REPEAT_FACTOR"],
        "UNARY_BOOLEAN_EXPRESSION" => &["BOOLEAN_EXPRESSION", "UNARY_GENERIC_EXPRESSION"],
        "UNARY_FUNCTION_CALL" => &["UNARY_NUMERIC_EXPRESSION"],
        "UNARY_GENERIC_EXPRESSION" => &["GENERIC_EXPRESSION"],
        "UNARY_NUMERIC_EXPRESSION" => &["NUMERIC_EXPRESSION", "UNARY_GENERIC_EXPRESSION"],
        "UNCERTAINTY_ASSIGNED_REPRESENTATION" => &["REPRESENTATION"],
        "UNCERTAINTY_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "UNCONSTRAINED_PAIR" => &["KINEMATIC_PAIR"],
        "UNCONSTRAINED_PAIR_VALUE" => &["PAIR_VALUE"],
        "UNIFORM_CURVE" => &["B_SPLINE_CURVE"],
        "UNIFORM_SURFACE" => &["B_SPLINE_SURFACE"],
        "UNIVERSAL_PAIR" => &["KINEMATIC_PAIR"],
        "UNIVERSAL_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "UNIVERSAL_PAIR_VALUE" => &["PAIR_VALUE"],
        "VALUE_FUNCTION" => &["NUMERIC_EXPRESSION", "UNARY_GENERIC_EXPRESSION"],
        "VALUE_RANGE" => &["COMPOUND_REPRESENTATION_ITEM"],
        "VALUE_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "VARIABLE" => &["GENERIC_VARIABLE"],
        "VECTOR" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "VECTOR_STYLE" => &["PRE_DEFINED_TERMINATOR_SYMBOL", "CURVE_STYLE"],
        "VEE_PROFILE" => &["SHAPE_ASPECT"],
        "VERTEX" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "VERTEX_LOOP" => &["LOOP"],
        "VERTEX_POINT" => &["VERTEX", "GEOMETRIC_REPRESENTATION_ITEM"],
        "VIEW_VOLUME" => &["FOUNDED_ITEM"],
        "VISUAL_APPEARANCE_REPRESENTATION" => &["REPRESENTATION"],
        "VOLUME_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "VOLUME_UNIT" => &["DERIVED_UNIT"],
        "XOR_EXPRESSION" => &["BINARY_BOOLEAN_EXPRESSION"],
        _ => &[],
    }
}
