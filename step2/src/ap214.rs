// Autogenerated file, do not hand-edit!
use crate::{
    id::Id,
    parse::{IResult, Logical, Parse, param, parse_complex_mapping},
    step_file::FromEntity,
};
use nom::{
    branch::{alt},
    bytes::complete::{tag},
    character::complete::{alpha0, alphanumeric1, char},
    combinator::{map, recognize},
    multi::{many0},
    sequence::{delimited, pair},
};
#[derive(Debug)]
pub struct AbsFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AbsFunction<'a> = Id<AbsFunction_<'a>>;
impl<'a> FromEntity<'a> for AbsFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AbsFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AbsFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ABS_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AcosFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AcosFunction<'a> = Id<AcosFunction_<'a>>;
impl<'a> FromEntity<'a> for AcosFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AcosFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AcosFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACOS_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Action_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Action<'a> = Id<Action_<'a>>;
impl<'a> FromEntity<'a> for Action_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Action(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Action_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, chosen_method) = param::<ActionMethod<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionAssignment_<'a> { // entity
    pub assigned_action: Action<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionAssignment<'a> = Id<ActionAssignment_<'a>>;
impl<'a> FromEntity<'a> for ActionAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_ASSIGNMENT(")(s)?;
        let (s, assigned_action) = param::<Action<'a>>(true, s)?;
        Ok((s, Self {
            assigned_action,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionDirective_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub analysis: Text<'a>,
    pub comment: Text<'a>,
    pub requests: Vec<VersionedActionRequest<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionDirective<'a> = Id<ActionDirective_<'a>>;
impl<'a> FromEntity<'a> for ActionDirective_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionDirective(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionDirective_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_DIRECTIVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, analysis) = param::<Text<'a>>(false, s)?;
        let (s, comment) = param::<Text<'a>>(false, s)?;
        let (s, requests) = param::<Vec<VersionedActionRequest<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            analysis,
            comment,
            requests,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ActionItem<'a> = Id<ActionItem_<'a>>;

#[derive(Debug)]
pub struct ActionMethod_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub consequence: Text<'a>,
    pub purpose: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionMethod<'a> = Id<ActionMethod_<'a>>;
impl<'a> FromEntity<'a> for ActionMethod_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionMethod(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionMethod_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_METHOD(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, consequence) = param::<Text<'a>>(false, s)?;
        let (s, purpose) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            consequence,
            purpose,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionMethodRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_method: ActionMethod<'a>,
    pub related_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionMethodRelationship<'a> = Id<ActionMethodRelationship_<'a>>;
impl<'a> FromEntity<'a> for ActionMethodRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionMethodRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionMethodRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_METHOD_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_method) = param::<ActionMethod<'a>>(false, s)?;
        let (s, related_method) = param::<ActionMethod<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_method,
            related_method,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionProperty_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub definition: CharacterizedActionDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionProperty<'a> = Id<ActionProperty_<'a>>;
impl<'a> FromEntity<'a> for ActionProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionProperty_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_PROPERTY(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, definition) = param::<CharacterizedActionDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            definition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionPropertyRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub property: ActionProperty<'a>,
    pub representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionPropertyRepresentation<'a> = Id<ActionPropertyRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ActionPropertyRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionPropertyRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionPropertyRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_PROPERTY_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, property) = param::<ActionProperty<'a>>(false, s)?;
        let (s, representation) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            property,
            representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_action: Action<'a>,
    pub related_action: Action<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRelationship<'a> = Id<ActionRelationship_<'a>>;
impl<'a> FromEntity<'a> for ActionRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_action) = param::<Action<'a>>(false, s)?;
        let (s, related_action) = param::<Action<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_action,
            related_action,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionRequestAssignment_<'a> { // entity
    pub assigned_action_request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRequestAssignment<'a> = Id<ActionRequestAssignment_<'a>>;
impl<'a> FromEntity<'a> for ActionRequestAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionRequestAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionRequestAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_REQUEST_ASSIGNMENT(")(s)?;
        let (s, assigned_action_request) = param::<VersionedActionRequest<'a>>(true, s)?;
        Ok((s, Self {
            assigned_action_request,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionRequestItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ActionRequestItem<'a> = Id<ActionRequestItem_<'a>>;

#[derive(Debug)]
pub struct ActionRequestSolution_<'a> { // entity
    pub method: ActionMethod<'a>,
    pub request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRequestSolution<'a> = Id<ActionRequestSolution_<'a>>;
impl<'a> FromEntity<'a> for ActionRequestSolution_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionRequestSolution(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionRequestSolution_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_REQUEST_SOLUTION(")(s)?;
        let (s, method) = param::<ActionMethod<'a>>(false, s)?;
        let (s, request) = param::<VersionedActionRequest<'a>>(true, s)?;
        Ok((s, Self {
            method,
            request,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionRequestStatus_<'a> { // entity
    pub status: Label<'a>,
    pub assigned_request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRequestStatus<'a> = Id<ActionRequestStatus_<'a>>;
impl<'a> FromEntity<'a> for ActionRequestStatus_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionRequestStatus(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionRequestStatus_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_REQUEST_STATUS(")(s)?;
        let (s, status) = param::<Label<'a>>(false, s)?;
        let (s, assigned_request) = param::<VersionedActionRequest<'a>>(true, s)?;
        Ok((s, Self {
            status,
            assigned_request,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionResource_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub usage: Vec<SupportedItem<'a>>,
    pub kind: ActionResourceType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionResource<'a> = Id<ActionResource_<'a>>;
impl<'a> FromEntity<'a> for ActionResource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionResource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionResource_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_RESOURCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, usage) = param::<Vec<SupportedItem<'a>>>(false, s)?;
        let (s, kind) = param::<ActionResourceType<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            usage,
            kind,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionResourceRequirement_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub kind: ResourceRequirementType<'a>,
    pub operations: Vec<CharacterizedActionDefinition<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionResourceRequirement<'a> = Id<ActionResourceRequirement_<'a>>;
impl<'a> FromEntity<'a> for ActionResourceRequirement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionResourceRequirement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionResourceRequirement_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_RESOURCE_REQUIREMENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, kind) = param::<ResourceRequirementType<'a>>(false, s)?;
        let (s, operations) = param::<Vec<CharacterizedActionDefinition<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            kind,
            operations,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionResourceType_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionResourceType<'a> = Id<ActionResourceType_<'a>>;
impl<'a> FromEntity<'a> for ActionResourceType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionResourceType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionResourceType_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_RESOURCE_TYPE(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ActionStatus_<'a> { // entity
    pub status: Label<'a>,
    pub assigned_action: ExecutedAction<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionStatus<'a> = Id<ActionStatus_<'a>>;
impl<'a> FromEntity<'a> for ActionStatus_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionStatus(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ActionStatus_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ACTION_STATUS(")(s)?;
        let (s, status) = param::<Label<'a>>(false, s)?;
        let (s, assigned_action) = param::<ExecutedAction<'a>>(true, s)?;
        Ok((s, Self {
            status,
            assigned_action,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Address_<'a> { // entity
    pub internal_location: Option<Label<'a>>,
    pub street_number: Option<Label<'a>>,
    pub street: Option<Label<'a>>,
    pub postal_box: Option<Label<'a>>,
    pub town: Option<Label<'a>>,
    pub region: Option<Label<'a>>,
    pub postal_code: Option<Label<'a>>,
    pub country: Option<Label<'a>>,
    pub facsimile_number: Option<Label<'a>>,
    pub telephone_number: Option<Label<'a>>,
    pub electronic_mail_address: Option<Label<'a>>,
    pub telex_number: Option<Label<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Address<'a> = Id<Address_<'a>>;
impl<'a> FromEntity<'a> for Address_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Address(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Address_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ADDRESS(")(s)?;
        let (s, internal_location) = param::<Option<Label<'a>>>(false, s)?;
        let (s, street_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, street) = param::<Option<Label<'a>>>(false, s)?;
        let (s, postal_box) = param::<Option<Label<'a>>>(false, s)?;
        let (s, town) = param::<Option<Label<'a>>>(false, s)?;
        let (s, region) = param::<Option<Label<'a>>>(false, s)?;
        let (s, postal_code) = param::<Option<Label<'a>>>(false, s)?;
        let (s, country) = param::<Option<Label<'a>>>(false, s)?;
        let (s, facsimile_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, telephone_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, electronic_mail_address) = param::<Option<Label<'a>>>(false, s)?;
        let (s, telex_number) = param::<Option<Label<'a>>>(true, s)?;
        Ok((s, Self {
            internal_location,
            street_number,
            street,
            postal_box,
            town,
            region,
            postal_code,
            country,
            facsimile_number,
            telephone_number,
            electronic_mail_address,
            telex_number,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AdvancedBrepShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AdvancedBrepShapeRepresentation<'a> = Id<AdvancedBrepShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for AdvancedBrepShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AdvancedBrepShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AdvancedBrepShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ADVANCED_BREP_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AdvancedFace_<'a> { // entity
    pub name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    pub face_geometry: Surface<'a>,
    pub same_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AdvancedFace<'a> = Id<AdvancedFace_<'a>>;
impl<'a> FromEntity<'a> for AdvancedFace_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AdvancedFace(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AdvancedFace_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ADVANCED_FACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, bounds) = param::<Vec<FaceBound<'a>>>(false, s)?;
        let (s, face_geometry) = param::<Surface<'a>>(false, s)?;
        let (s, same_sense) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            bounds,
            face_geometry,
            same_sense,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum AheadOrBehind<'a> { // enum
    Ahead,
    Exact,
    Behind,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for AheadOrBehind<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use AheadOrBehind::*;
        alt((
            map(tag(".AHEAD."), |_| Ahead),
            map(tag(".EXACT."), |_| Exact),
            map(tag(".BEHIND."), |_| Behind),
        ))(s)
    }
}
#[derive(Debug)]
pub struct AlternateProductRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub definition: Option<Text<'a>>,
    pub alternate: Product<'a>,
    pub base: Product<'a>,
    pub basis: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AlternateProductRelationship<'a> = Id<AlternateProductRelationship_<'a>>;
impl<'a> FromEntity<'a> for AlternateProductRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AlternateProductRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AlternateProductRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ALTERNATE_PRODUCT_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, definition) = param::<Option<Text<'a>>>(false, s)?;
        let (s, alternate) = param::<Product<'a>>(false, s)?;
        let (s, base) = param::<Product<'a>>(false, s)?;
        let (s, basis) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            name,
            definition,
            alternate,
            base,
            basis,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AmountOfSubstanceMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for AmountOfSubstanceMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct AmountOfSubstanceMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AmountOfSubstanceMeasureWithUnit<'a> = Id<AmountOfSubstanceMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for AmountOfSubstanceMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AmountOfSubstanceMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AmountOfSubstanceMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AmountOfSubstanceUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AmountOfSubstanceUnit<'a> = Id<AmountOfSubstanceUnit_<'a>>;
impl<'a> FromEntity<'a> for AmountOfSubstanceUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AmountOfSubstanceUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AmountOfSubstanceUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("AMOUNT_OF_SUBSTANCE_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AndExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AndExpression<'a> = Id<AndExpression_<'a>>;
impl<'a> FromEntity<'a> for AndExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AndExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AndExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("AND_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum AngleRelator<'a> { // enum
    Equal,
    Large,
    Small,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for AngleRelator<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use AngleRelator::*;
        alt((
            map(tag(".EQUAL."), |_| Equal),
            map(tag(".LARGE."), |_| Large),
            map(tag(".SMALL."), |_| Small),
        ))(s)
    }
}
#[derive(Debug)]
pub struct AngularDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularDimension<'a> = Id<AngularDimension_<'a>>;
impl<'a> FromEntity<'a> for AngularDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AngularDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AngularDimension_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANGULAR_DIMENSION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AngularLocation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    pub angle_selection: AngleRelator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularLocation<'a> = Id<AngularLocation_<'a>>;
impl<'a> FromEntity<'a> for AngularLocation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AngularLocation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AngularLocation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANGULAR_LOCATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, angle_selection) = param::<AngleRelator<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            angle_selection,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AngularSize_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    pub angle_selection: AngleRelator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularSize<'a> = Id<AngularSize_<'a>>;
impl<'a> FromEntity<'a> for AngularSize_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AngularSize(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AngularSize_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANGULAR_SIZE(")(s)?;
        let (s, applies_to) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, angle_selection) = param::<AngleRelator<'a>>(true, s)?;
        Ok((s, Self {
            applies_to,
            name,
            angle_selection,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AngularityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularityTolerance<'a> = Id<AngularityTolerance_<'a>>;
impl<'a> FromEntity<'a> for AngularityTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AngularityTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AngularityTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANGULARITY_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, datum_system) = param::<Vec<DatumReference<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationCurveOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationCurveOccurrence<'a> = Id<AnnotationCurveOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationCurveOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationCurveOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationCurveOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_CURVE_OCCURRENCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationFillArea_<'a> { // entity
    pub name: Label<'a>,
    pub boundaries: Vec<Curve<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationFillArea<'a> = Id<AnnotationFillArea_<'a>>;
impl<'a> FromEntity<'a> for AnnotationFillArea_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationFillArea(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationFillArea_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_FILL_AREA(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, boundaries) = param::<Vec<Curve<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            boundaries,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationFillAreaOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub fill_style_target: Point<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationFillAreaOccurrence<'a> = Id<AnnotationFillAreaOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationFillAreaOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationFillAreaOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationFillAreaOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_FILL_AREA_OCCURRENCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, fill_style_target) = param::<Point<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            fill_style_target,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationOccurrence<'a> = Id<AnnotationOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_OCCURRENCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationOccurrenceAssociativity_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_annotation_occurrence: AnnotationOccurrence<'a>,
    pub related_annotation_occurrence: AnnotationOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationOccurrenceAssociativity<'a> = Id<AnnotationOccurrenceAssociativity_<'a>>;
impl<'a> FromEntity<'a> for AnnotationOccurrenceAssociativity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationOccurrenceAssociativity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationOccurrenceAssociativity_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_OCCURRENCE_ASSOCIATIVITY(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, relating_annotation_occurrence) = param::<AnnotationOccurrence<'a>>(false, s)?;
        let (s, related_annotation_occurrence) = param::<AnnotationOccurrence<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_annotation_occurrence,
            related_annotation_occurrence,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationOccurrenceRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_annotation_occurrence: AnnotationOccurrence<'a>,
    pub related_annotation_occurrence: AnnotationOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationOccurrenceRelationship<'a> = Id<AnnotationOccurrenceRelationship_<'a>>;
impl<'a> FromEntity<'a> for AnnotationOccurrenceRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationOccurrenceRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationOccurrenceRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_OCCURRENCE_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, relating_annotation_occurrence) = param::<AnnotationOccurrence<'a>>(false, s)?;
        let (s, related_annotation_occurrence) = param::<AnnotationOccurrence<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_annotation_occurrence,
            related_annotation_occurrence,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct AnnotationPlane_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub elements: Option<Vec<AnnotationPlaneElement<'a>>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationPlane<'a> = Id<AnnotationPlane_<'a>>;
impl<'a> FromEntity<'a> for AnnotationPlane_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationPlane(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationPlane_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_PLANE(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, elements) = param::<Option<Vec<AnnotationPlaneElement<'a>>>>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            styles,
            item,
            elements,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationPlaneElement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AnnotationPlaneElement<'a> = Id<AnnotationPlaneElement_<'a>>;

#[derive(Debug)]
pub struct AnnotationSubfigureOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationSubfigureOccurrence<'a> = Id<AnnotationSubfigureOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationSubfigureOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationSubfigureOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationSubfigureOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_SUBFIGURE_OCCURRENCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationSymbol<'a> = Id<AnnotationSymbol_<'a>>;
impl<'a> FromEntity<'a> for AnnotationSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_SYMBOL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, mapping_source) = param::<RepresentationMap<'a>>(false, s)?;
        let (s, mapping_target) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationSymbolOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationSymbolOccurrence<'a> = Id<AnnotationSymbolOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationSymbolOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationSymbolOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationSymbolOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_SYMBOL_OCCURRENCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationSymbolOccurrenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AnnotationSymbolOccurrenceItem<'a> = Id<AnnotationSymbolOccurrenceItem_<'a>>;

#[derive(Debug)]
pub struct AnnotationText_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationText<'a> = Id<AnnotationText_<'a>>;
impl<'a> FromEntity<'a> for AnnotationText_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationText(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationText_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_TEXT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, mapping_source) = param::<RepresentationMap<'a>>(false, s)?;
        let (s, mapping_target) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationTextCharacter_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    pub alignment: TextAlignment<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationTextCharacter<'a> = Id<AnnotationTextCharacter_<'a>>;
impl<'a> FromEntity<'a> for AnnotationTextCharacter_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationTextCharacter(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationTextCharacter_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_TEXT_CHARACTER(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, mapping_source) = param::<RepresentationMap<'a>>(false, s)?;
        let (s, mapping_target) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, alignment) = param::<TextAlignment<'a>>(true, s)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            alignment,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationTextOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationTextOccurrence<'a> = Id<AnnotationTextOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationTextOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationTextOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AnnotationTextOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ANNOTATION_TEXT_OCCURRENCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AnnotationTextOccurrenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AnnotationTextOccurrenceItem<'a> = Id<AnnotationTextOccurrenceItem_<'a>>;

#[derive(Debug)]
pub struct Apex_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Apex<'a> = Id<Apex_<'a>>;
impl<'a> FromEntity<'a> for Apex_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Apex(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Apex_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APEX(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApplicationContext_<'a> { // entity
    pub application: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationContext<'a> = Id<ApplicationContext_<'a>>;
impl<'a> FromEntity<'a> for ApplicationContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApplicationContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApplicationContext_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLICATION_CONTEXT(")(s)?;
        let (s, application) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            application,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApplicationContextElement_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationContextElement<'a> = Id<ApplicationContextElement_<'a>>;
impl<'a> FromEntity<'a> for ApplicationContextElement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApplicationContextElement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApplicationContextElement_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLICATION_CONTEXT_ELEMENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, frame_of_reference) = param::<ApplicationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            frame_of_reference,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApplicationContextRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_context: ApplicationContext<'a>,
    pub related_context: ApplicationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationContextRelationship<'a> = Id<ApplicationContextRelationship_<'a>>;
impl<'a> FromEntity<'a> for ApplicationContextRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApplicationContextRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApplicationContextRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLICATION_CONTEXT_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_context) = param::<ApplicationContext<'a>>(false, s)?;
        let (s, related_context) = param::<ApplicationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_context,
            related_context,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApplicationProtocolDefinition_<'a> { // entity
    pub status: Label<'a>,
    pub application_interpreted_model_schema_name: Label<'a>,
    pub application_protocol_year: YearNumber<'a>,
    pub application: ApplicationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationProtocolDefinition<'a> = Id<ApplicationProtocolDefinition_<'a>>;
impl<'a> FromEntity<'a> for ApplicationProtocolDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApplicationProtocolDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApplicationProtocolDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLICATION_PROTOCOL_DEFINITION(")(s)?;
        let (s, status) = param::<Label<'a>>(false, s)?;
        let (s, application_interpreted_model_schema_name) = param::<Label<'a>>(false, s)?;
        let (s, application_protocol_year) = param::<YearNumber<'a>>(false, s)?;
        let (s, application) = param::<ApplicationContext<'a>>(true, s)?;
        Ok((s, Self {
            status,
            application_interpreted_model_schema_name,
            application_protocol_year,
            application,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedActionAssignment_<'a> { // entity
    pub assigned_action: Action<'a>,
    pub items: Vec<ActionItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedActionAssignment<'a> = Id<AppliedActionAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedActionAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedActionAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedActionAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_ACTION_ASSIGNMENT(")(s)?;
        let (s, assigned_action) = param::<Action<'a>>(false, s)?;
        let (s, items) = param::<Vec<ActionItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_action,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedActionRequestAssignment_<'a> { // entity
    pub assigned_action_request: VersionedActionRequest<'a>,
    pub items: Vec<ActionRequestItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedActionRequestAssignment<'a> = Id<AppliedActionRequestAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedActionRequestAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedActionRequestAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedActionRequestAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_ACTION_REQUEST_ASSIGNMENT(")(s)?;
        let (s, assigned_action_request) = param::<VersionedActionRequest<'a>>(false, s)?;
        let (s, items) = param::<Vec<ActionRequestItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_action_request,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedApprovalAssignment_<'a> { // entity
    pub assigned_approval: Approval<'a>,
    pub items: Vec<ApprovalItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedApprovalAssignment<'a> = Id<AppliedApprovalAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedApprovalAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedApprovalAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedApprovalAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_APPROVAL_ASSIGNMENT(")(s)?;
        let (s, assigned_approval) = param::<Approval<'a>>(false, s)?;
        let (s, items) = param::<Vec<ApprovalItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_approval,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedArea_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedArea<'a> = Id<AppliedArea_<'a>>;
impl<'a> FromEntity<'a> for AppliedArea_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedArea(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedArea_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_AREA(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedCertificationAssignment_<'a> { // entity
    pub assigned_certification: Certification<'a>,
    pub items: Vec<CertificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedCertificationAssignment<'a> = Id<AppliedCertificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedCertificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedCertificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedCertificationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_CERTIFICATION_ASSIGNMENT(")(s)?;
        let (s, assigned_certification) = param::<Certification<'a>>(false, s)?;
        let (s, items) = param::<Vec<CertificationItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_certification,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedClassificationAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub role: ClassificationRole<'a>,
    pub items: Vec<ClassificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedClassificationAssignment<'a> = Id<AppliedClassificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedClassificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedClassificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedClassificationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_CLASSIFICATION_ASSIGNMENT(")(s)?;
        let (s, assigned_class) = param::<Group<'a>>(false, s)?;
        let (s, role) = param::<ClassificationRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<ClassificationItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_class,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedContractAssignment_<'a> { // entity
    pub assigned_contract: Contract<'a>,
    pub items: Vec<ContractItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedContractAssignment<'a> = Id<AppliedContractAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedContractAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedContractAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedContractAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_CONTRACT_ASSIGNMENT(")(s)?;
        let (s, assigned_contract) = param::<Contract<'a>>(false, s)?;
        let (s, items) = param::<Vec<ContractItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_contract,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedDateAndTimeAssignment_<'a> { // entity
    pub assigned_date_and_time: DateAndTime<'a>,
    pub role: DateTimeRole<'a>,
    pub items: Vec<DateAndTimeItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDateAndTimeAssignment<'a> = Id<AppliedDateAndTimeAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedDateAndTimeAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedDateAndTimeAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedDateAndTimeAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_DATE_AND_TIME_ASSIGNMENT(")(s)?;
        let (s, assigned_date_and_time) = param::<DateAndTime<'a>>(false, s)?;
        let (s, role) = param::<DateTimeRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<DateAndTimeItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_date_and_time,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedDateAssignment_<'a> { // entity
    pub assigned_date: Date<'a>,
    pub role: DateRole<'a>,
    pub items: Vec<DateItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDateAssignment<'a> = Id<AppliedDateAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedDateAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedDateAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedDateAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_DATE_ASSIGNMENT(")(s)?;
        let (s, assigned_date) = param::<Date<'a>>(false, s)?;
        let (s, role) = param::<DateRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<DateItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_date,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedDocumentReference_<'a> { // entity
    pub assigned_document: Document<'a>,
    pub source: Label<'a>,
    pub items: Vec<DocumentReferenceItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDocumentReference<'a> = Id<AppliedDocumentReference_<'a>>;
impl<'a> FromEntity<'a> for AppliedDocumentReference_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedDocumentReference(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedDocumentReference_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_DOCUMENT_REFERENCE(")(s)?;
        let (s, assigned_document) = param::<Document<'a>>(false, s)?;
        let (s, source) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<DocumentReferenceItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_document,
            source,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedDocumentUsageConstraintAssignment_<'a> { // entity
    pub assigned_document_usage: DocumentUsageConstraint<'a>,
    pub role: DocumentUsageRole<'a>,
    pub items: Vec<DocumentReferenceItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDocumentUsageConstraintAssignment<'a> = Id<AppliedDocumentUsageConstraintAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedDocumentUsageConstraintAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedDocumentUsageConstraintAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedDocumentUsageConstraintAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT(")(s)?;
        let (s, assigned_document_usage) = param::<DocumentUsageConstraint<'a>>(false, s)?;
        let (s, role) = param::<DocumentUsageRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<DocumentReferenceItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_document_usage,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedEffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    pub items: Vec<EffectivityItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedEffectivityAssignment<'a> = Id<AppliedEffectivityAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedEffectivityAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedEffectivityAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedEffectivityAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_EFFECTIVITY_ASSIGNMENT(")(s)?;
        let (s, assigned_effectivity) = param::<Effectivity<'a>>(false, s)?;
        let (s, items) = param::<Vec<EffectivityItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_effectivity,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedEventOccurrenceAssignment_<'a> { // entity
    pub assigned_event_occurrence: EventOccurrence<'a>,
    pub role: EventOccurrenceRole<'a>,
    pub items: Vec<EventOccurrenceItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedEventOccurrenceAssignment<'a> = Id<AppliedEventOccurrenceAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedEventOccurrenceAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedEventOccurrenceAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedEventOccurrenceAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_EVENT_OCCURRENCE_ASSIGNMENT(")(s)?;
        let (s, assigned_event_occurrence) = param::<EventOccurrence<'a>>(false, s)?;
        let (s, role) = param::<EventOccurrenceRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<EventOccurrenceItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_event_occurrence,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedExternalIdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    pub source: ExternalSource<'a>,
    pub items: Vec<ExternalIdentificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedExternalIdentificationAssignment<'a> = Id<AppliedExternalIdentificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedExternalIdentificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedExternalIdentificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedExternalIdentificationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT(")(s)?;
        let (s, assigned_id) = param::<Identifier<'a>>(false, s)?;
        let (s, role) = param::<IdentificationRole<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(false, s)?;
        let (s, items) = param::<Vec<ExternalIdentificationItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_id,
            role,
            source,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedGroupAssignment_<'a> { // entity
    pub assigned_group: Group<'a>,
    pub items: Vec<GroupItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedGroupAssignment<'a> = Id<AppliedGroupAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedGroupAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedGroupAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedGroupAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_GROUP_ASSIGNMENT(")(s)?;
        let (s, assigned_group) = param::<Group<'a>>(false, s)?;
        let (s, items) = param::<Vec<GroupItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_group,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedIdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    pub items: Vec<IdentificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedIdentificationAssignment<'a> = Id<AppliedIdentificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedIdentificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedIdentificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedIdentificationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_IDENTIFICATION_ASSIGNMENT(")(s)?;
        let (s, assigned_id) = param::<Identifier<'a>>(false, s)?;
        let (s, role) = param::<IdentificationRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<IdentificationItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_id,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedIneffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    pub items: Vec<EffectivityItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedIneffectivityAssignment<'a> = Id<AppliedIneffectivityAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedIneffectivityAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedIneffectivityAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedIneffectivityAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_INEFFECTIVITY_ASSIGNMENT(")(s)?;
        let (s, assigned_effectivity) = param::<Effectivity<'a>>(false, s)?;
        let (s, items) = param::<Vec<EffectivityItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_effectivity,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedNameAssignment_<'a> { // entity
    pub assigned_name: Label<'a>,
    pub items: Vec<NameItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedNameAssignment<'a> = Id<AppliedNameAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedNameAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedNameAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedNameAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_NAME_ASSIGNMENT(")(s)?;
        let (s, assigned_name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<NameItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_name,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedOrganizationAssignment_<'a> { // entity
    pub assigned_organization: Organization<'a>,
    pub role: OrganizationRole<'a>,
    pub items: Vec<OrganizationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedOrganizationAssignment<'a> = Id<AppliedOrganizationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedOrganizationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedOrganizationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedOrganizationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_ORGANIZATION_ASSIGNMENT(")(s)?;
        let (s, assigned_organization) = param::<Organization<'a>>(false, s)?;
        let (s, role) = param::<OrganizationRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<OrganizationItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_organization,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedOrganizationalProjectAssignment_<'a> { // entity
    pub assigned_organizational_project: OrganizationalProject<'a>,
    pub role: OrganizationalProjectRole<'a>,
    pub items: Vec<OrganizationalProjectItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedOrganizationalProjectAssignment<'a> = Id<AppliedOrganizationalProjectAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedOrganizationalProjectAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedOrganizationalProjectAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedOrganizationalProjectAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT(")(s)?;
        let (s, assigned_organizational_project) = param::<OrganizationalProject<'a>>(false, s)?;
        let (s, role) = param::<OrganizationalProjectRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<OrganizationalProjectItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_organizational_project,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedPersonAndOrganizationAssignment_<'a> { // entity
    pub assigned_person_and_organization: PersonAndOrganization<'a>,
    pub role: PersonAndOrganizationRole<'a>,
    pub items: Vec<PersonAndOrganizationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedPersonAndOrganizationAssignment<'a> = Id<AppliedPersonAndOrganizationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedPersonAndOrganizationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedPersonAndOrganizationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedPersonAndOrganizationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT(")(s)?;
        let (s, assigned_person_and_organization) = param::<PersonAndOrganization<'a>>(false, s)?;
        let (s, role) = param::<PersonAndOrganizationRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<PersonAndOrganizationItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_person_and_organization,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedPresentedItem_<'a> { // entity
    pub items: Vec<PresentedItemSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedPresentedItem<'a> = Id<AppliedPresentedItem_<'a>>;
impl<'a> FromEntity<'a> for AppliedPresentedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedPresentedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedPresentedItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_PRESENTED_ITEM(")(s)?;
        let (s, items) = param::<Vec<PresentedItemSelect<'a>>>(true, s)?;
        Ok((s, Self {
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedSecurityClassificationAssignment_<'a> { // entity
    pub assigned_security_classification: SecurityClassification<'a>,
    pub items: Vec<SecurityClassificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedSecurityClassificationAssignment<'a> = Id<AppliedSecurityClassificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedSecurityClassificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedSecurityClassificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedSecurityClassificationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT(")(s)?;
        let (s, assigned_security_classification) = param::<SecurityClassification<'a>>(false, s)?;
        let (s, items) = param::<Vec<SecurityClassificationItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_security_classification,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AppliedTimeIntervalAssignment_<'a> { // entity
    pub assigned_time_interval: TimeInterval<'a>,
    pub role: TimeIntervalRole<'a>,
    pub items: Vec<TimeIntervalItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedTimeIntervalAssignment<'a> = Id<AppliedTimeIntervalAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedTimeIntervalAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedTimeIntervalAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AppliedTimeIntervalAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPLIED_TIME_INTERVAL_ASSIGNMENT(")(s)?;
        let (s, assigned_time_interval) = param::<TimeInterval<'a>>(false, s)?;
        let (s, role) = param::<TimeIntervalRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<TimeIntervalItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_time_interval,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Approval_<'a> { // entity
    pub status: ApprovalStatus<'a>,
    pub level: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Approval<'a> = Id<Approval_<'a>>;
impl<'a> FromEntity<'a> for Approval_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Approval(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Approval_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPROVAL(")(s)?;
        let (s, status) = param::<ApprovalStatus<'a>>(false, s)?;
        let (s, level) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            status,
            level,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApprovalAssignment_<'a> { // entity
    pub assigned_approval: Approval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalAssignment<'a> = Id<ApprovalAssignment_<'a>>;
impl<'a> FromEntity<'a> for ApprovalAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApprovalAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPROVAL_ASSIGNMENT(")(s)?;
        let (s, assigned_approval) = param::<Approval<'a>>(true, s)?;
        Ok((s, Self {
            assigned_approval,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApprovalDateTime_<'a> { // entity
    pub date_time: DateTimeSelect<'a>,
    pub dated_approval: Approval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalDateTime<'a> = Id<ApprovalDateTime_<'a>>;
impl<'a> FromEntity<'a> for ApprovalDateTime_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalDateTime(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApprovalDateTime_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPROVAL_DATE_TIME(")(s)?;
        let (s, date_time) = param::<DateTimeSelect<'a>>(false, s)?;
        let (s, dated_approval) = param::<Approval<'a>>(true, s)?;
        Ok((s, Self {
            date_time,
            dated_approval,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApprovalItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ApprovalItem<'a> = Id<ApprovalItem_<'a>>;

#[derive(Debug)]
pub struct ApprovalPersonOrganization_<'a> { // entity
    pub person_organization: PersonOrganizationSelect<'a>,
    pub authorized_approval: Approval<'a>,
    pub role: ApprovalRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalPersonOrganization<'a> = Id<ApprovalPersonOrganization_<'a>>;
impl<'a> FromEntity<'a> for ApprovalPersonOrganization_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalPersonOrganization(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApprovalPersonOrganization_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPROVAL_PERSON_ORGANIZATION(")(s)?;
        let (s, person_organization) = param::<PersonOrganizationSelect<'a>>(false, s)?;
        let (s, authorized_approval) = param::<Approval<'a>>(false, s)?;
        let (s, role) = param::<ApprovalRole<'a>>(true, s)?;
        Ok((s, Self {
            person_organization,
            authorized_approval,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApprovalRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_approval: Approval<'a>,
    pub related_approval: Approval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalRelationship<'a> = Id<ApprovalRelationship_<'a>>;
impl<'a> FromEntity<'a> for ApprovalRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApprovalRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPROVAL_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_approval) = param::<Approval<'a>>(false, s)?;
        let (s, related_approval) = param::<Approval<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_approval,
            related_approval,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApprovalRole_<'a> { // entity
    pub role: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalRole<'a> = Id<ApprovalRole_<'a>>;
impl<'a> FromEntity<'a> for ApprovalRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApprovalRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPROVAL_ROLE(")(s)?;
        let (s, role) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApprovalStatus_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalStatus<'a> = Id<ApprovalStatus_<'a>>;
impl<'a> FromEntity<'a> for ApprovalStatus_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalStatus(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApprovalStatus_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPROVAL_STATUS(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum ApproximationMethod<'a> { // enum
    ChordalDeviation,
    ChordalLength,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ApproximationMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ApproximationMethod::*;
        alt((
            map(tag(".CHORDAL_DEVIATION."), |_| ChordalDeviation),
            map(tag(".CHORDAL_LENGTH."), |_| ChordalLength),
        ))(s)
    }
}
#[derive(Debug)]
pub struct ApproximationTolerance_<'a> { // entity
    pub tolerance: ToleranceSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApproximationTolerance<'a> = Id<ApproximationTolerance_<'a>>;
impl<'a> FromEntity<'a> for ApproximationTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApproximationTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApproximationTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPROXIMATION_TOLERANCE(")(s)?;
        let (s, tolerance) = param::<ToleranceSelect<'a>>(true, s)?;
        Ok((s, Self {
            tolerance,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApproximationToleranceDeviation_<'a> { // entity
    pub tessellation_type: ApproximationMethod<'a>,
    pub tolerances: Vec<ToleranceDeviationSelect<'a>>,
    pub definition_space: ProductOrPresentationSpace<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApproximationToleranceDeviation<'a> = Id<ApproximationToleranceDeviation_<'a>>;
impl<'a> FromEntity<'a> for ApproximationToleranceDeviation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApproximationToleranceDeviation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApproximationToleranceDeviation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPROXIMATION_TOLERANCE_DEVIATION(")(s)?;
        let (s, tessellation_type) = param::<ApproximationMethod<'a>>(false, s)?;
        let (s, tolerances) = param::<Vec<ToleranceDeviationSelect<'a>>>(false, s)?;
        let (s, definition_space) = param::<ProductOrPresentationSpace<'a>>(true, s)?;
        Ok((s, Self {
            tessellation_type,
            tolerances,
            definition_space,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ApproximationToleranceParameter_<'a> { // entity
    pub tolerances: Vec<ToleranceParameterSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApproximationToleranceParameter<'a> = Id<ApproximationToleranceParameter_<'a>>;
impl<'a> FromEntity<'a> for ApproximationToleranceParameter_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApproximationToleranceParameter(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ApproximationToleranceParameter_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("APPROXIMATION_TOLERANCE_PARAMETER(")(s)?;
        let (s, tolerances) = param::<Vec<ToleranceParameterSelect<'a>>>(true, s)?;
        Ok((s, Self {
            tolerances,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AreaInSet_<'a> { // entity
    pub area: PresentationArea<'a>,
    pub in_set: PresentationSet<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AreaInSet<'a> = Id<AreaInSet_<'a>>;
impl<'a> FromEntity<'a> for AreaInSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AreaInSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AreaInSet_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("AREA_IN_SET(")(s)?;
        let (s, area) = param::<PresentationArea<'a>>(false, s)?;
        let (s, in_set) = param::<PresentationSet<'a>>(true, s)?;
        Ok((s, Self {
            area,
            in_set,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AreaMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for AreaMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct AreaMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AreaMeasureWithUnit<'a> = Id<AreaMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for AreaMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AreaMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AreaMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("AREA_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AreaOrView_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AreaOrView<'a> = Id<AreaOrView_<'a>>;

#[derive(Debug)]
pub struct AreaUnit_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AreaUnit<'a> = Id<AreaUnit_<'a>>;
impl<'a> FromEntity<'a> for AreaUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AreaUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AreaUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("AREA_UNIT(")(s)?;
        let (s, elements) = param::<Vec<DerivedUnitElement<'a>>>(true, s)?;
        Ok((s, Self {
            elements,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AsinFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AsinFunction<'a> = Id<AsinFunction_<'a>>;
impl<'a> FromEntity<'a> for AsinFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AsinFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AsinFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ASIN_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AssemblyComponentUsage_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AssemblyComponentUsage<'a> = Id<AssemblyComponentUsage_<'a>>;
impl<'a> FromEntity<'a> for AssemblyComponentUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AssemblyComponentUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AssemblyComponentUsage_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ASSEMBLY_COMPONENT_USAGE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, related_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, reference_designator) = param::<Option<Identifier<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            reference_designator,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AssemblyComponentUsageSubstitute_<'a> { // entity
    pub name: Label<'a>,
    pub definition: Option<Text<'a>>,
    pub base: AssemblyComponentUsage<'a>,
    pub substitute: AssemblyComponentUsage<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AssemblyComponentUsageSubstitute<'a> = Id<AssemblyComponentUsageSubstitute_<'a>>;
impl<'a> FromEntity<'a> for AssemblyComponentUsageSubstitute_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AssemblyComponentUsageSubstitute(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AssemblyComponentUsageSubstitute_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ASSEMBLY_COMPONENT_USAGE_SUBSTITUTE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, definition) = param::<Option<Text<'a>>>(false, s)?;
        let (s, base) = param::<AssemblyComponentUsage<'a>>(false, s)?;
        let (s, substitute) = param::<AssemblyComponentUsage<'a>>(true, s)?;
        Ok((s, Self {
            name,
            definition,
            base,
            substitute,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AtanFunction_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AtanFunction<'a> = Id<AtanFunction_<'a>>;
impl<'a> FromEntity<'a> for AtanFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AtanFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AtanFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ATAN_FUNCTION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AttributeClassificationAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub attribute_name: Label<'a>,
    pub role: ClassificationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeClassificationAssignment<'a> = Id<AttributeClassificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AttributeClassificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AttributeClassificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AttributeClassificationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ATTRIBUTE_CLASSIFICATION_ASSIGNMENT(")(s)?;
        let (s, assigned_class) = param::<Group<'a>>(false, s)?;
        let (s, attribute_name) = param::<Label<'a>>(false, s)?;
        let (s, role) = param::<ClassificationRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_class,
            attribute_name,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AttributeLanguageAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub attribute_name: Label<'a>,
    pub role: ClassificationRole<'a>,
    pub items: Vec<AttributeLanguageItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeLanguageAssignment<'a> = Id<AttributeLanguageAssignment_<'a>>;
impl<'a> FromEntity<'a> for AttributeLanguageAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AttributeLanguageAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AttributeLanguageAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ATTRIBUTE_LANGUAGE_ASSIGNMENT(")(s)?;
        let (s, assigned_class) = param::<Group<'a>>(false, s)?;
        let (s, attribute_name) = param::<Label<'a>>(false, s)?;
        let (s, role) = param::<ClassificationRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<AttributeLanguageItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_class,
            attribute_name,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AttributeLanguageItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AttributeLanguageItem<'a> = Id<AttributeLanguageItem_<'a>>;

#[derive(Debug)]
pub enum AttributeType<'a> { // select
    Label(Label<'a>),
    Text(Text<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for AttributeType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LABEL("), <Label<'a>>::parse, char(')')), |r| AttributeType::Label(r)),
            map(delimited(tag("TEXT("), <Text<'a>>::parse, char(')')), |r| AttributeType::Text(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct AttributeValueAssignment_<'a> { // entity
    pub attribute_name: Label<'a>,
    pub attribute_value: AttributeType<'a>,
    pub role: AttributeValueRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeValueAssignment<'a> = Id<AttributeValueAssignment_<'a>>;
impl<'a> FromEntity<'a> for AttributeValueAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AttributeValueAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AttributeValueAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ATTRIBUTE_VALUE_ASSIGNMENT(")(s)?;
        let (s, attribute_name) = param::<Label<'a>>(false, s)?;
        let (s, attribute_value) = param::<AttributeType<'a>>(false, s)?;
        let (s, role) = param::<AttributeValueRole<'a>>(true, s)?;
        Ok((s, Self {
            attribute_name,
            attribute_value,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct AttributeValueRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeValueRole<'a> = Id<AttributeValueRole_<'a>>;
impl<'a> FromEntity<'a> for AttributeValueRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AttributeValueRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for AttributeValueRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ATTRIBUTE_VALUE_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Axis1Placement_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    pub axis: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Axis1Placement<'a> = Id<Axis1Placement_<'a>>;
impl<'a> FromEntity<'a> for Axis1Placement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Axis1Placement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Axis1Placement_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("AXIS1_PLACEMENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, location) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, axis) = param::<Option<Direction<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            location,
            axis,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Axis2Placement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Axis2Placement<'a> = Id<Axis2Placement_<'a>>;

#[derive(Debug)]
pub struct Axis2Placement2d_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    pub ref_direction: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Axis2Placement2d<'a> = Id<Axis2Placement2d_<'a>>;
impl<'a> FromEntity<'a> for Axis2Placement2d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Axis2Placement2d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Axis2Placement2d_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("AXIS2_PLACEMENT_2D(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, location) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, ref_direction) = param::<Option<Direction<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            location,
            ref_direction,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Axis2Placement3d_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    pub axis: Option<Direction<'a>>,
    pub ref_direction: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Axis2Placement3d<'a> = Id<Axis2Placement3d_<'a>>;
impl<'a> FromEntity<'a> for Axis2Placement3d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Axis2Placement3d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Axis2Placement3d_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("AXIS2_PLACEMENT_3D(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, location) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, axis) = param::<Option<Direction<'a>>>(false, s)?;
        let (s, ref_direction) = param::<Option<Direction<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            location,
            axis,
            ref_direction,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BSplineCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineCurve<'a> = Id<BSplineCurve_<'a>>;
impl<'a> FromEntity<'a> for BSplineCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BSplineCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BSplineCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("B_SPLINE_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<CartesianPoint<'a>>>(false, s)?;
        let (s, curve_form) = param::<BSplineCurveForm<'a>>(false, s)?;
        let (s, closed_curve) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum BSplineCurveForm<'a> { // enum
    PolylineForm,
    CircularArc,
    EllipticArc,
    ParabolicArc,
    HyperbolicArc,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BSplineCurveForm<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BSplineCurveForm::*;
        alt((
            map(tag(".POLYLINE_FORM."), |_| PolylineForm),
            map(tag(".CIRCULAR_ARC."), |_| CircularArc),
            map(tag(".ELLIPTIC_ARC."), |_| EllipticArc),
            map(tag(".PARABOLIC_ARC."), |_| ParabolicArc),
            map(tag(".HYPERBOLIC_ARC."), |_| HyperbolicArc),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
#[derive(Debug)]
pub struct BSplineCurveWithKnots_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    pub knot_multiplicities: Vec<i64>,
    pub knots: Vec<ParameterValue<'a>>,
    pub knot_spec: KnotType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineCurveWithKnots<'a> = Id<BSplineCurveWithKnots_<'a>>;
impl<'a> FromEntity<'a> for BSplineCurveWithKnots_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BSplineCurveWithKnots(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BSplineCurveWithKnots_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("B_SPLINE_CURVE_WITH_KNOTS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<CartesianPoint<'a>>>(false, s)?;
        let (s, curve_form) = param::<BSplineCurveForm<'a>>(false, s)?;
        let (s, closed_curve) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(false, s)?;
        let (s, knot_multiplicities) = param::<Vec<i64>>(false, s)?;
        let (s, knots) = param::<Vec<ParameterValue<'a>>>(false, s)?;
        let (s, knot_spec) = param::<KnotType<'a>>(true, s)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            knot_multiplicities,
            knots,
            knot_spec,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BSplineSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineSurface<'a> = Id<BSplineSurface_<'a>>;
impl<'a> FromEntity<'a> for BSplineSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BSplineSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BSplineSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("B_SPLINE_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, u_degree) = param::<i64>(false, s)?;
        let (s, v_degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<Vec<CartesianPoint<'a>>>>(false, s)?;
        let (s, surface_form) = param::<BSplineSurfaceForm<'a>>(false, s)?;
        let (s, u_closed) = param::<Logical>(false, s)?;
        let (s, v_closed) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum BSplineSurfaceForm<'a> { // enum
    PlaneSurf,
    CylindricalSurf,
    ConicalSurf,
    SphericalSurf,
    ToroidalSurf,
    SurfOfRevolution,
    RuledSurf,
    GeneralisedCone,
    QuadricSurf,
    SurfOfLinearExtrusion,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BSplineSurfaceForm<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BSplineSurfaceForm::*;
        alt((
            map(tag(".PLANE_SURF."), |_| PlaneSurf),
            map(tag(".CYLINDRICAL_SURF."), |_| CylindricalSurf),
            map(tag(".CONICAL_SURF."), |_| ConicalSurf),
            map(tag(".SPHERICAL_SURF."), |_| SphericalSurf),
            map(tag(".TOROIDAL_SURF."), |_| ToroidalSurf),
            map(tag(".SURF_OF_REVOLUTION."), |_| SurfOfRevolution),
            map(tag(".RULED_SURF."), |_| RuledSurf),
            map(tag(".GENERALISED_CONE."), |_| GeneralisedCone),
            map(tag(".QUADRIC_SURF."), |_| QuadricSurf),
            map(tag(".SURF_OF_LINEAR_EXTRUSION."), |_| SurfOfLinearExtrusion),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
#[derive(Debug)]
pub struct BSplineSurfaceWithKnots_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    pub u_multiplicities: Vec<i64>,
    pub v_multiplicities: Vec<i64>,
    pub u_knots: Vec<ParameterValue<'a>>,
    pub v_knots: Vec<ParameterValue<'a>>,
    pub knot_spec: KnotType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineSurfaceWithKnots<'a> = Id<BSplineSurfaceWithKnots_<'a>>;
impl<'a> FromEntity<'a> for BSplineSurfaceWithKnots_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BSplineSurfaceWithKnots(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BSplineSurfaceWithKnots_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("B_SPLINE_SURFACE_WITH_KNOTS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, u_degree) = param::<i64>(false, s)?;
        let (s, v_degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<Vec<CartesianPoint<'a>>>>(false, s)?;
        let (s, surface_form) = param::<BSplineSurfaceForm<'a>>(false, s)?;
        let (s, u_closed) = param::<Logical>(false, s)?;
        let (s, v_closed) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(false, s)?;
        let (s, u_multiplicities) = param::<Vec<i64>>(false, s)?;
        let (s, v_multiplicities) = param::<Vec<i64>>(false, s)?;
        let (s, u_knots) = param::<Vec<ParameterValue<'a>>>(false, s)?;
        let (s, v_knots) = param::<Vec<ParameterValue<'a>>>(false, s)?;
        let (s, knot_spec) = param::<KnotType<'a>>(true, s)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            u_multiplicities,
            v_multiplicities,
            u_knots,
            v_knots,
            knot_spec,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BackgroundColour_<'a> { // entity
    pub presentation: AreaOrView<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BackgroundColour<'a> = Id<BackgroundColour_<'a>>;
impl<'a> FromEntity<'a> for BackgroundColour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BackgroundColour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BackgroundColour_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BACKGROUND_COLOUR(")(s)?;
        let (s, presentation) = param::<AreaOrView<'a>>(true, s)?;
        Ok((s, Self {
            presentation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BarringHole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BarringHole<'a> = Id<BarringHole_<'a>>;
impl<'a> FromEntity<'a> for BarringHole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BarringHole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BarringHole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BARRING_HOLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Bead_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Bead<'a> = Id<Bead_<'a>>;
impl<'a> FromEntity<'a> for Bead_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Bead(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Bead_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BEAD(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BeadEnd_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BeadEnd<'a> = Id<BeadEnd_<'a>>;
impl<'a> FromEntity<'a> for BeadEnd_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BeadEnd(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BeadEnd_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BEAD_END(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BezierCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BezierCurve<'a> = Id<BezierCurve_<'a>>;
impl<'a> FromEntity<'a> for BezierCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BezierCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BezierCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BEZIER_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<CartesianPoint<'a>>>(false, s)?;
        let (s, curve_form) = param::<BSplineCurveForm<'a>>(false, s)?;
        let (s, closed_curve) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BezierSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BezierSurface<'a> = Id<BezierSurface_<'a>>;
impl<'a> FromEntity<'a> for BezierSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BezierSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BezierSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BEZIER_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, u_degree) = param::<i64>(false, s)?;
        let (s, v_degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<Vec<CartesianPoint<'a>>>>(false, s)?;
        let (s, surface_form) = param::<BSplineSurfaceForm<'a>>(false, s)?;
        let (s, u_closed) = param::<Logical>(false, s)?;
        let (s, v_closed) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BinaryBooleanExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryBooleanExpression<'a> = Id<BinaryBooleanExpression_<'a>>;
impl<'a> FromEntity<'a> for BinaryBooleanExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BinaryBooleanExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BinaryBooleanExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BINARY_BOOLEAN_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BinaryFunctionCall_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryFunctionCall<'a> = Id<BinaryFunctionCall_<'a>>;
impl<'a> FromEntity<'a> for BinaryFunctionCall_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BinaryFunctionCall(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BinaryFunctionCall_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BINARY_FUNCTION_CALL(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BinaryGenericExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryGenericExpression<'a> = Id<BinaryGenericExpression_<'a>>;
impl<'a> FromEntity<'a> for BinaryGenericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BinaryGenericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BinaryGenericExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BINARY_GENERIC_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BinaryNumericExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryNumericExpression<'a> = Id<BinaryNumericExpression_<'a>>;
impl<'a> FromEntity<'a> for BinaryNumericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BinaryNumericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BinaryNumericExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BINARY_NUMERIC_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Block_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub x: PositiveLengthMeasure<'a>,
    pub y: PositiveLengthMeasure<'a>,
    pub z: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Block<'a> = Id<Block_<'a>>;
impl<'a> FromEntity<'a> for Block_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Block(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Block_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BLOCK(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement3d<'a>>(false, s)?;
        let (s, x) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, y) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, z) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            x,
            y,
            z,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BooleanDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanDefinedFunction<'a> = Id<BooleanDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for BooleanDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BooleanDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BooleanDefinedFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOOLEAN_DEFINED_FUNCTION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BooleanExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanExpression<'a> = Id<BooleanExpression_<'a>>;
impl<'a> FromEntity<'a> for BooleanExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BooleanExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BooleanExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOOLEAN_EXPRESSION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BooleanLiteral_<'a> { // entity
    pub the_value: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanLiteral<'a> = Id<BooleanLiteral_<'a>>;
impl<'a> FromEntity<'a> for BooleanLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BooleanLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BooleanLiteral_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOOLEAN_LITERAL(")(s)?;
        let (s, the_value) = param::<bool>(true, s)?;
        Ok((s, Self {
            the_value,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BooleanOperand_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type BooleanOperand<'a> = Id<BooleanOperand_<'a>>;

#[derive(Debug)]
pub enum BooleanOperator<'a> { // enum
    Union,
    Intersection,
    Difference,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BooleanOperator<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BooleanOperator::*;
        alt((
            map(tag(".UNION."), |_| Union),
            map(tag(".INTERSECTION."), |_| Intersection),
            map(tag(".DIFFERENCE."), |_| Difference),
        ))(s)
    }
}
#[derive(Debug)]
pub struct BooleanResult_<'a> { // entity
    pub name: Label<'a>,
    pub operator: BooleanOperator<'a>,
    pub first_operand: BooleanOperand<'a>,
    pub second_operand: BooleanOperand<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanResult<'a> = Id<BooleanResult_<'a>>;
impl<'a> FromEntity<'a> for BooleanResult_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BooleanResult(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BooleanResult_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOOLEAN_RESULT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, operator) = param::<BooleanOperator<'a>>(false, s)?;
        let (s, first_operand) = param::<BooleanOperand<'a>>(false, s)?;
        let (s, second_operand) = param::<BooleanOperand<'a>>(true, s)?;
        Ok((s, Self {
            name,
            operator,
            first_operand,
            second_operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BooleanVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanVariable<'a> = Id<BooleanVariable_<'a>>;
impl<'a> FromEntity<'a> for BooleanVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BooleanVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BooleanVariable_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOOLEAN_VARIABLE(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Boss_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Boss<'a> = Id<Boss_<'a>>;
impl<'a> FromEntity<'a> for Boss_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Boss(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Boss_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOSS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BossTop_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BossTop<'a> = Id<BossTop_<'a>>;
impl<'a> FromEntity<'a> for BossTop_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BossTop(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BossTop_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOSS_TOP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BoundaryCurve_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundaryCurve<'a> = Id<BoundaryCurve_<'a>>;
impl<'a> FromEntity<'a> for BoundaryCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoundaryCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BoundaryCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOUNDARY_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, segments) = param::<Vec<CompositeCurveSegment<'a>>>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            segments,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BoundedCurve_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedCurve<'a> = Id<BoundedCurve_<'a>>;
impl<'a> FromEntity<'a> for BoundedCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoundedCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BoundedCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOUNDED_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct BoundedPcurve_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedPcurve<'a> = Id<BoundedPcurve_<'a>>;
impl<'a> FromEntity<'a> for BoundedPcurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoundedPcurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BoundedPcurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOUNDED_PCURVE(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        let (s, basis_surface) = param::<Surface<'a>>(false, s)?;
        let (s, reference_to_curve) = param::<DefinitionalRepresentation<'a>>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            basis_surface,
            reference_to_curve,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BoundedSurface_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedSurface<'a> = Id<BoundedSurface_<'a>>;
impl<'a> FromEntity<'a> for BoundedSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoundedSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BoundedSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOUNDED_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct BoundedSurfaceCurve_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: Vec<PcurveOrSurface<'a>>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedSurfaceCurve<'a> = Id<BoundedSurfaceCurve_<'a>>;
impl<'a> FromEntity<'a> for BoundedSurfaceCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoundedSurfaceCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BoundedSurfaceCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOUNDED_SURFACE_CURVE(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        let (s, curve_3d) = param::<Curve<'a>>(false, s)?;
        let (s, associated_geometry) = param::<Vec<PcurveOrSurface<'a>>>(false, s)?;
        let (s, master_representation) = param::<PreferredSurfaceCurveRepresentation<'a>>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            curve_3d,
            associated_geometry,
            master_representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum BoxCharacteristicSelect<'a> { // select
    BoxHeight(BoxHeight<'a>),
    BoxWidth(BoxWidth<'a>),
    BoxSlantAngle(BoxSlantAngle<'a>),
    BoxRotateAngle(BoxRotateAngle<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for BoxCharacteristicSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("BOX_HEIGHT("), <BoxHeight<'a>>::parse, char(')')), |r| BoxCharacteristicSelect::BoxHeight(r)),
            map(delimited(tag("BOX_WIDTH("), <BoxWidth<'a>>::parse, char(')')), |r| BoxCharacteristicSelect::BoxWidth(r)),
            map(delimited(tag("BOX_SLANT_ANGLE("), <BoxSlantAngle<'a>>::parse, char(')')), |r| BoxCharacteristicSelect::BoxSlantAngle(r)),
            map(delimited(tag("BOX_ROTATE_ANGLE("), <BoxRotateAngle<'a>>::parse, char(')')), |r| BoxCharacteristicSelect::BoxRotateAngle(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct BoxDomain_<'a> { // entity
    pub corner: CartesianPoint<'a>,
    pub xlength: PositiveLengthMeasure<'a>,
    pub ylength: PositiveLengthMeasure<'a>,
    pub zlength: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoxDomain<'a> = Id<BoxDomain_<'a>>;
impl<'a> FromEntity<'a> for BoxDomain_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoxDomain(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BoxDomain_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOX_DOMAIN(")(s)?;
        let (s, corner) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, xlength) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, ylength) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, zlength) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            corner,
            xlength,
            ylength,
            zlength,
            _marker: std::marker::PhantomData}))
    }
}

#[derive(Debug)]
pub struct BoxHeight<'a>(pub PositiveRatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxHeight<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveRatioMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct BoxRotateAngle<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxRotateAngle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct BoxSlantAngle<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxSlantAngle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct BoxWidth<'a>(pub PositiveRatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxWidth<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveRatioMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct BoxedHalfSpace_<'a> { // entity
    pub name: Label<'a>,
    pub base_surface: Surface<'a>,
    pub agreement_flag: bool,
    pub enclosure: BoxDomain<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoxedHalfSpace<'a> = Id<BoxedHalfSpace_<'a>>;
impl<'a> FromEntity<'a> for BoxedHalfSpace_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoxedHalfSpace(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BoxedHalfSpace_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BOXED_HALF_SPACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, base_surface) = param::<Surface<'a>>(false, s)?;
        let (s, agreement_flag) = param::<bool>(false, s)?;
        let (s, enclosure) = param::<BoxDomain<'a>>(true, s)?;
        Ok((s, Self {
            name,
            base_surface,
            agreement_flag,
            enclosure,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct BrepWithVoids_<'a> { // entity
    pub name: Label<'a>,
    pub outer: ClosedShell<'a>,
    pub voids: Vec<OrientedClosedShell<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BrepWithVoids<'a> = Id<BrepWithVoids_<'a>>;
impl<'a> FromEntity<'a> for BrepWithVoids_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BrepWithVoids(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for BrepWithVoids_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("BREP_WITH_VOIDS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, outer) = param::<ClosedShell<'a>>(false, s)?;
        let (s, voids) = param::<Vec<OrientedClosedShell<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            outer,
            voids,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CalendarDate_<'a> { // entity
    pub year_component: YearNumber<'a>,
    pub day_component: DayInMonthNumber<'a>,
    pub month_component: MonthInYearNumber<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CalendarDate<'a> = Id<CalendarDate_<'a>>;
impl<'a> FromEntity<'a> for CalendarDate_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CalendarDate(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CalendarDate_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CALENDAR_DATE(")(s)?;
        let (s, year_component) = param::<YearNumber<'a>>(false, s)?;
        let (s, day_component) = param::<DayInMonthNumber<'a>>(false, s)?;
        let (s, month_component) = param::<MonthInYearNumber<'a>>(true, s)?;
        Ok((s, Self {
            year_component,
            day_component,
            month_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CameraImage_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraImage<'a> = Id<CameraImage_<'a>>;
impl<'a> FromEntity<'a> for CameraImage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraImage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CameraImage_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CAMERA_IMAGE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, mapping_source) = param::<RepresentationMap<'a>>(false, s)?;
        let (s, mapping_target) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CameraImage2dWithScale_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraImage2dWithScale<'a> = Id<CameraImage2dWithScale_<'a>>;
impl<'a> FromEntity<'a> for CameraImage2dWithScale_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraImage2dWithScale(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CameraImage2dWithScale_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CAMERA_IMAGE_2D_WITH_SCALE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, mapping_source) = param::<RepresentationMap<'a>>(false, s)?;
        let (s, mapping_target) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CameraImage3dWithScale_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraImage3dWithScale<'a> = Id<CameraImage3dWithScale_<'a>>;
impl<'a> FromEntity<'a> for CameraImage3dWithScale_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraImage3dWithScale(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CameraImage3dWithScale_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CAMERA_IMAGE_3D_WITH_SCALE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, mapping_source) = param::<RepresentationMap<'a>>(false, s)?;
        let (s, mapping_target) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CameraModel_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModel<'a> = Id<CameraModel_<'a>>;
impl<'a> FromEntity<'a> for CameraModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CameraModel_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CAMERA_MODEL(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CameraModelD2_<'a> { // entity
    pub name: Label<'a>,
    pub view_window: PlanarBox<'a>,
    pub view_window_clipping: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModelD2<'a> = Id<CameraModelD2_<'a>>;
impl<'a> FromEntity<'a> for CameraModelD2_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraModelD2(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CameraModelD2_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CAMERA_MODEL_D2(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, view_window) = param::<PlanarBox<'a>>(false, s)?;
        let (s, view_window_clipping) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            view_window,
            view_window_clipping,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CameraModelD3_<'a> { // entity
    pub name: Label<'a>,
    pub view_reference_system: Axis2Placement3d<'a>,
    pub perspective_of_volume: ViewVolume<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModelD3<'a> = Id<CameraModelD3_<'a>>;
impl<'a> FromEntity<'a> for CameraModelD3_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraModelD3(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CameraModelD3_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CAMERA_MODEL_D3(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, view_reference_system) = param::<Axis2Placement3d<'a>>(false, s)?;
        let (s, perspective_of_volume) = param::<ViewVolume<'a>>(true, s)?;
        Ok((s, Self {
            name,
            view_reference_system,
            perspective_of_volume,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CameraModelD3WithHlhsr_<'a> { // entity
    pub name: Label<'a>,
    pub view_reference_system: Axis2Placement3d<'a>,
    pub perspective_of_volume: ViewVolume<'a>,
    pub hidden_line_surface_removal: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModelD3WithHlhsr<'a> = Id<CameraModelD3WithHlhsr_<'a>>;
impl<'a> FromEntity<'a> for CameraModelD3WithHlhsr_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraModelD3WithHlhsr(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CameraModelD3WithHlhsr_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CAMERA_MODEL_D3_WITH_HLHSR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, view_reference_system) = param::<Axis2Placement3d<'a>>(false, s)?;
        let (s, perspective_of_volume) = param::<ViewVolume<'a>>(false, s)?;
        let (s, hidden_line_surface_removal) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            view_reference_system,
            perspective_of_volume,
            hidden_line_surface_removal,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CameraUsage_<'a> { // entity
    pub mapping_origin: RepresentationItem<'a>,
    pub mapped_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraUsage<'a> = Id<CameraUsage_<'a>>;
impl<'a> FromEntity<'a> for CameraUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CameraUsage_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CAMERA_USAGE(")(s)?;
        let (s, mapping_origin) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, mapped_representation) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            mapping_origin,
            mapped_representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CartesianPoint_<'a> { // entity
    pub name: Label<'a>,
    pub coordinates: Vec<LengthMeasure<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianPoint<'a> = Id<CartesianPoint_<'a>>;
impl<'a> FromEntity<'a> for CartesianPoint_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CartesianPoint(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CartesianPoint_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CARTESIAN_POINT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, coordinates) = param::<Vec<LengthMeasure<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            coordinates,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct CartesianTransformationOperator_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub axis1: Option<Direction<'a>>,
    pub axis2: Option<Direction<'a>>,
    pub local_origin: CartesianPoint<'a>,
    pub scale: Option<f64>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianTransformationOperator<'a> = Id<CartesianTransformationOperator_<'a>>;
impl<'a> FromEntity<'a> for CartesianTransformationOperator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CartesianTransformationOperator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CartesianTransformationOperator_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CARTESIAN_TRANSFORMATION_OPERATOR(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, functionally_defined_transformation__name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, axis1) = param::<Option<Direction<'a>>>(false, s)?;
        let (s, axis2) = param::<Option<Direction<'a>>>(false, s)?;
        let (s, local_origin) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, scale) = param::<Option<f64>>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            functionally_defined_transformation__name,
            description,
            axis1,
            axis2,
            local_origin,
            scale,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct CartesianTransformationOperator2d_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub axis1: Option<Direction<'a>>,
    pub axis2: Option<Direction<'a>>,
    pub local_origin: CartesianPoint<'a>,
    pub scale: Option<f64>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianTransformationOperator2d<'a> = Id<CartesianTransformationOperator2d_<'a>>;
impl<'a> FromEntity<'a> for CartesianTransformationOperator2d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CartesianTransformationOperator2d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CartesianTransformationOperator2d_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CARTESIAN_TRANSFORMATION_OPERATOR_2D(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, functionally_defined_transformation__name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, axis1) = param::<Option<Direction<'a>>>(false, s)?;
        let (s, axis2) = param::<Option<Direction<'a>>>(false, s)?;
        let (s, local_origin) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, scale) = param::<Option<f64>>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            functionally_defined_transformation__name,
            description,
            axis1,
            axis2,
            local_origin,
            scale,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct CartesianTransformationOperator3d_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub axis1: Option<Direction<'a>>,
    pub axis2: Option<Direction<'a>>,
    pub local_origin: CartesianPoint<'a>,
    pub scale: Option<f64>,
    pub axis3: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianTransformationOperator3d<'a> = Id<CartesianTransformationOperator3d_<'a>>;
impl<'a> FromEntity<'a> for CartesianTransformationOperator3d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CartesianTransformationOperator3d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CartesianTransformationOperator3d_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CARTESIAN_TRANSFORMATION_OPERATOR_3D(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, functionally_defined_transformation__name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, axis1) = param::<Option<Direction<'a>>>(false, s)?;
        let (s, axis2) = param::<Option<Direction<'a>>>(false, s)?;
        let (s, local_origin) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, scale) = param::<Option<f64>>(false, s)?;
        let (s, axis3) = param::<Option<Direction<'a>>>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            functionally_defined_transformation__name,
            description,
            axis1,
            axis2,
            local_origin,
            scale,
            axis3,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CategoryUsageItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CategoryUsageItem<'a> = Id<CategoryUsageItem_<'a>>;

#[derive(Debug)]
pub struct CelsiusTemperatureMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CelsiusTemperatureMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct CelsiusTemperatureMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CelsiusTemperatureMeasureWithUnit<'a> = Id<CelsiusTemperatureMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for CelsiusTemperatureMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CelsiusTemperatureMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CelsiusTemperatureMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum CentralOrParallel<'a> { // enum
    Central,
    Parallel,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for CentralOrParallel<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use CentralOrParallel::*;
        alt((
            map(tag(".CENTRAL."), |_| Central),
            map(tag(".PARALLEL."), |_| Parallel),
        ))(s)
    }
}
#[derive(Debug)]
pub struct CentreOfSymmetry_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CentreOfSymmetry<'a> = Id<CentreOfSymmetry_<'a>>;
impl<'a> FromEntity<'a> for CentreOfSymmetry_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CentreOfSymmetry(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CentreOfSymmetry_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CENTRE_OF_SYMMETRY(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Certification_<'a> { // entity
    pub name: Label<'a>,
    pub purpose: Text<'a>,
    pub kind: CertificationType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Certification<'a> = Id<Certification_<'a>>;
impl<'a> FromEntity<'a> for Certification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Certification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Certification_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CERTIFICATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, purpose) = param::<Text<'a>>(false, s)?;
        let (s, kind) = param::<CertificationType<'a>>(true, s)?;
        Ok((s, Self {
            name,
            purpose,
            kind,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CertificationAssignment_<'a> { // entity
    pub assigned_certification: Certification<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CertificationAssignment<'a> = Id<CertificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for CertificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CertificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CertificationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CERTIFICATION_ASSIGNMENT(")(s)?;
        let (s, assigned_certification) = param::<Certification<'a>>(true, s)?;
        Ok((s, Self {
            assigned_certification,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CertificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CertificationItem<'a> = Id<CertificationItem_<'a>>;

#[derive(Debug)]
pub struct CertificationType_<'a> { // entity
    pub description: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CertificationType<'a> = Id<CertificationType_<'a>>;
impl<'a> FromEntity<'a> for CertificationType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CertificationType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CertificationType_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CERTIFICATION_TYPE(")(s)?;
        let (s, description) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Chamfer_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Chamfer<'a> = Id<Chamfer_<'a>>;
impl<'a> FromEntity<'a> for Chamfer_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Chamfer(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Chamfer_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CHAMFER(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ChamferOffset_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ChamferOffset<'a> = Id<ChamferOffset_<'a>>;
impl<'a> FromEntity<'a> for ChamferOffset_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ChamferOffset(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ChamferOffset_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CHAMFER_OFFSET(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CharacterGlyphSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    pub character_box: PlanarExtent<'a>,
    pub baseline_ratio: RatioMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CharacterGlyphSymbol<'a> = Id<CharacterGlyphSymbol_<'a>>;
impl<'a> FromEntity<'a> for CharacterGlyphSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CharacterGlyphSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CharacterGlyphSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CHARACTER_GLYPH_SYMBOL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(false, s)?;
        let (s, character_box) = param::<PlanarExtent<'a>>(false, s)?;
        let (s, baseline_ratio) = param::<RatioMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            character_box,
            baseline_ratio,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum CharacterSpacingSelect<'a> { // select
    LengthMeasure(LengthMeasure<'a>),
    RatioMeasure(RatioMeasure<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CharacterSpacingSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LENGTH_MEASURE("), <LengthMeasure<'a>>::parse, char(')')), |r| CharacterSpacingSelect::LengthMeasure(r)),
            map(delimited(tag("RATIO_MEASURE("), <RatioMeasure<'a>>::parse, char(')')), |r| CharacterSpacingSelect::RatioMeasure(r)),
            map(<MeasureWithUnit<'a>>::parse, |r| CharacterSpacingSelect::MeasureWithUnit(r)),
            map(delimited(tag("DESCRIPTIVE_MEASURE("), <DescriptiveMeasure<'a>>::parse, char(')')), |r| CharacterSpacingSelect::DescriptiveMeasure(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct CharacterStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterStyleSelect<'a> = Id<CharacterStyleSelect_<'a>>;

#[derive(Debug)]
pub struct CharacterizedActionDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedActionDefinition<'a> = Id<CharacterizedActionDefinition_<'a>>;

#[allow(non_snake_case)]
#[derive(Debug)]
pub struct CharacterizedClass_<'a> { // entity
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    pub group__name: Label<'a>,
    pub group__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CharacterizedClass<'a> = Id<CharacterizedClass_<'a>>;
impl<'a> FromEntity<'a> for CharacterizedClass_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CharacterizedClass(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CharacterizedClass_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CHARACTERIZED_CLASS(")(s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param::<Option<Text<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, group__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, group__description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            characterized_object__name,
            characterized_object__description,
            group__name,
            group__description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CharacterizedDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedDefinition<'a> = Id<CharacterizedDefinition_<'a>>;

#[derive(Debug)]
pub struct CharacterizedMaterialProperty_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedMaterialProperty<'a> = Id<CharacterizedMaterialProperty_<'a>>;

#[derive(Debug)]
pub struct CharacterizedObject_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CharacterizedObject<'a> = Id<CharacterizedObject_<'a>>;
impl<'a> FromEntity<'a> for CharacterizedObject_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CharacterizedObject(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CharacterizedObject_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CHARACTERIZED_OBJECT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CharacterizedProductDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedProductDefinition<'a> = Id<CharacterizedProductDefinition_<'a>>;

#[derive(Debug)]
pub struct CharacterizedResourceDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedResourceDefinition<'a> = Id<CharacterizedResourceDefinition_<'a>>;

#[derive(Debug)]
pub struct Circle_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Circle<'a> = Id<Circle_<'a>>;
impl<'a> FromEntity<'a> for Circle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Circle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Circle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CIRCLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, radius) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            radius,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CircularClosedProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CircularClosedProfile<'a> = Id<CircularClosedProfile_<'a>>;
impl<'a> FromEntity<'a> for CircularClosedProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CircularClosedProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CircularClosedProfile_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CIRCULAR_CLOSED_PROFILE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CircularPattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CircularPattern<'a> = Id<CircularPattern_<'a>>;
impl<'a> FromEntity<'a> for CircularPattern_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CircularPattern(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CircularPattern_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CIRCULAR_PATTERN(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CircularRunoutTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CircularRunoutTolerance<'a> = Id<CircularRunoutTolerance_<'a>>;
impl<'a> FromEntity<'a> for CircularRunoutTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CircularRunoutTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CircularRunoutTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CIRCULAR_RUNOUT_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, datum_system) = param::<Vec<DatumReference<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Class_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Class<'a> = Id<Class_<'a>>;
impl<'a> FromEntity<'a> for Class_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Class(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Class_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CLASS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ClassSystem_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassSystem<'a> = Id<ClassSystem_<'a>>;
impl<'a> FromEntity<'a> for ClassSystem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClassSystem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ClassSystem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CLASS_SYSTEM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ClassUsageEffectivityContextAssignment_<'a> { // entity
    pub assigned_effectivity_assignment: EffectivityAssignment<'a>,
    pub role: EffectivityContextRole<'a>,
    pub items: Vec<ClassUsageEffectivityContextItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassUsageEffectivityContextAssignment<'a> = Id<ClassUsageEffectivityContextAssignment_<'a>>;
impl<'a> FromEntity<'a> for ClassUsageEffectivityContextAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClassUsageEffectivityContextAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ClassUsageEffectivityContextAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT(")(s)?;
        let (s, assigned_effectivity_assignment) = param::<EffectivityAssignment<'a>>(false, s)?;
        let (s, role) = param::<EffectivityContextRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<ClassUsageEffectivityContextItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_effectivity_assignment,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ClassUsageEffectivityContextItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ClassUsageEffectivityContextItem<'a> = Id<ClassUsageEffectivityContextItem_<'a>>;

#[derive(Debug)]
pub struct ClassificationAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub role: ClassificationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassificationAssignment<'a> = Id<ClassificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for ClassificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClassificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ClassificationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CLASSIFICATION_ASSIGNMENT(")(s)?;
        let (s, assigned_class) = param::<Group<'a>>(false, s)?;
        let (s, role) = param::<ClassificationRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_class,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ClassificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ClassificationItem<'a> = Id<ClassificationItem_<'a>>;

#[derive(Debug)]
pub struct ClassificationRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassificationRole<'a> = Id<ClassificationRole_<'a>>;
impl<'a> FromEntity<'a> for ClassificationRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClassificationRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ClassificationRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CLASSIFICATION_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ClosedPathProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClosedPathProfile<'a> = Id<ClosedPathProfile_<'a>>;
impl<'a> FromEntity<'a> for ClosedPathProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClosedPathProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ClosedPathProfile_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CLOSED_PATH_PROFILE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ClosedShell_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClosedShell<'a> = Id<ClosedShell_<'a>>;
impl<'a> FromEntity<'a> for ClosedShell_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClosedShell(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ClosedShell_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CLOSED_SHELL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, cfs_faces) = param::<Vec<Face<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            cfs_faces,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CoaxialityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CoaxialityTolerance<'a> = Id<CoaxialityTolerance_<'a>>;
impl<'a> FromEntity<'a> for CoaxialityTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CoaxialityTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CoaxialityTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COAXIALITY_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, datum_system) = param::<Vec<DatumReference<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Colour_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Colour<'a> = Id<Colour_<'a>>;
impl<'a> FromEntity<'a> for Colour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Colour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Colour_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COLOUR(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ColourRgb_<'a> { // entity
    pub name: Label<'a>,
    pub red: f64,
    pub green: f64,
    pub blue: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ColourRgb<'a> = Id<ColourRgb_<'a>>;
impl<'a> FromEntity<'a> for ColourRgb_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ColourRgb(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ColourRgb_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COLOUR_RGB(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, red) = param::<f64>(false, s)?;
        let (s, green) = param::<f64>(false, s)?;
        let (s, blue) = param::<f64>(true, s)?;
        Ok((s, Self {
            name,
            red,
            green,
            blue,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ColourSpecification_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ColourSpecification<'a> = Id<ColourSpecification_<'a>>;
impl<'a> FromEntity<'a> for ColourSpecification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ColourSpecification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ColourSpecification_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COLOUR_SPECIFICATION(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct CommonDatum_<'a> { // entity
    pub shape_aspect__name: Label<'a>,
    pub shape_aspect__description: Option<Text<'a>>,
    pub shape_aspect__of_shape: ProductDefinitionShape<'a>,
    pub shape_aspect__product_definitional: Logical,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CommonDatum<'a> = Id<CommonDatum_<'a>>;
impl<'a> FromEntity<'a> for CommonDatum_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CommonDatum(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CommonDatum_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMMON_DATUM(")(s)?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__description) = param::<Option<Text<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__product_definitional) = param::<Logical>(false, s)?;
        let (s, identification) = param::<Identifier<'a>>(true, s)?;
        Ok((s, Self {
            shape_aspect__name,
            shape_aspect__description,
            shape_aspect__of_shape,
            shape_aspect__product_definitional,
            identification,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ComparisonEqual_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonEqual<'a> = Id<ComparisonEqual_<'a>>;
impl<'a> FromEntity<'a> for ComparisonEqual_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonEqual(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ComparisonEqual_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPARISON_EQUAL(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ComparisonExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonExpression<'a> = Id<ComparisonExpression_<'a>>;
impl<'a> FromEntity<'a> for ComparisonExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ComparisonExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPARISON_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ComparisonGreater_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonGreater<'a> = Id<ComparisonGreater_<'a>>;
impl<'a> FromEntity<'a> for ComparisonGreater_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonGreater(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ComparisonGreater_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPARISON_GREATER(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ComparisonGreaterEqual_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonGreaterEqual<'a> = Id<ComparisonGreaterEqual_<'a>>;
impl<'a> FromEntity<'a> for ComparisonGreaterEqual_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonGreaterEqual(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ComparisonGreaterEqual_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPARISON_GREATER_EQUAL(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ComparisonLess_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonLess<'a> = Id<ComparisonLess_<'a>>;
impl<'a> FromEntity<'a> for ComparisonLess_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonLess(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ComparisonLess_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPARISON_LESS(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ComparisonLessEqual_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonLessEqual<'a> = Id<ComparisonLessEqual_<'a>>;
impl<'a> FromEntity<'a> for ComparisonLessEqual_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonLessEqual(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ComparisonLessEqual_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPARISON_LESS_EQUAL(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ComparisonNotEqual_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonNotEqual<'a> = Id<ComparisonNotEqual_<'a>>;
impl<'a> FromEntity<'a> for ComparisonNotEqual_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonNotEqual(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ComparisonNotEqual_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPARISON_NOT_EQUAL(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CompositeCurve_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeCurve<'a> = Id<CompositeCurve_<'a>>;
impl<'a> FromEntity<'a> for CompositeCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompositeCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOSITE_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, segments) = param::<Vec<CompositeCurveSegment<'a>>>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            segments,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CompositeCurveOnSurface_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeCurveOnSurface<'a> = Id<CompositeCurveOnSurface_<'a>>;
impl<'a> FromEntity<'a> for CompositeCurveOnSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeCurveOnSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompositeCurveOnSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOSITE_CURVE_ON_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, segments) = param::<Vec<CompositeCurveSegment<'a>>>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            segments,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CompositeCurveSegment_<'a> { // entity
    pub transition: TransitionCode<'a>,
    pub same_sense: bool,
    pub parent_curve: Curve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeCurveSegment<'a> = Id<CompositeCurveSegment_<'a>>;
impl<'a> FromEntity<'a> for CompositeCurveSegment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeCurveSegment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompositeCurveSegment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOSITE_CURVE_SEGMENT(")(s)?;
        let (s, transition) = param::<TransitionCode<'a>>(false, s)?;
        let (s, same_sense) = param::<bool>(false, s)?;
        let (s, parent_curve) = param::<Curve<'a>>(true, s)?;
        Ok((s, Self {
            transition,
            same_sense,
            parent_curve,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CompositeHole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeHole<'a> = Id<CompositeHole_<'a>>;
impl<'a> FromEntity<'a> for CompositeHole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeHole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompositeHole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOSITE_HOLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CompositeShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeShapeAspect<'a> = Id<CompositeShapeAspect_<'a>>;
impl<'a> FromEntity<'a> for CompositeShapeAspect_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeShapeAspect(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompositeShapeAspect_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOSITE_SHAPE_ASPECT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CompositeText_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeText<'a> = Id<CompositeText_<'a>>;
impl<'a> FromEntity<'a> for CompositeText_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeText(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompositeText_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOSITE_TEXT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, collected_text) = param::<Vec<TextOrCharacter<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            collected_text,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CompositeTextWithAssociatedCurves_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    pub associated_curves: Vec<Curve<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeTextWithAssociatedCurves<'a> = Id<CompositeTextWithAssociatedCurves_<'a>>;
impl<'a> FromEntity<'a> for CompositeTextWithAssociatedCurves_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeTextWithAssociatedCurves(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompositeTextWithAssociatedCurves_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, collected_text) = param::<Vec<TextOrCharacter<'a>>>(false, s)?;
        let (s, associated_curves) = param::<Vec<Curve<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            collected_text,
            associated_curves,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CompositeTextWithBlankingBox_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    pub blanking: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeTextWithBlankingBox<'a> = Id<CompositeTextWithBlankingBox_<'a>>;
impl<'a> FromEntity<'a> for CompositeTextWithBlankingBox_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeTextWithBlankingBox(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompositeTextWithBlankingBox_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOSITE_TEXT_WITH_BLANKING_BOX(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, collected_text) = param::<Vec<TextOrCharacter<'a>>>(false, s)?;
        let (s, blanking) = param::<PlanarBox<'a>>(true, s)?;
        Ok((s, Self {
            name,
            collected_text,
            blanking,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CompositeTextWithExtent_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    pub extent: PlanarExtent<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeTextWithExtent<'a> = Id<CompositeTextWithExtent_<'a>>;
impl<'a> FromEntity<'a> for CompositeTextWithExtent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeTextWithExtent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompositeTextWithExtent_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOSITE_TEXT_WITH_EXTENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, collected_text) = param::<Vec<TextOrCharacter<'a>>>(false, s)?;
        let (s, extent) = param::<PlanarExtent<'a>>(true, s)?;
        Ok((s, Self {
            name,
            collected_text,
            extent,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CompoundFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompoundFeature<'a> = Id<CompoundFeature_<'a>>;
impl<'a> FromEntity<'a> for CompoundFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompoundFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompoundFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOUND_FEATURE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum CompoundItemDefinition<'a> { // select
    ListRepresentationItem(Vec<RepresentationItem<'a>>),
    SetRepresentationItem(Vec<RepresentationItem<'a>>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CompoundItemDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LIST_REPRESENTATION_ITEM("), <Vec<RepresentationItem<'a>>>::parse, char(')')), |r| CompoundItemDefinition::ListRepresentationItem(r)),
            map(delimited(tag("SET_REPRESENTATION_ITEM("), <Vec<RepresentationItem<'a>>>::parse, char(')')), |r| CompoundItemDefinition::SetRepresentationItem(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct CompoundRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub item_element: CompoundItemDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompoundRepresentationItem<'a> = Id<CompoundRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for CompoundRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompoundRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompoundRepresentationItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOUND_REPRESENTATION_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, item_element) = param::<CompoundItemDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            item_element,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CompoundShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompoundShapeRepresentation<'a> = Id<CompoundShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for CompoundShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompoundShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CompoundShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COMPOUND_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConcatExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConcatExpression<'a> = Id<ConcatExpression_<'a>>;
impl<'a> FromEntity<'a> for ConcatExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConcatExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConcatExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONCAT_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConcentricityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConcentricityTolerance<'a> = Id<ConcentricityTolerance_<'a>>;
impl<'a> FromEntity<'a> for ConcentricityTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConcentricityTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConcentricityTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONCENTRICITY_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, datum_system) = param::<Vec<DatumReference<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConceptFeatureOperator_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConceptFeatureOperator<'a> = Id<ConceptFeatureOperator_<'a>>;
impl<'a> FromEntity<'a> for ConceptFeatureOperator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConceptFeatureOperator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConceptFeatureOperator_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONCEPT_FEATURE_OPERATOR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConceptFeatureRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_concept_feature: ProductConceptFeature<'a>,
    pub related_product_concept_feature: ProductConceptFeature<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConceptFeatureRelationship<'a> = Id<ConceptFeatureRelationship_<'a>>;
impl<'a> FromEntity<'a> for ConceptFeatureRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConceptFeatureRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConceptFeatureRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONCEPT_FEATURE_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_concept_feature) = param::<ProductConceptFeature<'a>>(false, s)?;
        let (s, related_product_concept_feature) = param::<ProductConceptFeature<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_product_concept_feature,
            related_product_concept_feature,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConceptFeatureRelationshipWithCondition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_concept_feature: ProductConceptFeature<'a>,
    pub related_product_concept_feature: ProductConceptFeature<'a>,
    pub conditional_operator: ConceptFeatureOperator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConceptFeatureRelationshipWithCondition<'a> = Id<ConceptFeatureRelationshipWithCondition_<'a>>;
impl<'a> FromEntity<'a> for ConceptFeatureRelationshipWithCondition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConceptFeatureRelationshipWithCondition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConceptFeatureRelationshipWithCondition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_concept_feature) = param::<ProductConceptFeature<'a>>(false, s)?;
        let (s, related_product_concept_feature) = param::<ProductConceptFeature<'a>>(false, s)?;
        let (s, conditional_operator) = param::<ConceptFeatureOperator<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_product_concept_feature,
            related_product_concept_feature,
            conditional_operator,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConditionalConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub condition: ConceptFeatureRelationshipWithCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConditionalConceptFeature<'a> = Id<ConditionalConceptFeature_<'a>>;
impl<'a> FromEntity<'a> for ConditionalConceptFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConditionalConceptFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConditionalConceptFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONDITIONAL_CONCEPT_FEATURE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, condition) = param::<ConceptFeatureRelationshipWithCondition<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            condition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConfigurableItem_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_concept: ProductConcept<'a>,
    pub purpose: Option<Label<'a>>,
    pub item_concept_feature: Vec<ProductConceptFeatureAssociation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurableItem<'a> = Id<ConfigurableItem_<'a>>;
impl<'a> FromEntity<'a> for ConfigurableItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurableItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConfigurableItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONFIGURABLE_ITEM(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, item_concept) = param::<ProductConcept<'a>>(false, s)?;
        let (s, purpose) = param::<Option<Label<'a>>>(false, s)?;
        let (s, item_concept_feature) = param::<Vec<ProductConceptFeatureAssociation<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            item_concept,
            purpose,
            item_concept_feature,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConfigurationDefinition_<'a> { // entity
    pub pair_values: Vec<PairValue<'a>>,
    pub t_parameter: MotionParameterMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationDefinition<'a> = Id<ConfigurationDefinition_<'a>>;
impl<'a> FromEntity<'a> for ConfigurationDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurationDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConfigurationDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONFIGURATION_DEFINITION(")(s)?;
        let (s, pair_values) = param::<Vec<PairValue<'a>>>(false, s)?;
        let (s, t_parameter) = param::<MotionParameterMeasure<'a>>(true, s)?;
        Ok((s, Self {
            pair_values,
            t_parameter,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConfigurationDesign_<'a> { // entity
    pub configuration: ConfigurationItem<'a>,
    pub design: ConfigurationDesignItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationDesign<'a> = Id<ConfigurationDesign_<'a>>;
impl<'a> FromEntity<'a> for ConfigurationDesign_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurationDesign(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConfigurationDesign_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONFIGURATION_DESIGN(")(s)?;
        let (s, configuration) = param::<ConfigurationItem<'a>>(false, s)?;
        let (s, design) = param::<ConfigurationDesignItem<'a>>(true, s)?;
        Ok((s, Self {
            configuration,
            design,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConfigurationDesignItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ConfigurationDesignItem<'a> = Id<ConfigurationDesignItem_<'a>>;

#[derive(Debug)]
pub struct ConfigurationEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub usage: ProductDefinitionRelationship<'a>,
    pub configuration: ConfigurationDesign<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationEffectivity<'a> = Id<ConfigurationEffectivity_<'a>>;
impl<'a> FromEntity<'a> for ConfigurationEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurationEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConfigurationEffectivity_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONFIGURATION_EFFECTIVITY(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, usage) = param::<ProductDefinitionRelationship<'a>>(false, s)?;
        let (s, configuration) = param::<ConfigurationDesign<'a>>(true, s)?;
        Ok((s, Self {
            id,
            usage,
            configuration,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConfigurationInterpolation_<'a> { // entity
    pub previous_configuration_definition: ConfigurationDefinition<'a>,
    pub next_configuration_definition: ConfigurationDefinition<'a>,
    pub interpolation: InterpolationType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationInterpolation<'a> = Id<ConfigurationInterpolation_<'a>>;
impl<'a> FromEntity<'a> for ConfigurationInterpolation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurationInterpolation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConfigurationInterpolation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONFIGURATION_INTERPOLATION(")(s)?;
        let (s, previous_configuration_definition) = param::<ConfigurationDefinition<'a>>(false, s)?;
        let (s, next_configuration_definition) = param::<ConfigurationDefinition<'a>>(false, s)?;
        let (s, interpolation) = param::<InterpolationType<'a>>(true, s)?;
        Ok((s, Self {
            previous_configuration_definition,
            next_configuration_definition,
            interpolation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConfigurationItem_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_concept: ProductConcept<'a>,
    pub purpose: Option<Label<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationItem<'a> = Id<ConfigurationItem_<'a>>;
impl<'a> FromEntity<'a> for ConfigurationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConfigurationItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONFIGURATION_ITEM(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, item_concept) = param::<ProductConcept<'a>>(false, s)?;
        let (s, purpose) = param::<Option<Label<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            item_concept,
            purpose,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConfiguredEffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    pub items: Vec<ConfiguredEffectivityItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfiguredEffectivityAssignment<'a> = Id<ConfiguredEffectivityAssignment_<'a>>;
impl<'a> FromEntity<'a> for ConfiguredEffectivityAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfiguredEffectivityAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConfiguredEffectivityAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONFIGURED_EFFECTIVITY_ASSIGNMENT(")(s)?;
        let (s, assigned_effectivity) = param::<Effectivity<'a>>(false, s)?;
        let (s, items) = param::<Vec<ConfiguredEffectivityItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_effectivity,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConfiguredEffectivityContextAssignment_<'a> { // entity
    pub assigned_effectivity_assignment: EffectivityAssignment<'a>,
    pub role: EffectivityContextRole<'a>,
    pub items: Vec<ConfiguredEffectivityContextItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfiguredEffectivityContextAssignment<'a> = Id<ConfiguredEffectivityContextAssignment_<'a>>;
impl<'a> FromEntity<'a> for ConfiguredEffectivityContextAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfiguredEffectivityContextAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConfiguredEffectivityContextAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT(")(s)?;
        let (s, assigned_effectivity_assignment) = param::<EffectivityAssignment<'a>>(false, s)?;
        let (s, role) = param::<EffectivityContextRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<ConfiguredEffectivityContextItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_effectivity_assignment,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConfiguredEffectivityContextItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ConfiguredEffectivityContextItem<'a> = Id<ConfiguredEffectivityContextItem_<'a>>;

#[derive(Debug)]
pub struct ConfiguredEffectivityItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ConfiguredEffectivityItem<'a> = Id<ConfiguredEffectivityItem_<'a>>;

#[derive(Debug)]
pub struct Conic_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Conic<'a> = Id<Conic_<'a>>;
impl<'a> FromEntity<'a> for Conic_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Conic(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Conic_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONIC(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConicalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub radius: LengthMeasure<'a>,
    pub semi_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConicalSurface<'a> = Id<ConicalSurface_<'a>>;
impl<'a> FromEntity<'a> for ConicalSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConicalSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConicalSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONICAL_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement3d<'a>>(false, s)?;
        let (s, radius) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, semi_angle) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            radius,
            semi_angle,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConnectedEdgeSet_<'a> { // entity
    pub name: Label<'a>,
    pub ces_edges: Vec<Edge<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConnectedEdgeSet<'a> = Id<ConnectedEdgeSet_<'a>>;
impl<'a> FromEntity<'a> for ConnectedEdgeSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConnectedEdgeSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConnectedEdgeSet_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONNECTED_EDGE_SET(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, ces_edges) = param::<Vec<Edge<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            ces_edges,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConnectedFaceSet_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConnectedFaceSet<'a> = Id<ConnectedFaceSet_<'a>>;
impl<'a> FromEntity<'a> for ConnectedFaceSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConnectedFaceSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConnectedFaceSet_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONNECTED_FACE_SET(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, cfs_faces) = param::<Vec<Face<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            cfs_faces,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConnectedFaceSubSet_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    pub parent_face_set: ConnectedFaceSet<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConnectedFaceSubSet<'a> = Id<ConnectedFaceSubSet_<'a>>;
impl<'a> FromEntity<'a> for ConnectedFaceSubSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConnectedFaceSubSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConnectedFaceSubSet_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONNECTED_FACE_SUB_SET(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, cfs_faces) = param::<Vec<Face<'a>>>(false, s)?;
        let (s, parent_face_set) = param::<ConnectedFaceSet<'a>>(true, s)?;
        Ok((s, Self {
            name,
            cfs_faces,
            parent_face_set,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConstructiveGeometryRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConstructiveGeometryRepresentation<'a> = Id<ConstructiveGeometryRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ConstructiveGeometryRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConstructiveGeometryRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConstructiveGeometryRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONSTRUCTIVE_GEOMETRY_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConstructiveGeometryRepresentationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConstructiveGeometryRepresentationRelationship<'a> = Id<ConstructiveGeometryRepresentationRelationship_<'a>>;
impl<'a> FromEntity<'a> for ConstructiveGeometryRepresentationRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConstructiveGeometryRepresentationRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConstructiveGeometryRepresentationRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONSTRUCTIVE_GEOMETRY_REPRESENTATION_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, rep_1) = param::<Representation<'a>>(false, s)?;
        let (s, rep_2) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ContactRatioRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContactRatioRepresentation<'a> = Id<ContactRatioRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ContactRatioRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContactRatioRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ContactRatioRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONTACT_RATIO_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ContextDependentInvisibility_<'a> { // entity
    pub invisible_items: Vec<InvisibleItem<'a>>,
    pub presentation_context: InvisibilityContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentInvisibility<'a> = Id<ContextDependentInvisibility_<'a>>;
impl<'a> FromEntity<'a> for ContextDependentInvisibility_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContextDependentInvisibility(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ContextDependentInvisibility_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONTEXT_DEPENDENT_INVISIBILITY(")(s)?;
        let (s, invisible_items) = param::<Vec<InvisibleItem<'a>>>(false, s)?;
        let (s, presentation_context) = param::<InvisibilityContext<'a>>(true, s)?;
        Ok((s, Self {
            invisible_items,
            presentation_context,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ContextDependentMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ContextDependentMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct ContextDependentOverRidingStyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub over_ridden_style: StyledItem<'a>,
    pub style_context: Vec<StyleContextSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentOverRidingStyledItem<'a> = Id<ContextDependentOverRidingStyledItem_<'a>>;
impl<'a> FromEntity<'a> for ContextDependentOverRidingStyledItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContextDependentOverRidingStyledItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ContextDependentOverRidingStyledItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, over_ridden_style) = param::<StyledItem<'a>>(false, s)?;
        let (s, style_context) = param::<Vec<StyleContextSelect<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            over_ridden_style,
            style_context,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ContextDependentShapeRepresentation_<'a> { // entity
    pub representation_relation: ShapeRepresentationRelationship<'a>,
    pub represented_product_relation: ProductDefinitionShape<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentShapeRepresentation<'a> = Id<ContextDependentShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ContextDependentShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContextDependentShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ContextDependentShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONTEXT_DEPENDENT_SHAPE_REPRESENTATION(")(s)?;
        let (s, representation_relation) = param::<ShapeRepresentationRelationship<'a>>(false, s)?;
        let (s, represented_product_relation) = param::<ProductDefinitionShape<'a>>(true, s)?;
        Ok((s, Self {
            representation_relation,
            represented_product_relation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ContextDependentUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentUnit<'a> = Id<ContextDependentUnit_<'a>>;
impl<'a> FromEntity<'a> for ContextDependentUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContextDependentUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ContextDependentUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONTEXT_DEPENDENT_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Contract_<'a> { // entity
    pub name: Label<'a>,
    pub purpose: Text<'a>,
    pub kind: ContractType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Contract<'a> = Id<Contract_<'a>>;
impl<'a> FromEntity<'a> for Contract_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Contract(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Contract_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONTRACT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, purpose) = param::<Text<'a>>(false, s)?;
        let (s, kind) = param::<ContractType<'a>>(true, s)?;
        Ok((s, Self {
            name,
            purpose,
            kind,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ContractAssignment_<'a> { // entity
    pub assigned_contract: Contract<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContractAssignment<'a> = Id<ContractAssignment_<'a>>;
impl<'a> FromEntity<'a> for ContractAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContractAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ContractAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONTRACT_ASSIGNMENT(")(s)?;
        let (s, assigned_contract) = param::<Contract<'a>>(true, s)?;
        Ok((s, Self {
            assigned_contract,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ContractItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ContractItem<'a> = Id<ContractItem_<'a>>;

#[derive(Debug)]
pub struct ContractType_<'a> { // entity
    pub description: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContractType<'a> = Id<ContractType_<'a>>;
impl<'a> FromEntity<'a> for ContractType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContractType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ContractType_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONTRACT_TYPE(")(s)?;
        let (s, description) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ConversionBasedUnit_<'a> { // entity
    pub name: Label<'a>,
    pub conversion_factor: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConversionBasedUnit<'a> = Id<ConversionBasedUnit_<'a>>;
impl<'a> FromEntity<'a> for ConversionBasedUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConversionBasedUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ConversionBasedUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CONVERSION_BASED_UNIT(")(s)?;
        let (s, _) = tag("*,")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, conversion_factor) = param::<MeasureWithUnit<'a>>(true, s)?;
        Ok((s, Self {
            name,
            conversion_factor,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CoordinatedUniversalTimeOffset_<'a> { // entity
    pub hour_offset: i64,
    pub minute_offset: Option<i64>,
    pub sense: AheadOrBehind<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CoordinatedUniversalTimeOffset<'a> = Id<CoordinatedUniversalTimeOffset_<'a>>;
impl<'a> FromEntity<'a> for CoordinatedUniversalTimeOffset_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CoordinatedUniversalTimeOffset(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CoordinatedUniversalTimeOffset_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COORDINATED_UNIVERSAL_TIME_OFFSET(")(s)?;
        let (s, hour_offset) = param::<i64>(false, s)?;
        let (s, minute_offset) = param::<Option<i64>>(false, s)?;
        let (s, sense) = param::<AheadOrBehind<'a>>(true, s)?;
        Ok((s, Self {
            hour_offset,
            minute_offset,
            sense,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CosFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CosFunction<'a> = Id<CosFunction_<'a>>;
impl<'a> FromEntity<'a> for CosFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CosFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CosFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("COS_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CountMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CountMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct CsgPrimitive_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CsgPrimitive<'a> = Id<CsgPrimitive_<'a>>;

#[derive(Debug)]
pub struct CsgSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CsgSelect<'a> = Id<CsgSelect_<'a>>;

#[derive(Debug)]
pub struct CsgShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CsgShapeRepresentation<'a> = Id<CsgShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for CsgShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CsgShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CsgShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CSG_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CsgSolid_<'a> { // entity
    pub name: Label<'a>,
    pub tree_root_expression: CsgSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CsgSolid<'a> = Id<CsgSolid_<'a>>;
impl<'a> FromEntity<'a> for CsgSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CsgSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CsgSolid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CSG_SOLID(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, tree_root_expression) = param::<CsgSelect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            tree_root_expression,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Curve_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Curve<'a> = Id<Curve_<'a>>;
impl<'a> FromEntity<'a> for Curve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Curve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Curve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CurveBoundedSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub boundaries: Vec<BoundaryCurve<'a>>,
    pub implicit_outer: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveBoundedSurface<'a> = Id<CurveBoundedSurface_<'a>>;
impl<'a> FromEntity<'a> for CurveBoundedSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveBoundedSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CurveBoundedSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CURVE_BOUNDED_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, basis_surface) = param::<Surface<'a>>(false, s)?;
        let (s, boundaries) = param::<Vec<BoundaryCurve<'a>>>(false, s)?;
        let (s, implicit_outer) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            basis_surface,
            boundaries,
            implicit_outer,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CurveDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveDimension<'a> = Id<CurveDimension_<'a>>;
impl<'a> FromEntity<'a> for CurveDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CurveDimension_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CURVE_DIMENSION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CurveFontOrScaledCurveFontSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveFontOrScaledCurveFontSelect<'a> = Id<CurveFontOrScaledCurveFontSelect_<'a>>;

#[derive(Debug)]
pub struct CurveOnSurface_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveOnSurface<'a> = Id<CurveOnSurface_<'a>>;

#[derive(Debug)]
pub struct CurveOrRender_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveOrRender<'a> = Id<CurveOrRender_<'a>>;

#[derive(Debug)]
pub struct CurveReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_curve: Curve<'a>,
    pub transformation: CartesianTransformationOperator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveReplica<'a> = Id<CurveReplica_<'a>>;
impl<'a> FromEntity<'a> for CurveReplica_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveReplica(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CurveReplica_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CURVE_REPLICA(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, parent_curve) = param::<Curve<'a>>(false, s)?;
        let (s, transformation) = param::<CartesianTransformationOperator<'a>>(true, s)?;
        Ok((s, Self {
            name,
            parent_curve,
            transformation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CurveStyle_<'a> { // entity
    pub name: Label<'a>,
    pub curve_font: CurveFontOrScaledCurveFontSelect<'a>,
    pub curve_width: SizeSelect<'a>,
    pub curve_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyle<'a> = Id<CurveStyle_<'a>>;
impl<'a> FromEntity<'a> for CurveStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CurveStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CURVE_STYLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, curve_font) = param::<CurveFontOrScaledCurveFontSelect<'a>>(false, s)?;
        let (s, curve_width) = param::<SizeSelect<'a>>(false, s)?;
        let (s, curve_colour) = param::<Colour<'a>>(true, s)?;
        Ok((s, Self {
            name,
            curve_font,
            curve_width,
            curve_colour,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CurveStyleFont_<'a> { // entity
    pub name: Label<'a>,
    pub pattern_list: Vec<CurveStyleFontPattern<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyleFont<'a> = Id<CurveStyleFont_<'a>>;
impl<'a> FromEntity<'a> for CurveStyleFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveStyleFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CurveStyleFont_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CURVE_STYLE_FONT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, pattern_list) = param::<Vec<CurveStyleFontPattern<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            pattern_list,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CurveStyleFontPattern_<'a> { // entity
    pub visible_segment_length: PositiveLengthMeasure<'a>,
    pub invisible_segment_length: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyleFontPattern<'a> = Id<CurveStyleFontPattern_<'a>>;
impl<'a> FromEntity<'a> for CurveStyleFontPattern_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveStyleFontPattern(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CurveStyleFontPattern_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CURVE_STYLE_FONT_PATTERN(")(s)?;
        let (s, visible_segment_length) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, invisible_segment_length) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            visible_segment_length,
            invisible_segment_length,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CurveStyleFontSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveStyleFontSelect<'a> = Id<CurveStyleFontSelect_<'a>>;

#[derive(Debug)]
pub struct CurveStyleRendering_<'a> { // entity
    pub rendering_method: ShadingCurveMethod<'a>,
    pub rendering_properties: SurfaceRenderingProperties<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyleRendering<'a> = Id<CurveStyleRendering_<'a>>;
impl<'a> FromEntity<'a> for CurveStyleRendering_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveStyleRendering(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CurveStyleRendering_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CURVE_STYLE_RENDERING(")(s)?;
        let (s, rendering_method) = param::<ShadingCurveMethod<'a>>(false, s)?;
        let (s, rendering_properties) = param::<SurfaceRenderingProperties<'a>>(true, s)?;
        Ok((s, Self {
            rendering_method,
            rendering_properties,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CurveSweptSolidShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveSweptSolidShapeRepresentation<'a> = Id<CurveSweptSolidShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for CurveSweptSolidShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveSweptSolidShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CurveSweptSolidShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}

#[derive(Debug)]
pub struct CurveToleranceDeviation<'a>(pub PositiveLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for CurveToleranceDeviation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveLengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct CurveToleranceParameter<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CurveToleranceParameter<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct CylindricalPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalPair<'a> = Id<CylindricalPair_<'a>>;
impl<'a> FromEntity<'a> for CylindricalPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CylindricalPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CylindricalPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CYLINDRICAL_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CylindricalPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_translation: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation: TranslationalRangeMeasure<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalPairRange<'a> = Id<CylindricalPairRange_<'a>>;
impl<'a> FromEntity<'a> for CylindricalPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CylindricalPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CylindricalPairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CYLINDRICAL_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, lower_limit_actual_translation) = param::<TranslationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_actual_translation) = param::<TranslationalRangeMeasure<'a>>(false, s)?;
        let (s, lower_limit_actual_rotation) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_actual_rotation) = param::<RotationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_translation,
            upper_limit_actual_translation,
            lower_limit_actual_rotation,
            upper_limit_actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CylindricalPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_translation: LengthMeasure<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalPairValue<'a> = Id<CylindricalPairValue_<'a>>;
impl<'a> FromEntity<'a> for CylindricalPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CylindricalPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CylindricalPairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CYLINDRICAL_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_translation) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, actual_rotation) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_translation,
            actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CylindricalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalSurface<'a> = Id<CylindricalSurface_<'a>>;
impl<'a> FromEntity<'a> for CylindricalSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CylindricalSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CylindricalSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CYLINDRICAL_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement3d<'a>>(false, s)?;
        let (s, radius) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            radius,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct CylindricityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricityTolerance<'a> = Id<CylindricityTolerance_<'a>>;
impl<'a> FromEntity<'a> for CylindricityTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CylindricityTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for CylindricityTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("CYLINDRICITY_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DataEnvironment_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub elements: Vec<PropertyDefinitionRepresentation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DataEnvironment<'a> = Id<DataEnvironment_<'a>>;
impl<'a> FromEntity<'a> for DataEnvironment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DataEnvironment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DataEnvironment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATA_ENVIRONMENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, elements) = param::<Vec<PropertyDefinitionRepresentation<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            elements,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Date_<'a> { // entity
    pub year_component: YearNumber<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Date<'a> = Id<Date_<'a>>;
impl<'a> FromEntity<'a> for Date_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Date(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Date_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATE(")(s)?;
        let (s, year_component) = param::<YearNumber<'a>>(true, s)?;
        Ok((s, Self {
            year_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DateAndTime_<'a> { // entity
    pub date_component: Date<'a>,
    pub time_component: LocalTime<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateAndTime<'a> = Id<DateAndTime_<'a>>;
impl<'a> FromEntity<'a> for DateAndTime_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DateAndTime(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DateAndTime_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATE_AND_TIME(")(s)?;
        let (s, date_component) = param::<Date<'a>>(false, s)?;
        let (s, time_component) = param::<LocalTime<'a>>(true, s)?;
        Ok((s, Self {
            date_component,
            time_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DateAndTimeAssignment_<'a> { // entity
    pub assigned_date_and_time: DateAndTime<'a>,
    pub role: DateTimeRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateAndTimeAssignment<'a> = Id<DateAndTimeAssignment_<'a>>;
impl<'a> FromEntity<'a> for DateAndTimeAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DateAndTimeAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DateAndTimeAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATE_AND_TIME_ASSIGNMENT(")(s)?;
        let (s, assigned_date_and_time) = param::<DateAndTime<'a>>(false, s)?;
        let (s, role) = param::<DateTimeRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_date_and_time,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DateAndTimeItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateAndTimeItem<'a> = Id<DateAndTimeItem_<'a>>;

#[derive(Debug)]
pub struct DateAssignment_<'a> { // entity
    pub assigned_date: Date<'a>,
    pub role: DateRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateAssignment<'a> = Id<DateAssignment_<'a>>;
impl<'a> FromEntity<'a> for DateAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DateAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DateAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATE_ASSIGNMENT(")(s)?;
        let (s, assigned_date) = param::<Date<'a>>(false, s)?;
        let (s, role) = param::<DateRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_date,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DateItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateItem<'a> = Id<DateItem_<'a>>;

#[derive(Debug)]
pub struct DateRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateRole<'a> = Id<DateRole_<'a>>;
impl<'a> FromEntity<'a> for DateRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DateRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DateRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATE_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DateTimeOrEventOccurrence_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateTimeOrEventOccurrence<'a> = Id<DateTimeOrEventOccurrence_<'a>>;

#[derive(Debug)]
pub struct DateTimeRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateTimeRole<'a> = Id<DateTimeRole_<'a>>;
impl<'a> FromEntity<'a> for DateTimeRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DateTimeRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DateTimeRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATE_TIME_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DateTimeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateTimeSelect<'a> = Id<DateTimeSelect_<'a>>;

#[derive(Debug)]
pub struct DatedEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_end_date: Option<DateTimeOrEventOccurrence<'a>>,
    pub effectivity_start_date: DateTimeOrEventOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatedEffectivity<'a> = Id<DatedEffectivity_<'a>>;
impl<'a> FromEntity<'a> for DatedEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatedEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DatedEffectivity_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATED_EFFECTIVITY(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, effectivity_end_date) = param::<Option<DateTimeOrEventOccurrence<'a>>>(false, s)?;
        let (s, effectivity_start_date) = param::<DateTimeOrEventOccurrence<'a>>(true, s)?;
        Ok((s, Self {
            id,
            effectivity_end_date,
            effectivity_start_date,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Datum_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Datum<'a> = Id<Datum_<'a>>;
impl<'a> FromEntity<'a> for Datum_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Datum(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Datum_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATUM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(false, s)?;
        let (s, identification) = param::<Identifier<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            identification,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DatumFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumFeature<'a> = Id<DatumFeature_<'a>>;
impl<'a> FromEntity<'a> for DatumFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatumFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DatumFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATUM_FEATURE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DatumFeatureCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumFeatureCallout<'a> = Id<DatumFeatureCallout_<'a>>;
impl<'a> FromEntity<'a> for DatumFeatureCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatumFeatureCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DatumFeatureCallout_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATUM_FEATURE_CALLOUT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DatumReference_<'a> { // entity
    pub precedence: i64,
    pub referenced_datum: Datum<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumReference<'a> = Id<DatumReference_<'a>>;
impl<'a> FromEntity<'a> for DatumReference_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatumReference(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DatumReference_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATUM_REFERENCE(")(s)?;
        let (s, precedence) = param::<i64>(false, s)?;
        let (s, referenced_datum) = param::<Datum<'a>>(true, s)?;
        Ok((s, Self {
            precedence,
            referenced_datum,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DatumTarget_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub target_id: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumTarget<'a> = Id<DatumTarget_<'a>>;
impl<'a> FromEntity<'a> for DatumTarget_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatumTarget(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DatumTarget_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATUM_TARGET(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(false, s)?;
        let (s, target_id) = param::<Identifier<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            target_id,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DatumTargetCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumTargetCallout<'a> = Id<DatumTargetCallout_<'a>>;
impl<'a> FromEntity<'a> for DatumTargetCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatumTargetCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DatumTargetCallout_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DATUM_TARGET_CALLOUT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DayInMonthNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DayInMonthNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct DefaultToleranceTable_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefaultToleranceTable<'a> = Id<DefaultToleranceTable_<'a>>;
impl<'a> FromEntity<'a> for DefaultToleranceTable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefaultToleranceTable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DefaultToleranceTable_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DEFAULT_TOLERANCE_TABLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DefaultToleranceTableCell_<'a> { // entity
    pub name: Label<'a>,
    pub item_element: CompoundItemDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefaultToleranceTableCell<'a> = Id<DefaultToleranceTableCell_<'a>>;
impl<'a> FromEntity<'a> for DefaultToleranceTableCell_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefaultToleranceTableCell(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DefaultToleranceTableCell_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DEFAULT_TOLERANCE_TABLE_CELL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, item_element) = param::<CompoundItemDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            item_element,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DefinedCharacterGlyph_<'a> { // entity
    pub name: Label<'a>,
    pub definition: DefinedGlyphSelect<'a>,
    pub placement: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinedCharacterGlyph<'a> = Id<DefinedCharacterGlyph_<'a>>;
impl<'a> FromEntity<'a> for DefinedCharacterGlyph_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefinedCharacterGlyph(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DefinedCharacterGlyph_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DEFINED_CHARACTER_GLYPH(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, definition) = param::<DefinedGlyphSelect<'a>>(false, s)?;
        let (s, placement) = param::<Axis2Placement<'a>>(true, s)?;
        Ok((s, Self {
            name,
            definition,
            placement,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinedFunction<'a> = Id<DefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for DefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DefinedFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DEFINED_FUNCTION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DefinedGlyphSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DefinedGlyphSelect<'a> = Id<DefinedGlyphSelect_<'a>>;

#[derive(Debug)]
pub struct DefinedSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub definition: DefinedSymbolSelect<'a>,
    pub target: SymbolTarget<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinedSymbol<'a> = Id<DefinedSymbol_<'a>>;
impl<'a> FromEntity<'a> for DefinedSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefinedSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DefinedSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DEFINED_SYMBOL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, definition) = param::<DefinedSymbolSelect<'a>>(false, s)?;
        let (s, target) = param::<SymbolTarget<'a>>(true, s)?;
        Ok((s, Self {
            name,
            definition,
            target,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DefinedSymbolSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DefinedSymbolSelect<'a> = Id<DefinedSymbolSelect_<'a>>;

#[derive(Debug)]
pub struct DefinitionalRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinitionalRepresentation<'a> = Id<DefinitionalRepresentation_<'a>>;
impl<'a> FromEntity<'a> for DefinitionalRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefinitionalRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DefinitionalRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DEFINITIONAL_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DegeneratePcurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DegeneratePcurve<'a> = Id<DegeneratePcurve_<'a>>;
impl<'a> FromEntity<'a> for DegeneratePcurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DegeneratePcurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DegeneratePcurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DEGENERATE_PCURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, basis_surface) = param::<Surface<'a>>(false, s)?;
        let (s, reference_to_curve) = param::<DefinitionalRepresentation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            basis_surface,
            reference_to_curve,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DegenerateToroidalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub major_radius: PositiveLengthMeasure<'a>,
    pub minor_radius: PositiveLengthMeasure<'a>,
    pub select_outer: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DegenerateToroidalSurface<'a> = Id<DegenerateToroidalSurface_<'a>>;
impl<'a> FromEntity<'a> for DegenerateToroidalSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DegenerateToroidalSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DegenerateToroidalSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DEGENERATE_TOROIDAL_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement3d<'a>>(false, s)?;
        let (s, major_radius) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, minor_radius) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, select_outer) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            position,
            major_radius,
            minor_radius,
            select_outer,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DerivedPropertySelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DerivedPropertySelect<'a> = Id<DerivedPropertySelect_<'a>>;

#[derive(Debug)]
pub struct DerivedShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedShapeAspect<'a> = Id<DerivedShapeAspect_<'a>>;
impl<'a> FromEntity<'a> for DerivedShapeAspect_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DerivedShapeAspect(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DerivedShapeAspect_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DERIVED_SHAPE_ASPECT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DerivedUnit_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedUnit<'a> = Id<DerivedUnit_<'a>>;
impl<'a> FromEntity<'a> for DerivedUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DerivedUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DerivedUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DERIVED_UNIT(")(s)?;
        let (s, elements) = param::<Vec<DerivedUnitElement<'a>>>(true, s)?;
        Ok((s, Self {
            elements,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DerivedUnitElement_<'a> { // entity
    pub unit: NamedUnit<'a>,
    pub exponent: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedUnitElement<'a> = Id<DerivedUnitElement_<'a>>;
impl<'a> FromEntity<'a> for DerivedUnitElement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DerivedUnitElement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DerivedUnitElement_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DERIVED_UNIT_ELEMENT(")(s)?;
        let (s, unit) = param::<NamedUnit<'a>>(false, s)?;
        let (s, exponent) = param::<f64>(true, s)?;
        Ok((s, Self {
            unit,
            exponent,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DerivedUnitVariable_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedUnitVariable<'a> = Id<DerivedUnitVariable_<'a>>;
impl<'a> FromEntity<'a> for DerivedUnitVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DerivedUnitVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DerivedUnitVariable_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DERIVED_UNIT_VARIABLE(")(s)?;
        let (s, elements) = param::<Vec<DerivedUnitElement<'a>>>(true, s)?;
        Ok((s, Self {
            elements,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DescriptionAttribute_<'a> { // entity
    pub attribute_value: Text<'a>,
    pub described_item: DescriptionAttributeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DescriptionAttribute<'a> = Id<DescriptionAttribute_<'a>>;
impl<'a> FromEntity<'a> for DescriptionAttribute_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DescriptionAttribute(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DescriptionAttribute_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DESCRIPTION_ATTRIBUTE(")(s)?;
        let (s, attribute_value) = param::<Text<'a>>(false, s)?;
        let (s, described_item) = param::<DescriptionAttributeSelect<'a>>(true, s)?;
        Ok((s, Self {
            attribute_value,
            described_item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DescriptionAttributeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DescriptionAttributeSelect<'a> = Id<DescriptionAttributeSelect_<'a>>;

#[derive(Debug)]
pub struct DescriptiveMeasure<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DescriptiveMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct DescriptiveRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DescriptiveRepresentationItem<'a> = Id<DescriptiveRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for DescriptiveRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DescriptiveRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DescriptiveRepresentationItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DESCRIPTIVE_REPRESENTATION_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DiameterDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DiameterDimension<'a> = Id<DiameterDimension_<'a>>;
impl<'a> FromEntity<'a> for DiameterDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DiameterDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DiameterDimension_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIAMETER_DIMENSION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCallout<'a> = Id<DimensionCallout_<'a>>;
impl<'a> FromEntity<'a> for DimensionCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionCallout_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSION_CALLOUT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionCalloutComponentRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCalloutComponentRelationship<'a> = Id<DimensionCalloutComponentRelationship_<'a>>;
impl<'a> FromEntity<'a> for DimensionCalloutComponentRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCalloutComponentRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionCalloutComponentRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, relating_draughting_callout) = param::<DraughtingCallout<'a>>(false, s)?;
        let (s, related_draughting_callout) = param::<DraughtingCallout<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_draughting_callout,
            related_draughting_callout,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionCalloutRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCalloutRelationship<'a> = Id<DimensionCalloutRelationship_<'a>>;
impl<'a> FromEntity<'a> for DimensionCalloutRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCalloutRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionCalloutRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSION_CALLOUT_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, relating_draughting_callout) = param::<DraughtingCallout<'a>>(false, s)?;
        let (s, related_draughting_callout) = param::<DraughtingCallout<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_draughting_callout,
            related_draughting_callout,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DimensionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct DimensionCurve_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCurve<'a> = Id<DimensionCurve_<'a>>;
impl<'a> FromEntity<'a> for DimensionCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSION_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionCurveDirectedCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCurveDirectedCallout<'a> = Id<DimensionCurveDirectedCallout_<'a>>;
impl<'a> FromEntity<'a> for DimensionCurveDirectedCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCurveDirectedCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionCurveDirectedCallout_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSION_CURVE_DIRECTED_CALLOUT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionCurveTerminator_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub annotated_curve: AnnotationCurveOccurrence<'a>,
    pub role: DimensionExtentUsage<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCurveTerminator<'a> = Id<DimensionCurveTerminator_<'a>>;
impl<'a> FromEntity<'a> for DimensionCurveTerminator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCurveTerminator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionCurveTerminator_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSION_CURVE_TERMINATOR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, annotated_curve) = param::<AnnotationCurveOccurrence<'a>>(false, s)?;
        let (s, role) = param::<DimensionExtentUsage<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            annotated_curve,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum DimensionExtentUsage<'a> { // enum
    Origin,
    Target,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for DimensionExtentUsage<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use DimensionExtentUsage::*;
        alt((
            map(tag(".ORIGIN."), |_| Origin),
            map(tag(".TARGET."), |_| Target),
        ))(s)
    }
}
#[derive(Debug)]
pub struct DimensionPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionPair<'a> = Id<DimensionPair_<'a>>;
impl<'a> FromEntity<'a> for DimensionPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSION_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, relating_draughting_callout) = param::<DraughtingCallout<'a>>(false, s)?;
        let (s, related_draughting_callout) = param::<DraughtingCallout<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_draughting_callout,
            related_draughting_callout,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionRelatedToleranceZoneElement_<'a> { // entity
    pub related_dimension: DimensionalLocation<'a>,
    pub related_element: ToleranceZoneDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionRelatedToleranceZoneElement<'a> = Id<DimensionRelatedToleranceZoneElement_<'a>>;
impl<'a> FromEntity<'a> for DimensionRelatedToleranceZoneElement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionRelatedToleranceZoneElement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionRelatedToleranceZoneElement_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSION_RELATED_TOLERANCE_ZONE_ELEMENT(")(s)?;
        let (s, related_dimension) = param::<DimensionalLocation<'a>>(false, s)?;
        let (s, related_element) = param::<ToleranceZoneDefinition<'a>>(true, s)?;
        Ok((s, Self {
            related_dimension,
            related_element,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct DimensionTextAssociativity_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionTextAssociativity<'a> = Id<DimensionTextAssociativity_<'a>>;
impl<'a> FromEntity<'a> for DimensionTextAssociativity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionTextAssociativity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionTextAssociativity_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSION_TEXT_ASSOCIATIVITY(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        let (s, literal) = param::<PresentableText<'a>>(false, s)?;
        let (s, placement) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, alignment) = param::<TextAlignment<'a>>(false, s)?;
        let (s, path) = param::<TextPath<'a>>(false, s)?;
        let (s, font) = param::<FontSelect<'a>>(false, s)?;
        let (s, mapping_source) = param::<RepresentationMap<'a>>(false, s)?;
        let (s, mapping_target) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            literal,
            placement,
            alignment,
            path,
            font,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionalCharacteristic_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DimensionalCharacteristic<'a> = Id<DimensionalCharacteristic_<'a>>;

#[derive(Debug)]
pub struct DimensionalCharacteristicRepresentation_<'a> { // entity
    pub dimension: DimensionalCharacteristic<'a>,
    pub representation: ShapeDimensionRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalCharacteristicRepresentation<'a> = Id<DimensionalCharacteristicRepresentation_<'a>>;
impl<'a> FromEntity<'a> for DimensionalCharacteristicRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalCharacteristicRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionalCharacteristicRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSIONAL_CHARACTERISTIC_REPRESENTATION(")(s)?;
        let (s, dimension) = param::<DimensionalCharacteristic<'a>>(false, s)?;
        let (s, representation) = param::<ShapeDimensionRepresentation<'a>>(true, s)?;
        Ok((s, Self {
            dimension,
            representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionalExponents_<'a> { // entity
    pub length_exponent: f64,
    pub mass_exponent: f64,
    pub time_exponent: f64,
    pub electric_current_exponent: f64,
    pub thermodynamic_temperature_exponent: f64,
    pub amount_of_substance_exponent: f64,
    pub luminous_intensity_exponent: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalExponents<'a> = Id<DimensionalExponents_<'a>>;
impl<'a> FromEntity<'a> for DimensionalExponents_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalExponents(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionalExponents_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSIONAL_EXPONENTS(")(s)?;
        let (s, length_exponent) = param::<f64>(false, s)?;
        let (s, mass_exponent) = param::<f64>(false, s)?;
        let (s, time_exponent) = param::<f64>(false, s)?;
        let (s, electric_current_exponent) = param::<f64>(false, s)?;
        let (s, thermodynamic_temperature_exponent) = param::<f64>(false, s)?;
        let (s, amount_of_substance_exponent) = param::<f64>(false, s)?;
        let (s, luminous_intensity_exponent) = param::<f64>(true, s)?;
        Ok((s, Self {
            length_exponent,
            mass_exponent,
            time_exponent,
            electric_current_exponent,
            thermodynamic_temperature_exponent,
            amount_of_substance_exponent,
            luminous_intensity_exponent,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionalLocation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalLocation<'a> = Id<DimensionalLocation_<'a>>;
impl<'a> FromEntity<'a> for DimensionalLocation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalLocation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionalLocation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSIONAL_LOCATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionalLocationWithPath_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    pub path: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalLocationWithPath<'a> = Id<DimensionalLocationWithPath_<'a>>;
impl<'a> FromEntity<'a> for DimensionalLocationWithPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalLocationWithPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionalLocationWithPath_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSIONAL_LOCATION_WITH_PATH(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, path) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            path,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionalSize_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalSize<'a> = Id<DimensionalSize_<'a>>;
impl<'a> FromEntity<'a> for DimensionalSize_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalSize(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionalSize_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSIONAL_SIZE(")(s)?;
        let (s, applies_to) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            applies_to,
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DimensionalSizeWithPath_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    pub path: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalSizeWithPath<'a> = Id<DimensionalSizeWithPath_<'a>>;
impl<'a> FromEntity<'a> for DimensionalSizeWithPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalSizeWithPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DimensionalSizeWithPath_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIMENSIONAL_SIZE_WITH_PATH(")(s)?;
        let (s, applies_to) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, path) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            applies_to,
            name,
            path,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DirectedAction_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub directive: ActionDirective<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectedAction<'a> = Id<DirectedAction_<'a>>;
impl<'a> FromEntity<'a> for DirectedAction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DirectedAction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DirectedAction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIRECTED_ACTION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, chosen_method) = param::<ActionMethod<'a>>(false, s)?;
        let (s, directive) = param::<ActionDirective<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            directive,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DirectedAngle_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectedAngle<'a> = Id<DirectedAngle_<'a>>;
impl<'a> FromEntity<'a> for DirectedAngle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DirectedAngle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DirectedAngle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIRECTED_ANGLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DirectedDimensionalLocation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectedDimensionalLocation<'a> = Id<DirectedDimensionalLocation_<'a>>;
impl<'a> FromEntity<'a> for DirectedDimensionalLocation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DirectedDimensionalLocation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DirectedDimensionalLocation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIRECTED_DIMENSIONAL_LOCATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Direction_<'a> { // entity
    pub name: Label<'a>,
    pub direction_ratios: Vec<f64>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Direction<'a> = Id<Direction_<'a>>;
impl<'a> FromEntity<'a> for Direction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Direction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Direction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIRECTION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, direction_ratios) = param::<Vec<f64>>(true, s)?;
        Ok((s, Self {
            name,
            direction_ratios,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum DirectionCountSelect<'a> { // select
    UDirectionCount(UDirectionCount<'a>),
    VDirectionCount(VDirectionCount<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DirectionCountSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("U_DIRECTION_COUNT("), <UDirectionCount<'a>>::parse, char(')')), |r| DirectionCountSelect::UDirectionCount(r)),
            map(delimited(tag("V_DIRECTION_COUNT("), <VDirectionCount<'a>>::parse, char(')')), |r| DirectionCountSelect::VDirectionCount(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct DirectionShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectionShapeRepresentation<'a> = Id<DirectionShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for DirectionShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DirectionShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DirectionShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIRECTION_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DivExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DivExpression<'a> = Id<DivExpression_<'a>>;
impl<'a> FromEntity<'a> for DivExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DivExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DivExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DIV_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Document_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub kind: DocumentType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Document<'a> = Id<Document_<'a>>;
impl<'a> FromEntity<'a> for Document_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Document(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Document_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DOCUMENT(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, kind) = param::<DocumentType<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            kind,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct DocumentFile_<'a> { // entity
    pub id: Identifier<'a>,
    pub document__name: Label<'a>,
    pub document__description: Option<Text<'a>>,
    pub kind: DocumentType<'a>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentFile<'a> = Id<DocumentFile_<'a>>;
impl<'a> FromEntity<'a> for DocumentFile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentFile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DocumentFile_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DOCUMENT_FILE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, document__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, document__description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, kind) = param::<DocumentType<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            document__name,
            document__description,
            kind,
            characterized_object__name,
            characterized_object__description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DocumentProductAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_document: Document<'a>,
    pub related_product: ProductOrFormationOrDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentProductAssociation<'a> = Id<DocumentProductAssociation_<'a>>;
impl<'a> FromEntity<'a> for DocumentProductAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentProductAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DocumentProductAssociation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DOCUMENT_PRODUCT_ASSOCIATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_document) = param::<Document<'a>>(false, s)?;
        let (s, related_product) = param::<ProductOrFormationOrDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_document,
            related_product,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DocumentProductEquivalence_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_document: Document<'a>,
    pub related_product: ProductOrFormationOrDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentProductEquivalence<'a> = Id<DocumentProductEquivalence_<'a>>;
impl<'a> FromEntity<'a> for DocumentProductEquivalence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentProductEquivalence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DocumentProductEquivalence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DOCUMENT_PRODUCT_EQUIVALENCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_document) = param::<Document<'a>>(false, s)?;
        let (s, related_product) = param::<ProductOrFormationOrDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_document,
            related_product,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DocumentReference_<'a> { // entity
    pub assigned_document: Document<'a>,
    pub source: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentReference<'a> = Id<DocumentReference_<'a>>;
impl<'a> FromEntity<'a> for DocumentReference_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentReference(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DocumentReference_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DOCUMENT_REFERENCE(")(s)?;
        let (s, assigned_document) = param::<Document<'a>>(false, s)?;
        let (s, source) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            assigned_document,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DocumentReferenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DocumentReferenceItem<'a> = Id<DocumentReferenceItem_<'a>>;

#[derive(Debug)]
pub struct DocumentRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_document: Document<'a>,
    pub related_document: Document<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentRelationship<'a> = Id<DocumentRelationship_<'a>>;
impl<'a> FromEntity<'a> for DocumentRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DocumentRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DOCUMENT_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_document) = param::<Document<'a>>(false, s)?;
        let (s, related_document) = param::<Document<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_document,
            related_document,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DocumentRepresentationType_<'a> { // entity
    pub name: Label<'a>,
    pub represented_document: Document<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentRepresentationType<'a> = Id<DocumentRepresentationType_<'a>>;
impl<'a> FromEntity<'a> for DocumentRepresentationType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentRepresentationType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DocumentRepresentationType_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DOCUMENT_REPRESENTATION_TYPE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, represented_document) = param::<Document<'a>>(true, s)?;
        Ok((s, Self {
            name,
            represented_document,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DocumentType_<'a> { // entity
    pub product_data_type: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentType<'a> = Id<DocumentType_<'a>>;
impl<'a> FromEntity<'a> for DocumentType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DocumentType_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DOCUMENT_TYPE(")(s)?;
        let (s, product_data_type) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            product_data_type,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DocumentUsageConstraint_<'a> { // entity
    pub source: Document<'a>,
    pub subject_element: Label<'a>,
    pub subject_element_value: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentUsageConstraint<'a> = Id<DocumentUsageConstraint_<'a>>;
impl<'a> FromEntity<'a> for DocumentUsageConstraint_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentUsageConstraint(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DocumentUsageConstraint_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DOCUMENT_USAGE_CONSTRAINT(")(s)?;
        let (s, source) = param::<Document<'a>>(false, s)?;
        let (s, subject_element) = param::<Label<'a>>(false, s)?;
        let (s, subject_element_value) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            source,
            subject_element,
            subject_element_value,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DocumentUsageConstraintAssignment_<'a> { // entity
    pub assigned_document_usage: DocumentUsageConstraint<'a>,
    pub role: DocumentUsageRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentUsageConstraintAssignment<'a> = Id<DocumentUsageConstraintAssignment_<'a>>;
impl<'a> FromEntity<'a> for DocumentUsageConstraintAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentUsageConstraintAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DocumentUsageConstraintAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT(")(s)?;
        let (s, assigned_document_usage) = param::<DocumentUsageConstraint<'a>>(false, s)?;
        let (s, role) = param::<DocumentUsageRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_document_usage,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DocumentUsageRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentUsageRole<'a> = Id<DocumentUsageRole_<'a>>;
impl<'a> FromEntity<'a> for DocumentUsageRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentUsageRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DocumentUsageRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DOCUMENT_USAGE_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingAnnotationOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingAnnotationOccurrence<'a> = Id<DraughtingAnnotationOccurrence_<'a>>;
impl<'a> FromEntity<'a> for DraughtingAnnotationOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingAnnotationOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingAnnotationOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_ANNOTATION_OCCURRENCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingCallout<'a> = Id<DraughtingCallout_<'a>>;
impl<'a> FromEntity<'a> for DraughtingCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingCallout_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_CALLOUT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingCalloutElement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DraughtingCalloutElement<'a> = Id<DraughtingCalloutElement_<'a>>;

#[derive(Debug)]
pub struct DraughtingCalloutRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingCalloutRelationship<'a> = Id<DraughtingCalloutRelationship_<'a>>;
impl<'a> FromEntity<'a> for DraughtingCalloutRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingCalloutRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingCalloutRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_CALLOUT_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, relating_draughting_callout) = param::<DraughtingCallout<'a>>(false, s)?;
        let (s, related_draughting_callout) = param::<DraughtingCallout<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_draughting_callout,
            related_draughting_callout,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingElements_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingElements<'a> = Id<DraughtingElements_<'a>>;
impl<'a> FromEntity<'a> for DraughtingElements_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingElements(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingElements_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_ELEMENTS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingModel_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingModel<'a> = Id<DraughtingModel_<'a>>;
impl<'a> FromEntity<'a> for DraughtingModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingModel_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_MODEL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingModelItemAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub identified_item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingModelItemAssociation<'a> = Id<DraughtingModelItemAssociation_<'a>>;
impl<'a> FromEntity<'a> for DraughtingModelItemAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingModelItemAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingModelItemAssociation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_MODEL_ITEM_ASSOCIATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, definition) = param::<RepresentedDefinition<'a>>(false, s)?;
        let (s, used_representation) = param::<Representation<'a>>(false, s)?;
        let (s, identified_item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            definition,
            used_representation,
            identified_item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingModelItemAssociationSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DraughtingModelItemAssociationSelect<'a> = Id<DraughtingModelItemAssociationSelect_<'a>>;

#[derive(Debug)]
pub struct DraughtingPreDefinedColour_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingPreDefinedColour<'a> = Id<DraughtingPreDefinedColour_<'a>>;
impl<'a> FromEntity<'a> for DraughtingPreDefinedColour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingPreDefinedColour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingPreDefinedColour_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_PRE_DEFINED_COLOUR(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingPreDefinedCurveFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingPreDefinedCurveFont<'a> = Id<DraughtingPreDefinedCurveFont_<'a>>;
impl<'a> FromEntity<'a> for DraughtingPreDefinedCurveFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingPreDefinedCurveFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingPreDefinedCurveFont_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_PRE_DEFINED_CURVE_FONT(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingPreDefinedTextFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingPreDefinedTextFont<'a> = Id<DraughtingPreDefinedTextFont_<'a>>;
impl<'a> FromEntity<'a> for DraughtingPreDefinedTextFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingPreDefinedTextFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingPreDefinedTextFont_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_PRE_DEFINED_TEXT_FONT(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingSpecificationReference_<'a> { // entity
    pub assigned_document: Document<'a>,
    pub source: Label<'a>,
    pub specified_items: Vec<SpecifiedItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingSpecificationReference<'a> = Id<DraughtingSpecificationReference_<'a>>;
impl<'a> FromEntity<'a> for DraughtingSpecificationReference_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingSpecificationReference(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingSpecificationReference_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_SPECIFICATION_REFERENCE(")(s)?;
        let (s, assigned_document) = param::<Document<'a>>(false, s)?;
        let (s, source) = param::<Label<'a>>(false, s)?;
        let (s, specified_items) = param::<Vec<SpecifiedItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_document,
            source,
            specified_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingSubfigureRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingSubfigureRepresentation<'a> = Id<DraughtingSubfigureRepresentation_<'a>>;
impl<'a> FromEntity<'a> for DraughtingSubfigureRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingSubfigureRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingSubfigureRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_SUBFIGURE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingSymbolRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingSymbolRepresentation<'a> = Id<DraughtingSymbolRepresentation_<'a>>;
impl<'a> FromEntity<'a> for DraughtingSymbolRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingSymbolRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingSymbolRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_SYMBOL_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingTextLiteralWithDelineation_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub delineation: TextDelineation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingTextLiteralWithDelineation<'a> = Id<DraughtingTextLiteralWithDelineation_<'a>>;
impl<'a> FromEntity<'a> for DraughtingTextLiteralWithDelineation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingTextLiteralWithDelineation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingTextLiteralWithDelineation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_TEXT_LITERAL_WITH_DELINEATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, literal) = param::<PresentableText<'a>>(false, s)?;
        let (s, placement) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, alignment) = param::<TextAlignment<'a>>(false, s)?;
        let (s, path) = param::<TextPath<'a>>(false, s)?;
        let (s, font) = param::<FontSelect<'a>>(false, s)?;
        let (s, delineation) = param::<TextDelineation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            delineation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingTitle_<'a> { // entity
    pub items: Vec<DraughtingTitledItem<'a>>,
    pub language: Label<'a>,
    pub contents: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingTitle<'a> = Id<DraughtingTitle_<'a>>;
impl<'a> FromEntity<'a> for DraughtingTitle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingTitle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DraughtingTitle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAUGHTING_TITLE(")(s)?;
        let (s, items) = param::<Vec<DraughtingTitledItem<'a>>>(false, s)?;
        let (s, language) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            items,
            language,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DraughtingTitledItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DraughtingTitledItem<'a> = Id<DraughtingTitledItem_<'a>>;

#[derive(Debug)]
pub struct DrawingDefinition_<'a> { // entity
    pub drawing_number: Identifier<'a>,
    pub drawing_type: Option<Label<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingDefinition<'a> = Id<DrawingDefinition_<'a>>;
impl<'a> FromEntity<'a> for DrawingDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DrawingDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAWING_DEFINITION(")(s)?;
        let (s, drawing_number) = param::<Identifier<'a>>(false, s)?;
        let (s, drawing_type) = param::<Option<Label<'a>>>(true, s)?;
        Ok((s, Self {
            drawing_number,
            drawing_type,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DrawingRevision_<'a> { // entity
    pub revision_identifier: Identifier<'a>,
    pub drawing_identifier: DrawingDefinition<'a>,
    pub intended_scale: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingRevision<'a> = Id<DrawingRevision_<'a>>;
impl<'a> FromEntity<'a> for DrawingRevision_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingRevision(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DrawingRevision_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAWING_REVISION(")(s)?;
        let (s, revision_identifier) = param::<Identifier<'a>>(false, s)?;
        let (s, drawing_identifier) = param::<DrawingDefinition<'a>>(false, s)?;
        let (s, intended_scale) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            revision_identifier,
            drawing_identifier,
            intended_scale,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DrawingRevisionSequence_<'a> { // entity
    pub predecessor: DrawingRevision<'a>,
    pub successor: DrawingRevision<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingRevisionSequence<'a> = Id<DrawingRevisionSequence_<'a>>;
impl<'a> FromEntity<'a> for DrawingRevisionSequence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingRevisionSequence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DrawingRevisionSequence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAWING_REVISION_SEQUENCE(")(s)?;
        let (s, predecessor) = param::<DrawingRevision<'a>>(false, s)?;
        let (s, successor) = param::<DrawingRevision<'a>>(true, s)?;
        Ok((s, Self {
            predecessor,
            successor,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DrawingSheetLayout_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingSheetLayout<'a> = Id<DrawingSheetLayout_<'a>>;
impl<'a> FromEntity<'a> for DrawingSheetLayout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingSheetLayout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DrawingSheetLayout_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAWING_SHEET_LAYOUT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DrawingSheetRevision_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    pub revision_identifier: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingSheetRevision<'a> = Id<DrawingSheetRevision_<'a>>;
impl<'a> FromEntity<'a> for DrawingSheetRevision_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingSheetRevision(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DrawingSheetRevision_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAWING_SHEET_REVISION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(false, s)?;
        let (s, revision_identifier) = param::<Identifier<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            revision_identifier,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct DrawingSheetRevisionUsage_<'a> { // entity
    pub area: PresentationArea<'a>,
    pub in_set: PresentationSet<'a>,
    pub sheet_number: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingSheetRevisionUsage<'a> = Id<DrawingSheetRevisionUsage_<'a>>;
impl<'a> FromEntity<'a> for DrawingSheetRevisionUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingSheetRevisionUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for DrawingSheetRevisionUsage_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("DRAWING_SHEET_REVISION_USAGE(")(s)?;
        let (s, area) = param::<PresentationArea<'a>>(false, s)?;
        let (s, in_set) = param::<PresentationSet<'a>>(false, s)?;
        let (s, sheet_number) = param::<Identifier<'a>>(true, s)?;
        Ok((s, Self {
            area,
            in_set,
            sheet_number,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Edge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_start: Vertex<'a>,
    pub edge_end: Vertex<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Edge<'a> = Id<Edge_<'a>>;
impl<'a> FromEntity<'a> for Edge_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Edge(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Edge_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EDGE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, edge_start) = param::<Vertex<'a>>(false, s)?;
        let (s, edge_end) = param::<Vertex<'a>>(true, s)?;
        Ok((s, Self {
            name,
            edge_start,
            edge_end,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EdgeBasedWireframeModel_<'a> { // entity
    pub name: Label<'a>,
    pub ebwm_boundary: Vec<ConnectedEdgeSet<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeBasedWireframeModel<'a> = Id<EdgeBasedWireframeModel_<'a>>;
impl<'a> FromEntity<'a> for EdgeBasedWireframeModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EdgeBasedWireframeModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EdgeBasedWireframeModel_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EDGE_BASED_WIREFRAME_MODEL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, ebwm_boundary) = param::<Vec<ConnectedEdgeSet<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            ebwm_boundary,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EdgeBasedWireframeShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeBasedWireframeShapeRepresentation<'a> = Id<EdgeBasedWireframeShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for EdgeBasedWireframeShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EdgeBasedWireframeShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EdgeBasedWireframeShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct EdgeCurve_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub edge_start: Vertex<'a>,
    pub edge_end: Vertex<'a>,
    pub edge_geometry: Curve<'a>,
    pub same_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeCurve<'a> = Id<EdgeCurve_<'a>>;
impl<'a> FromEntity<'a> for EdgeCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EdgeCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EdgeCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EDGE_CURVE(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        let (s, edge_start) = param::<Vertex<'a>>(false, s)?;
        let (s, edge_end) = param::<Vertex<'a>>(false, s)?;
        let (s, edge_geometry) = param::<Curve<'a>>(false, s)?;
        let (s, same_sense) = param::<bool>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            edge_start,
            edge_end,
            edge_geometry,
            same_sense,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct EdgeLoop_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub edge_list: Vec<OrientedEdge<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeLoop<'a> = Id<EdgeLoop_<'a>>;
impl<'a> FromEntity<'a> for EdgeLoop_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EdgeLoop(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EdgeLoop_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EDGE_LOOP(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        let (s, edge_list) = param::<Vec<OrientedEdge<'a>>>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            edge_list,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EdgeRound_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeRound<'a> = Id<EdgeRound_<'a>>;
impl<'a> FromEntity<'a> for EdgeRound_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EdgeRound(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EdgeRound_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EDGE_ROUND(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Effectivity_<'a> { // entity
    pub id: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Effectivity<'a> = Id<Effectivity_<'a>>;
impl<'a> FromEntity<'a> for Effectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Effectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Effectivity_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EFFECTIVITY(")(s)?;
        let (s, id) = param::<Identifier<'a>>(true, s)?;
        Ok((s, Self {
            id,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityAssignment<'a> = Id<EffectivityAssignment_<'a>>;
impl<'a> FromEntity<'a> for EffectivityAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EffectivityAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EffectivityAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EFFECTIVITY_ASSIGNMENT(")(s)?;
        let (s, assigned_effectivity) = param::<Effectivity<'a>>(true, s)?;
        Ok((s, Self {
            assigned_effectivity,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EffectivityContextAssignment_<'a> { // entity
    pub assigned_effectivity_assignment: EffectivityAssignment<'a>,
    pub role: EffectivityContextRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityContextAssignment<'a> = Id<EffectivityContextAssignment_<'a>>;
impl<'a> FromEntity<'a> for EffectivityContextAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EffectivityContextAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EffectivityContextAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EFFECTIVITY_CONTEXT_ASSIGNMENT(")(s)?;
        let (s, assigned_effectivity_assignment) = param::<EffectivityAssignment<'a>>(false, s)?;
        let (s, role) = param::<EffectivityContextRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_effectivity_assignment,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EffectivityContextRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityContextRole<'a> = Id<EffectivityContextRole_<'a>>;
impl<'a> FromEntity<'a> for EffectivityContextRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EffectivityContextRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EffectivityContextRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EFFECTIVITY_CONTEXT_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EffectivityItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type EffectivityItem<'a> = Id<EffectivityItem_<'a>>;

#[derive(Debug)]
pub struct EffectivityRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub related_effectivity: Effectivity<'a>,
    pub relating_effectivity: Effectivity<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityRelationship<'a> = Id<EffectivityRelationship_<'a>>;
impl<'a> FromEntity<'a> for EffectivityRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EffectivityRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EffectivityRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EFFECTIVITY_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, related_effectivity) = param::<Effectivity<'a>>(false, s)?;
        let (s, relating_effectivity) = param::<Effectivity<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            related_effectivity,
            relating_effectivity,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ElectricCurrentMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ElectricCurrentMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct ElectricCurrentMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElectricCurrentMeasureWithUnit<'a> = Id<ElectricCurrentMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for ElectricCurrentMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ElectricCurrentMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ElectricCurrentMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ELECTRIC_CURRENT_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ElectricCurrentUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElectricCurrentUnit<'a> = Id<ElectricCurrentUnit_<'a>>;
impl<'a> FromEntity<'a> for ElectricCurrentUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ElectricCurrentUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ElectricCurrentUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ELECTRIC_CURRENT_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ElementDelivery_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElementDelivery<'a> = Id<ElementDelivery_<'a>>;
impl<'a> FromEntity<'a> for ElementDelivery_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ElementDelivery(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ElementDelivery_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ELEMENT_DELIVERY(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, chosen_method) = param::<ActionMethod<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ElementarySurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElementarySurface<'a> = Id<ElementarySurface_<'a>>;
impl<'a> FromEntity<'a> for ElementarySurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ElementarySurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ElementarySurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ELEMENTARY_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement3d<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Ellipse_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub semi_axis_1: PositiveLengthMeasure<'a>,
    pub semi_axis_2: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Ellipse<'a> = Id<Ellipse_<'a>>;
impl<'a> FromEntity<'a> for Ellipse_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Ellipse(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Ellipse_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ELLIPSE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, semi_axis_1) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, semi_axis_2) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            semi_axis_1,
            semi_axis_2,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Environment_<'a> { // entity
    pub syntactic_representation: GenericVariable<'a>,
    pub semantics: VariableSemantics<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Environment<'a> = Id<Environment_<'a>>;
impl<'a> FromEntity<'a> for Environment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Environment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Environment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ENVIRONMENT(")(s)?;
        let (s, syntactic_representation) = param::<GenericVariable<'a>>(false, s)?;
        let (s, semantics) = param::<VariableSemantics<'a>>(true, s)?;
        Ok((s, Self {
            syntactic_representation,
            semantics,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EqualsExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EqualsExpression<'a> = Id<EqualsExpression_<'a>>;
impl<'a> FromEntity<'a> for EqualsExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EqualsExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EqualsExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EQUALS_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EvaluatedDegeneratePcurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    pub equivalent_point: CartesianPoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EvaluatedDegeneratePcurve<'a> = Id<EvaluatedDegeneratePcurve_<'a>>;
impl<'a> FromEntity<'a> for EvaluatedDegeneratePcurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EvaluatedDegeneratePcurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EvaluatedDegeneratePcurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EVALUATED_DEGENERATE_PCURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, basis_surface) = param::<Surface<'a>>(false, s)?;
        let (s, reference_to_curve) = param::<DefinitionalRepresentation<'a>>(false, s)?;
        let (s, equivalent_point) = param::<CartesianPoint<'a>>(true, s)?;
        Ok((s, Self {
            name,
            basis_surface,
            reference_to_curve,
            equivalent_point,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EventOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrence<'a> = Id<EventOccurrence_<'a>>;
impl<'a> FromEntity<'a> for EventOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EventOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EventOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EVENT_OCCURRENCE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EventOccurrenceAssignment_<'a> { // entity
    pub assigned_event_occurrence: EventOccurrence<'a>,
    pub role: EventOccurrenceRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceAssignment<'a> = Id<EventOccurrenceAssignment_<'a>>;
impl<'a> FromEntity<'a> for EventOccurrenceAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EventOccurrenceAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EventOccurrenceAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EVENT_OCCURRENCE_ASSIGNMENT(")(s)?;
        let (s, assigned_event_occurrence) = param::<EventOccurrence<'a>>(false, s)?;
        let (s, role) = param::<EventOccurrenceRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_event_occurrence,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EventOccurrenceContextAssignment_<'a> { // entity
    pub assigned_event_occurrence_assignment: EventOccurrenceAssignment<'a>,
    pub role: EventOccurrenceContextRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceContextAssignment<'a> = Id<EventOccurrenceContextAssignment_<'a>>;
impl<'a> FromEntity<'a> for EventOccurrenceContextAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EventOccurrenceContextAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EventOccurrenceContextAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EVENT_OCCURRENCE_CONTEXT_ASSIGNMENT(")(s)?;
        let (s, assigned_event_occurrence_assignment) = param::<EventOccurrenceAssignment<'a>>(false, s)?;
        let (s, role) = param::<EventOccurrenceContextRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_event_occurrence_assignment,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EventOccurrenceContextRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceContextRole<'a> = Id<EventOccurrenceContextRole_<'a>>;
impl<'a> FromEntity<'a> for EventOccurrenceContextRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EventOccurrenceContextRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EventOccurrenceContextRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EVENT_OCCURRENCE_CONTEXT_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct EventOccurrenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type EventOccurrenceItem<'a> = Id<EventOccurrenceItem_<'a>>;

#[derive(Debug)]
pub struct EventOccurrenceRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceRole<'a> = Id<EventOccurrenceRole_<'a>>;
impl<'a> FromEntity<'a> for EventOccurrenceRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EventOccurrenceRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for EventOccurrenceRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EVENT_OCCURRENCE_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExclusiveProductConceptFeatureCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExclusiveProductConceptFeatureCategory<'a> = Id<ExclusiveProductConceptFeatureCategory_<'a>>;
impl<'a> FromEntity<'a> for ExclusiveProductConceptFeatureCategory_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExclusiveProductConceptFeatureCategory(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExclusiveProductConceptFeatureCategory_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXCLUSIVE_PRODUCT_CONCEPT_FEATURE_CATEGORY(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExecutedAction_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExecutedAction<'a> = Id<ExecutedAction_<'a>>;
impl<'a> FromEntity<'a> for ExecutedAction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExecutedAction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExecutedAction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXECUTED_ACTION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, chosen_method) = param::<ActionMethod<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExpFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExpFunction<'a> = Id<ExpFunction_<'a>>;
impl<'a> FromEntity<'a> for ExpFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExpFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExpFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXP_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Expression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Expression<'a> = Id<Expression_<'a>>;
impl<'a> FromEntity<'a> for Expression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Expression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Expression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXPRESSION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExpressionConversionBasedUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExpressionConversionBasedUnit<'a> = Id<ExpressionConversionBasedUnit_<'a>>;
impl<'a> FromEntity<'a> for ExpressionConversionBasedUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExpressionConversionBasedUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExpressionConversionBasedUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXPRESSION_CONVERSION_BASED_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Extension_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Extension<'a> = Id<Extension_<'a>>;
impl<'a> FromEntity<'a> for Extension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Extension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Extension_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTENSION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternalIdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternalIdentificationAssignment<'a> = Id<ExternalIdentificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for ExternalIdentificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternalIdentificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternalIdentificationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNAL_IDENTIFICATION_ASSIGNMENT(")(s)?;
        let (s, assigned_id) = param::<Identifier<'a>>(false, s)?;
        let (s, role) = param::<IdentificationRole<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(true, s)?;
        Ok((s, Self {
            assigned_id,
            role,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternalIdentificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ExternalIdentificationItem<'a> = Id<ExternalIdentificationItem_<'a>>;

#[derive(Debug)]
pub struct ExternalSource_<'a> { // entity
    pub source_id: SourceItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternalSource<'a> = Id<ExternalSource_<'a>>;
impl<'a> FromEntity<'a> for ExternalSource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternalSource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternalSource_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNAL_SOURCE(")(s)?;
        let (s, source_id) = param::<SourceItem<'a>>(true, s)?;
        Ok((s, Self {
            source_id,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedCharacterGlyph_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedCharacterGlyph<'a> = Id<ExternallyDefinedCharacterGlyph_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedCharacterGlyph_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedCharacterGlyph(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedCharacterGlyph_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_CHARACTER_GLYPH(")(s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(true, s)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedClass_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedClass<'a> = Id<ExternallyDefinedClass_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedClass_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedClass(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedClass_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_CLASS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedCurveFont_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedCurveFont<'a> = Id<ExternallyDefinedCurveFont_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedCurveFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedCurveFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedCurveFont_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_CURVE_FONT(")(s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(true, s)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedDimensionDefinition_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedDimensionDefinition<'a> = Id<ExternallyDefinedDimensionDefinition_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedDimensionDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedDimensionDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedDimensionDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_DIMENSION_DEFINITION(")(s)?;
        let (s, applies_to) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(true, s)?;
        Ok((s, Self {
            applies_to,
            name,
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedFeatureDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedFeatureDefinition<'a> = Id<ExternallyDefinedFeatureDefinition_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedFeatureDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedFeatureDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedFeatureDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_FEATURE_DEFINITION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedGeneralProperty_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedGeneralProperty<'a> = Id<ExternallyDefinedGeneralProperty_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedGeneralProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedGeneralProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedGeneralProperty_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_GENERAL_PROPERTY(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedHatchStyle_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedHatchStyle<'a> = Id<ExternallyDefinedHatchStyle_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedHatchStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedHatchStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedHatchStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_HATCH_STYLE(")(s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            item_id,
            source,
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedItem_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedItem<'a> = Id<ExternallyDefinedItem_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_ITEM(")(s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(true, s)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedItemRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_item: ExternallyDefinedItem<'a>,
    pub related_item: ExternallyDefinedItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedItemRelationship<'a> = Id<ExternallyDefinedItemRelationship_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedItemRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedItemRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedItemRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_ITEM_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_item) = param::<ExternallyDefinedItem<'a>>(false, s)?;
        let (s, related_item) = param::<ExternallyDefinedItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_item,
            related_item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedStyle_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedStyle<'a> = Id<ExternallyDefinedStyle_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_STYLE(")(s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(true, s)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedSymbol_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedSymbol<'a> = Id<ExternallyDefinedSymbol_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_SYMBOL(")(s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(true, s)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedTextFont_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedTextFont<'a> = Id<ExternallyDefinedTextFont_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedTextFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedTextFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedTextFont_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_TEXT_FONT(")(s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(true, s)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedTileStyle_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedTileStyle<'a> = Id<ExternallyDefinedTileStyle_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedTileStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedTileStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExternallyDefinedTileStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTERNALLY_DEFINED_TILE_STYLE(")(s)?;
        let (s, item_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, source) = param::<ExternalSource<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            item_id,
            source,
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExtrudedAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub extruded_direction: Direction<'a>,
    pub depth: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExtrudedAreaSolid<'a> = Id<ExtrudedAreaSolid_<'a>>;
impl<'a> FromEntity<'a> for ExtrudedAreaSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExtrudedAreaSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExtrudedAreaSolid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTRUDED_AREA_SOLID(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, swept_area) = param::<CurveBoundedSurface<'a>>(false, s)?;
        let (s, extruded_direction) = param::<Direction<'a>>(false, s)?;
        let (s, depth) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            swept_area,
            extruded_direction,
            depth,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ExtrudedFaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_face: FaceSurface<'a>,
    pub extruded_direction: Direction<'a>,
    pub depth: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExtrudedFaceSolid<'a> = Id<ExtrudedFaceSolid_<'a>>;
impl<'a> FromEntity<'a> for ExtrudedFaceSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExtrudedFaceSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ExtrudedFaceSolid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("EXTRUDED_FACE_SOLID(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, swept_face) = param::<FaceSurface<'a>>(false, s)?;
        let (s, extruded_direction) = param::<Direction<'a>>(false, s)?;
        let (s, depth) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            swept_face,
            extruded_direction,
            depth,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Face_<'a> { // entity
    pub name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Face<'a> = Id<Face_<'a>>;
impl<'a> FromEntity<'a> for Face_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Face(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Face_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, bounds) = param::<Vec<FaceBound<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            bounds,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FaceBasedSurfaceModel_<'a> { // entity
    pub name: Label<'a>,
    pub fbsm_faces: Vec<ConnectedFaceSet<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceBasedSurfaceModel<'a> = Id<FaceBasedSurfaceModel_<'a>>;
impl<'a> FromEntity<'a> for FaceBasedSurfaceModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FaceBasedSurfaceModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FaceBasedSurfaceModel_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FACE_BASED_SURFACE_MODEL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, fbsm_faces) = param::<Vec<ConnectedFaceSet<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            fbsm_faces,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FaceBound_<'a> { // entity
    pub name: Label<'a>,
    pub bound: Loop<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceBound<'a> = Id<FaceBound_<'a>>;
impl<'a> FromEntity<'a> for FaceBound_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FaceBound(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FaceBound_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FACE_BOUND(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, bound) = param::<Loop<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            bound,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FaceOuterBound_<'a> { // entity
    pub name: Label<'a>,
    pub bound: Loop<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceOuterBound<'a> = Id<FaceOuterBound_<'a>>;
impl<'a> FromEntity<'a> for FaceOuterBound_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FaceOuterBound(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FaceOuterBound_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FACE_OUTER_BOUND(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, bound) = param::<Loop<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            bound,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceShapeRepresentation<'a> = Id<FaceShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for FaceShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FaceShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FaceShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FACE_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct FaceSurface_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    pub face_geometry: Surface<'a>,
    pub same_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceSurface<'a> = Id<FaceSurface_<'a>>;
impl<'a> FromEntity<'a> for FaceSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FaceSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FaceSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FACE_SURFACE(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        let (s, bounds) = param::<Vec<FaceBound<'a>>>(false, s)?;
        let (s, face_geometry) = param::<Surface<'a>>(false, s)?;
        let (s, same_sense) = param::<bool>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            bounds,
            face_geometry,
            same_sense,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FacetedBrep_<'a> { // entity
    pub name: Label<'a>,
    pub outer: ClosedShell<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FacetedBrep<'a> = Id<FacetedBrep_<'a>>;
impl<'a> FromEntity<'a> for FacetedBrep_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FacetedBrep(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FacetedBrep_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FACETED_BREP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, outer) = param::<ClosedShell<'a>>(true, s)?;
        Ok((s, Self {
            name,
            outer,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FacetedBrepShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FacetedBrepShapeRepresentation<'a> = Id<FacetedBrepShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for FacetedBrepShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FacetedBrepShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FacetedBrepShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FACETED_BREP_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FeatureComponentDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureComponentDefinition<'a> = Id<FeatureComponentDefinition_<'a>>;
impl<'a> FromEntity<'a> for FeatureComponentDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeatureComponentDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FeatureComponentDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FEATURE_COMPONENT_DEFINITION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FeatureComponentRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureComponentRelationship<'a> = Id<FeatureComponentRelationship_<'a>>;
impl<'a> FromEntity<'a> for FeatureComponentRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeatureComponentRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FeatureComponentRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FEATURE_COMPONENT_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FeatureDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureDefinition<'a> = Id<FeatureDefinition_<'a>>;
impl<'a> FromEntity<'a> for FeatureDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeatureDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FeatureDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FEATURE_DEFINITION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FeatureInPanel_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureInPanel<'a> = Id<FeatureInPanel_<'a>>;
impl<'a> FromEntity<'a> for FeatureInPanel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeatureInPanel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FeatureInPanel_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FEATURE_IN_PANEL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FeaturePattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeaturePattern<'a> = Id<FeaturePattern_<'a>>;
impl<'a> FromEntity<'a> for FeaturePattern_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeaturePattern(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FeaturePattern_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FEATURE_PATTERN(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FeaturedShape_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeaturedShape<'a> = Id<FeaturedShape_<'a>>;
impl<'a> FromEntity<'a> for FeaturedShape_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeaturedShape(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FeaturedShape_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FEATURED_SHAPE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, definition) = param::<CharacterizedDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            definition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FillAreaStyle_<'a> { // entity
    pub name: Label<'a>,
    pub fill_styles: Vec<FillStyleSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyle<'a> = Id<FillAreaStyle_<'a>>;
impl<'a> FromEntity<'a> for FillAreaStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FillAreaStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FillAreaStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FILL_AREA_STYLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, fill_styles) = param::<Vec<FillStyleSelect<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            fill_styles,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FillAreaStyleColour_<'a> { // entity
    pub name: Label<'a>,
    pub fill_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleColour<'a> = Id<FillAreaStyleColour_<'a>>;
impl<'a> FromEntity<'a> for FillAreaStyleColour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FillAreaStyleColour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FillAreaStyleColour_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FILL_AREA_STYLE_COLOUR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, fill_colour) = param::<Colour<'a>>(true, s)?;
        Ok((s, Self {
            name,
            fill_colour,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FillAreaStyleHatching_<'a> { // entity
    pub name: Label<'a>,
    pub hatch_line_appearance: CurveStyle<'a>,
    pub start_of_next_hatch_line: OneDirectionRepeatFactor<'a>,
    pub point_of_reference_hatch_line: CartesianPoint<'a>,
    pub pattern_start: CartesianPoint<'a>,
    pub hatch_line_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleHatching<'a> = Id<FillAreaStyleHatching_<'a>>;
impl<'a> FromEntity<'a> for FillAreaStyleHatching_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FillAreaStyleHatching(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FillAreaStyleHatching_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FILL_AREA_STYLE_HATCHING(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, hatch_line_appearance) = param::<CurveStyle<'a>>(false, s)?;
        let (s, start_of_next_hatch_line) = param::<OneDirectionRepeatFactor<'a>>(false, s)?;
        let (s, point_of_reference_hatch_line) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, pattern_start) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, hatch_line_angle) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            hatch_line_appearance,
            start_of_next_hatch_line,
            point_of_reference_hatch_line,
            pattern_start,
            hatch_line_angle,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FillAreaStyleTileShapeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FillAreaStyleTileShapeSelect<'a> = Id<FillAreaStyleTileShapeSelect_<'a>>;

#[derive(Debug)]
pub struct FillAreaStyleTileSymbolWithStyle_<'a> { // entity
    pub name: Label<'a>,
    pub symbol: AnnotationSymbolOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleTileSymbolWithStyle<'a> = Id<FillAreaStyleTileSymbolWithStyle_<'a>>;
impl<'a> FromEntity<'a> for FillAreaStyleTileSymbolWithStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FillAreaStyleTileSymbolWithStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FillAreaStyleTileSymbolWithStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FILL_AREA_STYLE_TILE_SYMBOL_WITH_STYLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, symbol) = param::<AnnotationSymbolOccurrence<'a>>(true, s)?;
        Ok((s, Self {
            name,
            symbol,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FillAreaStyleTiles_<'a> { // entity
    pub name: Label<'a>,
    pub tiling_pattern: TwoDirectionRepeatFactor<'a>,
    pub tiles: Vec<FillAreaStyleTileShapeSelect<'a>>,
    pub tiling_scale: PositiveRatioMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleTiles<'a> = Id<FillAreaStyleTiles_<'a>>;
impl<'a> FromEntity<'a> for FillAreaStyleTiles_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FillAreaStyleTiles(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FillAreaStyleTiles_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FILL_AREA_STYLE_TILES(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, tiling_pattern) = param::<TwoDirectionRepeatFactor<'a>>(false, s)?;
        let (s, tiles) = param::<Vec<FillAreaStyleTileShapeSelect<'a>>>(false, s)?;
        let (s, tiling_scale) = param::<PositiveRatioMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            tiling_pattern,
            tiles,
            tiling_scale,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FillStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FillStyleSelect<'a> = Id<FillStyleSelect_<'a>>;

#[derive(Debug)]
pub struct Fillet_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Fillet<'a> = Id<Fillet_<'a>>;
impl<'a> FromEntity<'a> for Fillet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Fillet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Fillet_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FILLET(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FlatnessTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FlatnessTolerance<'a> = Id<FlatnessTolerance_<'a>>;
impl<'a> FromEntity<'a> for FlatnessTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FlatnessTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FlatnessTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FLATNESS_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FontSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FontSelect<'a> = Id<FontSelect_<'a>>;

#[derive(Debug)]
pub struct FormatFunction_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FormatFunction<'a> = Id<FormatFunction_<'a>>;
impl<'a> FromEntity<'a> for FormatFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FormatFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FormatFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FORMAT_FUNCTION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FoundedItem_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FoundedItem<'a> = Id<FoundedItem_<'a>>;
impl<'a> FromEntity<'a> for FoundedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FoundedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FoundedItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FOUNDED_ITEM(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FoundedItemSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FoundedItemSelect<'a> = Id<FoundedItemSelect_<'a>>;

#[derive(Debug)]
pub struct FoundedKinematicPath_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FoundedKinematicPath<'a> = Id<FoundedKinematicPath_<'a>>;
impl<'a> FromEntity<'a> for FoundedKinematicPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FoundedKinematicPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FoundedKinematicPath_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FOUNDED_KINEMATIC_PATH(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FullyConstrainedPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FullyConstrainedPair<'a> = Id<FullyConstrainedPair_<'a>>;
impl<'a> FromEntity<'a> for FullyConstrainedPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FullyConstrainedPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FullyConstrainedPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FULLY_CONSTRAINED_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct FunctionallyDefinedTransformation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FunctionallyDefinedTransformation<'a> = Id<FunctionallyDefinedTransformation_<'a>>;
impl<'a> FromEntity<'a> for FunctionallyDefinedTransformation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FunctionallyDefinedTransformation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for FunctionallyDefinedTransformation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("FUNCTIONALLY_DEFINED_TRANSFORMATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GearPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub radius_first_link: LengthMeasure<'a>,
    pub radius_second_link: LengthMeasure<'a>,
    pub bevel: PlaneAngleMeasure<'a>,
    pub helical_angle: PlaneAngleMeasure<'a>,
    pub gear_ratio: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GearPair<'a> = Id<GearPair_<'a>>;
impl<'a> FromEntity<'a> for GearPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GearPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GearPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEAR_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, radius_first_link) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, radius_second_link) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, bevel) = param::<PlaneAngleMeasure<'a>>(false, s)?;
        let (s, helical_angle) = param::<PlaneAngleMeasure<'a>>(false, s)?;
        let (s, gear_ratio) = param::<f64>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            radius_first_link,
            radius_second_link,
            bevel,
            helical_angle,
            gear_ratio,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GearPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation_1: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation_1: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GearPairRange<'a> = Id<GearPairRange_<'a>>;
impl<'a> FromEntity<'a> for GearPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GearPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GearPairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEAR_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, lower_limit_actual_rotation_1) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_actual_rotation_1) = param::<RotationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_rotation_1,
            upper_limit_actual_rotation_1,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GearPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation_1: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GearPairValue<'a> = Id<GearPairValue_<'a>>;
impl<'a> FromEntity<'a> for GearPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GearPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GearPairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEAR_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_rotation_1) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_rotation_1,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeneralFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralFeature<'a> = Id<GeneralFeature_<'a>>;
impl<'a> FromEntity<'a> for GeneralFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeneralFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeneralFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GENERAL_FEATURE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeneralMaterialProperty_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralMaterialProperty<'a> = Id<GeneralMaterialProperty_<'a>>;
impl<'a> FromEntity<'a> for GeneralMaterialProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeneralMaterialProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeneralMaterialProperty_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GENERAL_MATERIAL_PROPERTY(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeneralProperty_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralProperty<'a> = Id<GeneralProperty_<'a>>;
impl<'a> FromEntity<'a> for GeneralProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeneralProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeneralProperty_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GENERAL_PROPERTY(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeneralPropertyAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub base_definition: GeneralProperty<'a>,
    pub derived_definition: DerivedPropertySelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralPropertyAssociation<'a> = Id<GeneralPropertyAssociation_<'a>>;
impl<'a> FromEntity<'a> for GeneralPropertyAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeneralPropertyAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeneralPropertyAssociation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GENERAL_PROPERTY_ASSOCIATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, base_definition) = param::<GeneralProperty<'a>>(false, s)?;
        let (s, derived_definition) = param::<DerivedPropertySelect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            base_definition,
            derived_definition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeneralPropertyRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_property: GeneralProperty<'a>,
    pub related_property: GeneralProperty<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralPropertyRelationship<'a> = Id<GeneralPropertyRelationship_<'a>>;
impl<'a> FromEntity<'a> for GeneralPropertyRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeneralPropertyRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeneralPropertyRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GENERAL_PROPERTY_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_property) = param::<GeneralProperty<'a>>(false, s)?;
        let (s, related_property) = param::<GeneralProperty<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_property,
            related_property,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GenericCharacterGlyphSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericCharacterGlyphSymbol<'a> = Id<GenericCharacterGlyphSymbol_<'a>>;
impl<'a> FromEntity<'a> for GenericCharacterGlyphSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GenericCharacterGlyphSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GenericCharacterGlyphSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GENERIC_CHARACTER_GLYPH_SYMBOL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GenericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericExpression<'a> = Id<GenericExpression_<'a>>;
impl<'a> FromEntity<'a> for GenericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GenericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GenericExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GENERIC_EXPRESSION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GenericLiteral_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericLiteral<'a> = Id<GenericLiteral_<'a>>;
impl<'a> FromEntity<'a> for GenericLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GenericLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GenericLiteral_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GENERIC_LITERAL(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GenericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericVariable<'a> = Id<GenericVariable_<'a>>;
impl<'a> FromEntity<'a> for GenericVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GenericVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GenericVariable_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GENERIC_VARIABLE(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricAlignment_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricAlignment<'a> = Id<GeometricAlignment_<'a>>;
impl<'a> FromEntity<'a> for GeometricAlignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricAlignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricAlignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRIC_ALIGNMENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricCurveSet_<'a> { // entity
    pub name: Label<'a>,
    pub elements: Vec<GeometricSetSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricCurveSet<'a> = Id<GeometricCurveSet_<'a>>;
impl<'a> FromEntity<'a> for GeometricCurveSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricCurveSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricCurveSet_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRIC_CURVE_SET(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, elements) = param::<Vec<GeometricSetSelect<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            elements,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricIntersection_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricIntersection<'a> = Id<GeometricIntersection_<'a>>;
impl<'a> FromEntity<'a> for GeometricIntersection_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricIntersection(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricIntersection_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRIC_INTERSECTION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricItemSpecificUsage_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub identified_item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricItemSpecificUsage<'a> = Id<GeometricItemSpecificUsage_<'a>>;
impl<'a> FromEntity<'a> for GeometricItemSpecificUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricItemSpecificUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricItemSpecificUsage_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRIC_ITEM_SPECIFIC_USAGE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, definition) = param::<RepresentedDefinition<'a>>(false, s)?;
        let (s, used_representation) = param::<Representation<'a>>(false, s)?;
        let (s, identified_item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            definition,
            used_representation,
            identified_item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricRepresentationContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    pub coordinate_space_dimension: DimensionCount<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricRepresentationContext<'a> = Id<GeometricRepresentationContext_<'a>>;
impl<'a> FromEntity<'a> for GeometricRepresentationContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricRepresentationContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricRepresentationContext_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRIC_REPRESENTATION_CONTEXT(")(s)?;
        let (s, context_identifier) = param::<Identifier<'a>>(false, s)?;
        let (s, context_type) = param::<Text<'a>>(false, s)?;
        let (s, coordinate_space_dimension) = param::<DimensionCount<'a>>(true, s)?;
        Ok((s, Self {
            context_identifier,
            context_type,
            coordinate_space_dimension,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricRepresentationItem<'a> = Id<GeometricRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for GeometricRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricRepresentationItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRIC_REPRESENTATION_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricSet_<'a> { // entity
    pub name: Label<'a>,
    pub elements: Vec<GeometricSetSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricSet<'a> = Id<GeometricSet_<'a>>;
impl<'a> FromEntity<'a> for GeometricSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricSet_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRIC_SET(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, elements) = param::<Vec<GeometricSetSelect<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            elements,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricSetSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type GeometricSetSelect<'a> = Id<GeometricSetSelect_<'a>>;

#[derive(Debug)]
pub struct GeometricTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricTolerance<'a> = Id<GeometricTolerance_<'a>>;
impl<'a> FromEntity<'a> for GeometricTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRIC_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricToleranceRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_geometric_tolerance: GeometricTolerance<'a>,
    pub related_geometric_tolerance: GeometricTolerance<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricToleranceRelationship<'a> = Id<GeometricToleranceRelationship_<'a>>;
impl<'a> FromEntity<'a> for GeometricToleranceRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricToleranceRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricToleranceRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRIC_TOLERANCE_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, relating_geometric_tolerance) = param::<GeometricTolerance<'a>>(false, s)?;
        let (s, related_geometric_tolerance) = param::<GeometricTolerance<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_geometric_tolerance,
            related_geometric_tolerance,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricToleranceWithDatumReference_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricToleranceWithDatumReference<'a> = Id<GeometricToleranceWithDatumReference_<'a>>;
impl<'a> FromEntity<'a> for GeometricToleranceWithDatumReference_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricToleranceWithDatumReference(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricToleranceWithDatumReference_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, datum_system) = param::<Vec<DatumReference<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricToleranceWithDefinedUnit_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub unit_size: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricToleranceWithDefinedUnit<'a> = Id<GeometricToleranceWithDefinedUnit_<'a>>;
impl<'a> FromEntity<'a> for GeometricToleranceWithDefinedUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricToleranceWithDefinedUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricToleranceWithDefinedUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRIC_TOLERANCE_WITH_DEFINED_UNIT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, unit_size) = param::<MeasureWithUnit<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            unit_size,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricalToleranceCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricalToleranceCallout<'a> = Id<GeometricalToleranceCallout_<'a>>;
impl<'a> FromEntity<'a> for GeometricalToleranceCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricalToleranceCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricalToleranceCallout_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRICAL_TOLERANCE_CALLOUT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricallyBounded2dWireframeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricallyBounded2dWireframeRepresentation<'a> = Id<GeometricallyBounded2dWireframeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for GeometricallyBounded2dWireframeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricallyBounded2dWireframeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricallyBounded2dWireframeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricallyBoundedSurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricallyBoundedSurfaceShapeRepresentation<'a> = Id<GeometricallyBoundedSurfaceShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for GeometricallyBoundedSurfaceShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricallyBoundedSurfaceShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricallyBoundedSurfaceShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GeometricallyBoundedWireframeShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricallyBoundedWireframeShapeRepresentation<'a> = Id<GeometricallyBoundedWireframeShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for GeometricallyBoundedWireframeShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricallyBoundedWireframeShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GeometricallyBoundedWireframeShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GlobalUncertaintyAssignedContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    pub uncertainty: Vec<UncertaintyMeasureWithUnit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GlobalUncertaintyAssignedContext<'a> = Id<GlobalUncertaintyAssignedContext_<'a>>;
impl<'a> FromEntity<'a> for GlobalUncertaintyAssignedContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GlobalUncertaintyAssignedContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GlobalUncertaintyAssignedContext_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT(")(s)?;
        let (s, context_identifier) = param::<Identifier<'a>>(false, s)?;
        let (s, context_type) = param::<Text<'a>>(false, s)?;
        let (s, uncertainty) = param::<Vec<UncertaintyMeasureWithUnit<'a>>>(true, s)?;
        Ok((s, Self {
            context_identifier,
            context_type,
            uncertainty,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GlobalUnitAssignedContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    pub units: Vec<Unit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GlobalUnitAssignedContext<'a> = Id<GlobalUnitAssignedContext_<'a>>;
impl<'a> FromEntity<'a> for GlobalUnitAssignedContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GlobalUnitAssignedContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GlobalUnitAssignedContext_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GLOBAL_UNIT_ASSIGNED_CONTEXT(")(s)?;
        let (s, context_identifier) = param::<Identifier<'a>>(false, s)?;
        let (s, context_type) = param::<Text<'a>>(false, s)?;
        let (s, units) = param::<Vec<Unit<'a>>>(true, s)?;
        Ok((s, Self {
            context_identifier,
            context_type,
            units,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Group_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Group<'a> = Id<Group_<'a>>;
impl<'a> FromEntity<'a> for Group_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Group(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Group_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GROUP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GroupAssignment_<'a> { // entity
    pub assigned_group: Group<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GroupAssignment<'a> = Id<GroupAssignment_<'a>>;
impl<'a> FromEntity<'a> for GroupAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GroupAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GroupAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GROUP_ASSIGNMENT(")(s)?;
        let (s, assigned_group) = param::<Group<'a>>(true, s)?;
        Ok((s, Self {
            assigned_group,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct GroupItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type GroupItem<'a> = Id<GroupItem_<'a>>;

#[derive(Debug)]
pub struct GroupRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_group: Group<'a>,
    pub related_group: Group<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GroupRelationship<'a> = Id<GroupRelationship_<'a>>;
impl<'a> FromEntity<'a> for GroupRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GroupRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for GroupRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("GROUP_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_group) = param::<Group<'a>>(false, s)?;
        let (s, related_group) = param::<Group<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_group,
            related_group,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct HalfSpaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub base_surface: Surface<'a>,
    pub agreement_flag: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HalfSpaceSolid<'a> = Id<HalfSpaceSolid_<'a>>;
impl<'a> FromEntity<'a> for HalfSpaceSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HalfSpaceSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for HalfSpaceSolid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("HALF_SPACE_SOLID(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, base_surface) = param::<Surface<'a>>(false, s)?;
        let (s, agreement_flag) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            base_surface,
            agreement_flag,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct HardnessRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HardnessRepresentation<'a> = Id<HardnessRepresentation_<'a>>;
impl<'a> FromEntity<'a> for HardnessRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HardnessRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for HardnessRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("HARDNESS_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct HiddenElementOverRidingStyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub over_ridden_style: StyledItem<'a>,
    pub style_context: Vec<StyleContextSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HiddenElementOverRidingStyledItem<'a> = Id<HiddenElementOverRidingStyledItem_<'a>>;
impl<'a> FromEntity<'a> for HiddenElementOverRidingStyledItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HiddenElementOverRidingStyledItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for HiddenElementOverRidingStyledItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("HIDDEN_ELEMENT_OVER_RIDING_STYLED_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, over_ridden_style) = param::<StyledItem<'a>>(false, s)?;
        let (s, style_context) = param::<Vec<StyleContextSelect<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            over_ridden_style,
            style_context,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct HoleBottom_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HoleBottom<'a> = Id<HoleBottom_<'a>>;
impl<'a> FromEntity<'a> for HoleBottom_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HoleBottom(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for HoleBottom_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("HOLE_BOTTOM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct HoleInPanel_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HoleInPanel<'a> = Id<HoleInPanel_<'a>>;
impl<'a> FromEntity<'a> for HoleInPanel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HoleInPanel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for HoleInPanel_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("HOLE_IN_PANEL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct HomokineticPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub input_skew_angle: Option<PlaneAngleMeasure<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HomokineticPair<'a> = Id<HomokineticPair_<'a>>;
impl<'a> FromEntity<'a> for HomokineticPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HomokineticPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for HomokineticPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("HOMOKINETIC_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, input_skew_angle) = param::<Option<PlaneAngleMeasure<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            input_skew_angle,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct HourInDay<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for HourInDay<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct Hyperbola_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub semi_axis: PositiveLengthMeasure<'a>,
    pub semi_imag_axis: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Hyperbola<'a> = Id<Hyperbola_<'a>>;
impl<'a> FromEntity<'a> for Hyperbola_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Hyperbola(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Hyperbola_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("HYPERBOLA(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, semi_axis) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, semi_imag_axis) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            semi_axis,
            semi_imag_axis,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct IdAttribute_<'a> { // entity
    pub attribute_value: Identifier<'a>,
    pub identified_item: IdAttributeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IdAttribute<'a> = Id<IdAttribute_<'a>>;
impl<'a> FromEntity<'a> for IdAttribute_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IdAttribute(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for IdAttribute_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ID_ATTRIBUTE(")(s)?;
        let (s, attribute_value) = param::<Identifier<'a>>(false, s)?;
        let (s, identified_item) = param::<IdAttributeSelect<'a>>(true, s)?;
        Ok((s, Self {
            attribute_value,
            identified_item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct IdAttributeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type IdAttributeSelect<'a> = Id<IdAttributeSelect_<'a>>;

#[derive(Debug)]
pub struct IdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IdentificationAssignment<'a> = Id<IdentificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for IdentificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IdentificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for IdentificationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("IDENTIFICATION_ASSIGNMENT(")(s)?;
        let (s, assigned_id) = param::<Identifier<'a>>(false, s)?;
        let (s, role) = param::<IdentificationRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_id,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct IdentificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type IdentificationItem<'a> = Id<IdentificationItem_<'a>>;

#[derive(Debug)]
pub struct IdentificationRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IdentificationRole<'a> = Id<IdentificationRole_<'a>>;
impl<'a> FromEntity<'a> for IdentificationRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IdentificationRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for IdentificationRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("IDENTIFICATION_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Identifier<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Identifier<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct InclusionProductConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub condition: ConceptFeatureRelationshipWithCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InclusionProductConceptFeature<'a> = Id<InclusionProductConceptFeature_<'a>>;
impl<'a> FromEntity<'a> for InclusionProductConceptFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::InclusionProductConceptFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for InclusionProductConceptFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INCLUSION_PRODUCT_CONCEPT_FEATURE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, condition) = param::<ConceptFeatureRelationshipWithCondition<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            condition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct IndexExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IndexExpression<'a> = Id<IndexExpression_<'a>>;
impl<'a> FromEntity<'a> for IndexExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IndexExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for IndexExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INDEX_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct InitialState_<'a> { // entity
    pub applies_to_mechanism: Mechanism<'a>,
    pub pair_values: Vec<PairValue<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InitialState<'a> = Id<InitialState_<'a>>;
impl<'a> FromEntity<'a> for InitialState_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::InitialState(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for InitialState_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INITIAL_STATE(")(s)?;
        let (s, applies_to_mechanism) = param::<Mechanism<'a>>(false, s)?;
        let (s, pair_values) = param::<Vec<PairValue<'a>>>(true, s)?;
        Ok((s, Self {
            applies_to_mechanism,
            pair_values,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct InstancedFeature_<'a> { // entity
    pub shape_aspect__name: Label<'a>,
    pub shape_aspect__description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InstancedFeature<'a> = Id<InstancedFeature_<'a>>;
impl<'a> FromEntity<'a> for InstancedFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::InstancedFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for InstancedFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INSTANCED_FEATURE(")(s)?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(false, s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            shape_aspect__name,
            shape_aspect__description,
            of_shape,
            product_definitional,
            characterized_object__name,
            characterized_object__description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct IntLiteral_<'a> { // entity
    pub the_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntLiteral<'a> = Id<IntLiteral_<'a>>;
impl<'a> FromEntity<'a> for IntLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for IntLiteral_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INT_LITERAL(")(s)?;
        let (s, the_value) = param::<f64>(true, s)?;
        Ok((s, Self {
            the_value,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct IntNumericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntNumericVariable<'a> = Id<IntNumericVariable_<'a>>;
impl<'a> FromEntity<'a> for IntNumericVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntNumericVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for IntNumericVariable_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INT_NUMERIC_VARIABLE(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct IntValueFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntValueFunction<'a> = Id<IntValueFunction_<'a>>;
impl<'a> FromEntity<'a> for IntValueFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntValueFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for IntValueFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INT_VALUE_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct IntegerDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntegerDefinedFunction<'a> = Id<IntegerDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for IntegerDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntegerDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for IntegerDefinedFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INTEGER_DEFINED_FUNCTION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct InterpolatedConfigurationSequence_<'a> { // entity
    pub interpolation: Vec<ConfigurationInterpolation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InterpolatedConfigurationSequence<'a> = Id<InterpolatedConfigurationSequence_<'a>>;
impl<'a> FromEntity<'a> for InterpolatedConfigurationSequence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::InterpolatedConfigurationSequence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for InterpolatedConfigurationSequence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INTERPOLATED_CONFIGURATION_SEQUENCE(")(s)?;
        let (s, interpolation) = param::<Vec<ConfigurationInterpolation<'a>>>(true, s)?;
        Ok((s, Self {
            interpolation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum InterpolationType<'a> { // enum
    Undefined,
    Synchronous,
    Linear,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for InterpolationType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use InterpolationType::*;
        alt((
            map(tag(".UNDEFINED."), |_| Undefined),
            map(tag(".SYNCHRONOUS."), |_| Synchronous),
            map(tag(".LINEAR."), |_| Linear),
        ))(s)
    }
}
#[derive(Debug)]
pub struct IntersectionCurve_<'a> { // entity
    pub name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: Vec<PcurveOrSurface<'a>>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntersectionCurve<'a> = Id<IntersectionCurve_<'a>>;
impl<'a> FromEntity<'a> for IntersectionCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntersectionCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for IntersectionCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INTERSECTION_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, curve_3d) = param::<Curve<'a>>(false, s)?;
        let (s, associated_geometry) = param::<Vec<PcurveOrSurface<'a>>>(false, s)?;
        let (s, master_representation) = param::<PreferredSurfaceCurveRepresentation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            curve_3d,
            associated_geometry,
            master_representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct IntervalExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntervalExpression<'a> = Id<IntervalExpression_<'a>>;
impl<'a> FromEntity<'a> for IntervalExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntervalExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for IntervalExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INTERVAL_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Invisibility_<'a> { // entity
    pub invisible_items: Vec<InvisibleItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Invisibility<'a> = Id<Invisibility_<'a>>;
impl<'a> FromEntity<'a> for Invisibility_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Invisibility(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Invisibility_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("INVISIBILITY(")(s)?;
        let (s, invisible_items) = param::<Vec<InvisibleItem<'a>>>(true, s)?;
        Ok((s, Self {
            invisible_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct InvisibilityContext_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type InvisibilityContext<'a> = Id<InvisibilityContext_<'a>>;

#[derive(Debug)]
pub struct InvisibleItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type InvisibleItem<'a> = Id<InvisibleItem_<'a>>;

#[derive(Debug)]
pub struct ItemDefinedTransformation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ItemDefinedTransformation<'a> = Id<ItemDefinedTransformation_<'a>>;
impl<'a> FromEntity<'a> for ItemDefinedTransformation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ItemDefinedTransformation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ItemDefinedTransformation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ITEM_DEFINED_TRANSFORMATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ItemIdentifiedRepresentationUsage_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub identified_item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ItemIdentifiedRepresentationUsage<'a> = Id<ItemIdentifiedRepresentationUsage_<'a>>;
impl<'a> FromEntity<'a> for ItemIdentifiedRepresentationUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ItemIdentifiedRepresentationUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ItemIdentifiedRepresentationUsage_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ITEM_IDENTIFIED_REPRESENTATION_USAGE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, definition) = param::<RepresentedDefinition<'a>>(false, s)?;
        let (s, used_representation) = param::<Representation<'a>>(false, s)?;
        let (s, identified_item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            definition,
            used_representation,
            identified_item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Joggle_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Joggle<'a> = Id<Joggle_<'a>>;
impl<'a> FromEntity<'a> for Joggle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Joggle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Joggle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("JOGGLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct JoggleTermination_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type JoggleTermination<'a> = Id<JoggleTermination_<'a>>;
impl<'a> FromEntity<'a> for JoggleTermination_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::JoggleTermination(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for JoggleTermination_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("JOGGLE_TERMINATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicAnalysisConsistency_<'a> { // entity
    pub control: KinematicControl<'a>,
    pub result: KinematicAnalysisResult<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicAnalysisConsistency<'a> = Id<KinematicAnalysisConsistency_<'a>>;
impl<'a> FromEntity<'a> for KinematicAnalysisConsistency_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicAnalysisConsistency(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicAnalysisConsistency_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_ANALYSIS_CONSISTENCY(")(s)?;
        let (s, control) = param::<KinematicControl<'a>>(false, s)?;
        let (s, result) = param::<KinematicAnalysisResult<'a>>(true, s)?;
        Ok((s, Self {
            control,
            result,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicAnalysisDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type KinematicAnalysisDefinition<'a> = Id<KinematicAnalysisDefinition_<'a>>;

#[derive(Debug)]
pub struct KinematicAnalysisResult_<'a> { // entity
    pub analysed_mechanism: Mechanism<'a>,
    pub contained_kinematic_results: Vec<KinematicResult<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicAnalysisResult<'a> = Id<KinematicAnalysisResult_<'a>>;
impl<'a> FromEntity<'a> for KinematicAnalysisResult_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicAnalysisResult(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicAnalysisResult_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_ANALYSIS_RESULT(")(s)?;
        let (s, analysed_mechanism) = param::<Mechanism<'a>>(false, s)?;
        let (s, contained_kinematic_results) = param::<Vec<KinematicResult<'a>>>(true, s)?;
        Ok((s, Self {
            analysed_mechanism,
            contained_kinematic_results,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicControl_<'a> { // entity
    pub controlled_mechanism: Mechanism<'a>,
    pub contained_kinematic_programs: Vec<KinematicAnalysisDefinition<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicControl<'a> = Id<KinematicControl_<'a>>;
impl<'a> FromEntity<'a> for KinematicControl_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicControl(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicControl_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_CONTROL(")(s)?;
        let (s, controlled_mechanism) = param::<Mechanism<'a>>(false, s)?;
        let (s, contained_kinematic_programs) = param::<Vec<KinematicAnalysisDefinition<'a>>>(true, s)?;
        Ok((s, Self {
            controlled_mechanism,
            contained_kinematic_programs,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicFrameBackground_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type KinematicFrameBackground<'a> = Id<KinematicFrameBackground_<'a>>;

#[derive(Debug)]
pub struct KinematicFrameBackgroundRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicFrameBackgroundRepresentation<'a> = Id<KinematicFrameBackgroundRepresentation_<'a>>;
impl<'a> FromEntity<'a> for KinematicFrameBackgroundRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicFrameBackgroundRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicFrameBackgroundRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_FRAME_BACKGROUND_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicFrameBackgroundRepresentationAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub transformation_operator: Transformation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicFrameBackgroundRepresentationAssociation<'a> = Id<KinematicFrameBackgroundRepresentationAssociation_<'a>>;
impl<'a> FromEntity<'a> for KinematicFrameBackgroundRepresentationAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicFrameBackgroundRepresentationAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicFrameBackgroundRepresentationAssociation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_FRAME_BACKGROUND_REPRESENTATION_ASSOCIATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, rep_1) = param::<Representation<'a>>(false, s)?;
        let (s, rep_2) = param::<Representation<'a>>(false, s)?;
        let (s, transformation_operator) = param::<Transformation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            transformation_operator,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct KinematicFrameBasedTransformation_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transformator: RigidPlacement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicFrameBasedTransformation<'a> = Id<KinematicFrameBasedTransformation_<'a>>;
impl<'a> FromEntity<'a> for KinematicFrameBasedTransformation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicFrameBasedTransformation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicFrameBasedTransformation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_FRAME_BASED_TRANSFORMATION(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, functionally_defined_transformation__name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transformator) = param::<RigidPlacement<'a>>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            functionally_defined_transformation__name,
            description,
            transformator,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicGroundRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicGroundRepresentation<'a> = Id<KinematicGroundRepresentation_<'a>>;
impl<'a> FromEntity<'a> for KinematicGroundRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicGroundRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicGroundRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_GROUND_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicJoint_<'a> { // entity
    pub first_link: KinematicLink<'a>,
    pub second_link: KinematicLink<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicJoint<'a> = Id<KinematicJoint_<'a>>;
impl<'a> FromEntity<'a> for KinematicJoint_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicJoint(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicJoint_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_JOINT(")(s)?;
        let (s, first_link) = param::<KinematicLink<'a>>(false, s)?;
        let (s, second_link) = param::<KinematicLink<'a>>(true, s)?;
        Ok((s, Self {
            first_link,
            second_link,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicLink_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLink<'a> = Id<KinematicLink_<'a>>;
impl<'a> FromEntity<'a> for KinematicLink_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicLink(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicLink_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_LINK(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicLinkRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLinkRepresentation<'a> = Id<KinematicLinkRepresentation_<'a>>;
impl<'a> FromEntity<'a> for KinematicLinkRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicLinkRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicLinkRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_LINK_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicLinkRepresentationAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLinkRepresentationAssociation<'a> = Id<KinematicLinkRepresentationAssociation_<'a>>;
impl<'a> FromEntity<'a> for KinematicLinkRepresentationAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicLinkRepresentationAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicLinkRepresentationAssociation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_LINK_REPRESENTATION_ASSOCIATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, rep_1) = param::<Representation<'a>>(false, s)?;
        let (s, rep_2) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicLinkRepresentationRelation_<'a> { // entity
    pub topological_aspects: KinematicLink<'a>,
    pub geometric_aspects: KinematicLinkRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLinkRepresentationRelation<'a> = Id<KinematicLinkRepresentationRelation_<'a>>;
impl<'a> FromEntity<'a> for KinematicLinkRepresentationRelation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicLinkRepresentationRelation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicLinkRepresentationRelation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_LINK_REPRESENTATION_RELATION(")(s)?;
        let (s, topological_aspects) = param::<KinematicLink<'a>>(false, s)?;
        let (s, geometric_aspects) = param::<KinematicLinkRepresentation<'a>>(true, s)?;
        Ok((s, Self {
            topological_aspects,
            geometric_aspects,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPair<'a> = Id<KinematicPair_<'a>>;
impl<'a> FromEntity<'a> for KinematicPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicPath_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPath<'a> = Id<KinematicPath_<'a>>;
impl<'a> FromEntity<'a> for KinematicPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicPath_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_PATH(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicPropertyDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    pub ground_definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPropertyDefinition<'a> = Id<KinematicPropertyDefinition_<'a>>;
impl<'a> FromEntity<'a> for KinematicPropertyDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicPropertyDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicPropertyDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_PROPERTY_DEFINITION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, definition) = param::<CharacterizedDefinition<'a>>(false, s)?;
        let (s, ground_definition) = param::<CharacterizedDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            definition,
            ground_definition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicPropertyRepresentationRelation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPropertyRepresentationRelation<'a> = Id<KinematicPropertyRepresentationRelation_<'a>>;
impl<'a> FromEntity<'a> for KinematicPropertyRepresentationRelation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicPropertyRepresentationRelation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicPropertyRepresentationRelation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_PROPERTY_REPRESENTATION_RELATION(")(s)?;
        let (s, definition) = param::<RepresentedDefinition<'a>>(false, s)?;
        let (s, used_representation) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            definition,
            used_representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct KinematicResult_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type KinematicResult<'a> = Id<KinematicResult_<'a>>;

#[derive(Debug)]
pub struct KinematicStructure_<'a> { // entity
    pub joints: Vec<KinematicJoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicStructure<'a> = Id<KinematicStructure_<'a>>;
impl<'a> FromEntity<'a> for KinematicStructure_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicStructure(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KinematicStructure_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_STRUCTURE(")(s)?;
        let (s, joints) = param::<Vec<KinematicJoint<'a>>>(true, s)?;
        Ok((s, Self {
            joints,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum KnotType<'a> { // enum
    UniformKnots,
    QuasiUniformKnots,
    PiecewiseBezierKnots,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for KnotType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use KnotType::*;
        alt((
            map(tag(".UNIFORM_KNOTS."), |_| UniformKnots),
            map(tag(".QUASI_UNIFORM_KNOTS."), |_| QuasiUniformKnots),
            map(tag(".PIECEWISE_BEZIER_KNOTS."), |_| PiecewiseBezierKnots),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
#[derive(Debug)]
pub struct KnownSource_<'a> { // entity
    pub source_id: SourceItem<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KnownSource<'a> = Id<KnownSource_<'a>>;
impl<'a> FromEntity<'a> for KnownSource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KnownSource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for KnownSource_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("KNOWN_SOURCE(")(s)?;
        let (s, source_id) = param::<SourceItem<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            source_id,
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Label<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Label<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct Language_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Language<'a> = Id<Language_<'a>>;
impl<'a> FromEntity<'a> for Language_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Language(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Language_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LANGUAGE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LanguageAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub role: ClassificationRole<'a>,
    pub items: Vec<LanguageItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LanguageAssignment<'a> = Id<LanguageAssignment_<'a>>;
impl<'a> FromEntity<'a> for LanguageAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LanguageAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LanguageAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LANGUAGE_ASSIGNMENT(")(s)?;
        let (s, assigned_class) = param::<Group<'a>>(false, s)?;
        let (s, role) = param::<ClassificationRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<LanguageItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_class,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LanguageItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type LanguageItem<'a> = Id<LanguageItem_<'a>>;

#[derive(Debug)]
pub struct LayeredItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type LayeredItem<'a> = Id<LayeredItem_<'a>>;

#[derive(Debug)]
pub struct LeaderCurve_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderCurve<'a> = Id<LeaderCurve_<'a>>;
impl<'a> FromEntity<'a> for LeaderCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LeaderCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LeaderCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LEADER_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LeaderDirectedCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderDirectedCallout<'a> = Id<LeaderDirectedCallout_<'a>>;
impl<'a> FromEntity<'a> for LeaderDirectedCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LeaderDirectedCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LeaderDirectedCallout_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LEADER_DIRECTED_CALLOUT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LeaderDirectedDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderDirectedDimension<'a> = Id<LeaderDirectedDimension_<'a>>;
impl<'a> FromEntity<'a> for LeaderDirectedDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LeaderDirectedDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LeaderDirectedDimension_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LEADER_DIRECTED_DIMENSION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LeaderTerminator_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub annotated_curve: AnnotationCurveOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderTerminator<'a> = Id<LeaderTerminator_<'a>>;
impl<'a> FromEntity<'a> for LeaderTerminator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LeaderTerminator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LeaderTerminator_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LEADER_TERMINATOR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, annotated_curve) = param::<AnnotationCurveOccurrence<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            annotated_curve,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LengthFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LengthFunction<'a> = Id<LengthFunction_<'a>>;
impl<'a> FromEntity<'a> for LengthFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LengthFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LengthFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LENGTH_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LengthMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for LengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct LengthMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LengthMeasureWithUnit<'a> = Id<LengthMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for LengthMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LengthMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LengthMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LENGTH_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LengthUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LengthUnit<'a> = Id<LengthUnit_<'a>>;
impl<'a> FromEntity<'a> for LengthUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LengthUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LengthUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LENGTH_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LightSource_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSource<'a> = Id<LightSource_<'a>>;
impl<'a> FromEntity<'a> for LightSource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LightSource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LightSource_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LIGHT_SOURCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, light_colour) = param::<Colour<'a>>(true, s)?;
        Ok((s, Self {
            name,
            light_colour,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LightSourceAmbient_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourceAmbient<'a> = Id<LightSourceAmbient_<'a>>;
impl<'a> FromEntity<'a> for LightSourceAmbient_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LightSourceAmbient(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LightSourceAmbient_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LIGHT_SOURCE_AMBIENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, light_colour) = param::<Colour<'a>>(true, s)?;
        Ok((s, Self {
            name,
            light_colour,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LightSourceDirectional_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    pub orientation: Direction<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourceDirectional<'a> = Id<LightSourceDirectional_<'a>>;
impl<'a> FromEntity<'a> for LightSourceDirectional_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LightSourceDirectional(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LightSourceDirectional_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LIGHT_SOURCE_DIRECTIONAL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, light_colour) = param::<Colour<'a>>(false, s)?;
        let (s, orientation) = param::<Direction<'a>>(true, s)?;
        Ok((s, Self {
            name,
            light_colour,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LightSourcePositional_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    pub position: CartesianPoint<'a>,
    pub constant_attenuation: f64,
    pub distance_attenuation: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourcePositional<'a> = Id<LightSourcePositional_<'a>>;
impl<'a> FromEntity<'a> for LightSourcePositional_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LightSourcePositional(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LightSourcePositional_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LIGHT_SOURCE_POSITIONAL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, light_colour) = param::<Colour<'a>>(false, s)?;
        let (s, position) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, constant_attenuation) = param::<f64>(false, s)?;
        let (s, distance_attenuation) = param::<f64>(true, s)?;
        Ok((s, Self {
            name,
            light_colour,
            position,
            constant_attenuation,
            distance_attenuation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LightSourceSpot_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    pub position: CartesianPoint<'a>,
    pub orientation: Direction<'a>,
    pub concentration_exponent: f64,
    pub constant_attenuation: f64,
    pub distance_attenuation: f64,
    pub spread_angle: PositivePlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourceSpot<'a> = Id<LightSourceSpot_<'a>>;
impl<'a> FromEntity<'a> for LightSourceSpot_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LightSourceSpot(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LightSourceSpot_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LIGHT_SOURCE_SPOT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, light_colour) = param::<Colour<'a>>(false, s)?;
        let (s, position) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, orientation) = param::<Direction<'a>>(false, s)?;
        let (s, concentration_exponent) = param::<f64>(false, s)?;
        let (s, constant_attenuation) = param::<f64>(false, s)?;
        let (s, distance_attenuation) = param::<f64>(false, s)?;
        let (s, spread_angle) = param::<PositivePlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            light_colour,
            position,
            orientation,
            concentration_exponent,
            constant_attenuation,
            distance_attenuation,
            spread_angle,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LikeExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LikeExpression<'a> = Id<LikeExpression_<'a>>;
impl<'a> FromEntity<'a> for LikeExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LikeExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LikeExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LIKE_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum LimitCondition<'a> { // enum
    MaximumMaterialCondition,
    LeastMaterialCondition,
    RegardlessOfFeatureSize,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for LimitCondition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use LimitCondition::*;
        alt((
            map(tag(".MAXIMUM_MATERIAL_CONDITION."), |_| MaximumMaterialCondition),
            map(tag(".LEAST_MATERIAL_CONDITION."), |_| LeastMaterialCondition),
            map(tag(".REGARDLESS_OF_FEATURE_SIZE."), |_| RegardlessOfFeatureSize),
        ))(s)
    }
}
#[derive(Debug)]
pub struct LimitsAndFits_<'a> { // entity
    pub form_variance: Label<'a>,
    pub zone_variance: Label<'a>,
    pub grade: Label<'a>,
    pub source: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LimitsAndFits<'a> = Id<LimitsAndFits_<'a>>;
impl<'a> FromEntity<'a> for LimitsAndFits_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LimitsAndFits(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LimitsAndFits_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LIMITS_AND_FITS(")(s)?;
        let (s, form_variance) = param::<Label<'a>>(false, s)?;
        let (s, zone_variance) = param::<Label<'a>>(false, s)?;
        let (s, grade) = param::<Label<'a>>(false, s)?;
        let (s, source) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            form_variance,
            zone_variance,
            grade,
            source,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Line_<'a> { // entity
    pub name: Label<'a>,
    pub pnt: CartesianPoint<'a>,
    pub dir: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Line<'a> = Id<Line_<'a>>;
impl<'a> FromEntity<'a> for Line_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Line(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Line_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LINE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, pnt) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, dir) = param::<Vector<'a>>(true, s)?;
        Ok((s, Self {
            name,
            pnt,
            dir,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LineProfileTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LineProfileTolerance<'a> = Id<LineProfileTolerance_<'a>>;
impl<'a> FromEntity<'a> for LineProfileTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LineProfileTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LineProfileTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LINE_PROFILE_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LinearDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LinearDimension<'a> = Id<LinearDimension_<'a>>;
impl<'a> FromEntity<'a> for LinearDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LinearDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LinearDimension_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LINEAR_DIMENSION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ListOfReversibleTopologyItem<'a>(pub Vec<ReversibleTopologyItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for ListOfReversibleTopologyItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<ReversibleTopologyItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct ListRepresentationItem<'a>(pub Vec<RepresentationItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for ListRepresentationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<RepresentationItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct LiteralNumber_<'a> { // entity
    pub the_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LiteralNumber<'a> = Id<LiteralNumber_<'a>>;
impl<'a> FromEntity<'a> for LiteralNumber_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LiteralNumber(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LiteralNumber_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LITERAL_NUMBER(")(s)?;
        let (s, the_value) = param::<f64>(true, s)?;
        Ok((s, Self {
            the_value,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LocalTime_<'a> { // entity
    pub hour_component: HourInDay<'a>,
    pub minute_component: Option<MinuteInHour<'a>>,
    pub second_component: Option<SecondInMinute<'a>>,
    pub zone: CoordinatedUniversalTimeOffset<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LocalTime<'a> = Id<LocalTime_<'a>>;
impl<'a> FromEntity<'a> for LocalTime_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LocalTime(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LocalTime_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LOCAL_TIME(")(s)?;
        let (s, hour_component) = param::<HourInDay<'a>>(false, s)?;
        let (s, minute_component) = param::<Option<MinuteInHour<'a>>>(false, s)?;
        let (s, second_component) = param::<Option<SecondInMinute<'a>>>(false, s)?;
        let (s, zone) = param::<CoordinatedUniversalTimeOffset<'a>>(true, s)?;
        Ok((s, Self {
            hour_component,
            minute_component,
            second_component,
            zone,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LocationShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LocationShapeRepresentation<'a> = Id<LocationShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for LocationShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LocationShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LocationShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LOCATION_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Locator_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Locator<'a> = Id<Locator_<'a>>;
impl<'a> FromEntity<'a> for Locator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Locator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Locator_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LOCATOR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Log10Function_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Log10Function<'a> = Id<Log10Function_<'a>>;
impl<'a> FromEntity<'a> for Log10Function_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Log10Function(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Log10Function_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LOG10_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Log2Function_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Log2Function<'a> = Id<Log2Function_<'a>>;
impl<'a> FromEntity<'a> for Log2Function_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Log2Function(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Log2Function_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LOG2_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LogFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LogFunction<'a> = Id<LogFunction_<'a>>;
impl<'a> FromEntity<'a> for LogFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LogFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LogFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LOG_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Loop_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Loop<'a> = Id<Loop_<'a>>;
impl<'a> FromEntity<'a> for Loop_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Loop(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Loop_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LOOP(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LotEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_lot_id: Identifier<'a>,
    pub effectivity_lot_size: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LotEffectivity<'a> = Id<LotEffectivity_<'a>>;
impl<'a> FromEntity<'a> for LotEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LotEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LotEffectivity_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LOT_EFFECTIVITY(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, effectivity_lot_id) = param::<Identifier<'a>>(false, s)?;
        let (s, effectivity_lot_size) = param::<MeasureWithUnit<'a>>(true, s)?;
        Ok((s, Self {
            id,
            effectivity_lot_id,
            effectivity_lot_size,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LuminousIntensityMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for LuminousIntensityMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct LuminousIntensityMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LuminousIntensityMeasureWithUnit<'a> = Id<LuminousIntensityMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for LuminousIntensityMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LuminousIntensityMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LuminousIntensityMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LUMINOUS_INTENSITY_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct LuminousIntensityUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LuminousIntensityUnit<'a> = Id<LuminousIntensityUnit_<'a>>;
impl<'a> FromEntity<'a> for LuminousIntensityUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LuminousIntensityUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for LuminousIntensityUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("LUMINOUS_INTENSITY_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MakeFromUsageOption_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub ranking: i64,
    pub ranking_rationale: Text<'a>,
    pub quantity: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MakeFromUsageOption<'a> = Id<MakeFromUsageOption_<'a>>;
impl<'a> FromEntity<'a> for MakeFromUsageOption_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MakeFromUsageOption(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MakeFromUsageOption_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MAKE_FROM_USAGE_OPTION(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, related_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, ranking) = param::<i64>(false, s)?;
        let (s, ranking_rationale) = param::<Text<'a>>(false, s)?;
        let (s, quantity) = param::<MeasureWithUnit<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            ranking,
            ranking_rationale,
            quantity,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ManifoldSolidBrep_<'a> { // entity
    pub name: Label<'a>,
    pub outer: ClosedShell<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ManifoldSolidBrep<'a> = Id<ManifoldSolidBrep_<'a>>;
impl<'a> FromEntity<'a> for ManifoldSolidBrep_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ManifoldSolidBrep(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ManifoldSolidBrep_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MANIFOLD_SOLID_BREP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, outer) = param::<ClosedShell<'a>>(true, s)?;
        Ok((s, Self {
            name,
            outer,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ManifoldSubsurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ManifoldSubsurfaceShapeRepresentation<'a> = Id<ManifoldSubsurfaceShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ManifoldSubsurfaceShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ManifoldSubsurfaceShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ManifoldSubsurfaceShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ManifoldSurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ManifoldSurfaceShapeRepresentation<'a> = Id<ManifoldSurfaceShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ManifoldSurfaceShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ManifoldSurfaceShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ManifoldSurfaceShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MANIFOLD_SURFACE_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MappedItem_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MappedItem<'a> = Id<MappedItem_<'a>>;
impl<'a> FromEntity<'a> for MappedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MappedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MappedItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MAPPED_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, mapping_source) = param::<RepresentationMap<'a>>(false, s)?;
        let (s, mapping_target) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum MarkerSelect<'a> { // select
    MarkerType(MarkerType<'a>),
    PreDefinedMarker(PreDefinedMarker<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MarkerSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("MARKER_TYPE("), <MarkerType<'a>>::parse, char(')')), |r| MarkerSelect::MarkerType(r)),
            map(<PreDefinedMarker<'a>>::parse, |r| MarkerSelect::PreDefinedMarker(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub enum MarkerType<'a> { // enum
    Dot,
    X,
    Plus,
    Asterisk,
    Ring,
    Square,
    Triangle,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for MarkerType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use MarkerType::*;
        alt((
            map(tag(".DOT."), |_| Dot),
            map(tag(".X."), |_| X),
            map(tag(".PLUS."), |_| Plus),
            map(tag(".ASTERISK."), |_| Asterisk),
            map(tag(".RING."), |_| Ring),
            map(tag(".SQUARE."), |_| Square),
            map(tag(".TRIANGLE."), |_| Triangle),
        ))(s)
    }
}
#[derive(Debug)]
pub struct MassMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MassMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct MassMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MassMeasureWithUnit<'a> = Id<MassMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for MassMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MassMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MassMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MASS_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MassUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MassUnit<'a> = Id<MassUnit_<'a>>;
impl<'a> FromEntity<'a> for MassUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MassUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MassUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MASS_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MaterialDesignation_<'a> { // entity
    pub name: Label<'a>,
    pub definitions: Vec<CharacterizedDefinition<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialDesignation<'a> = Id<MaterialDesignation_<'a>>;
impl<'a> FromEntity<'a> for MaterialDesignation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MaterialDesignation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MaterialDesignation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MATERIAL_DESIGNATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, definitions) = param::<Vec<CharacterizedDefinition<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            definitions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MaterialDesignationCharacterization_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub designation: MaterialDesignation<'a>,
    pub property: CharacterizedMaterialProperty<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialDesignationCharacterization<'a> = Id<MaterialDesignationCharacterization_<'a>>;
impl<'a> FromEntity<'a> for MaterialDesignationCharacterization_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MaterialDesignationCharacterization(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MaterialDesignationCharacterization_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MATERIAL_DESIGNATION_CHARACTERIZATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, designation) = param::<MaterialDesignation<'a>>(false, s)?;
        let (s, property) = param::<CharacterizedMaterialProperty<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            designation,
            property,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MaterialProperty_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialProperty<'a> = Id<MaterialProperty_<'a>>;
impl<'a> FromEntity<'a> for MaterialProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MaterialProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MaterialProperty_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MATERIAL_PROPERTY(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, definition) = param::<CharacterizedDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            definition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MaterialPropertyRepresentation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub dependent_environment: DataEnvironment<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialPropertyRepresentation<'a> = Id<MaterialPropertyRepresentation_<'a>>;
impl<'a> FromEntity<'a> for MaterialPropertyRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MaterialPropertyRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MaterialPropertyRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MATERIAL_PROPERTY_REPRESENTATION(")(s)?;
        let (s, definition) = param::<RepresentedDefinition<'a>>(false, s)?;
        let (s, used_representation) = param::<Representation<'a>>(false, s)?;
        let (s, dependent_environment) = param::<DataEnvironment<'a>>(true, s)?;
        Ok((s, Self {
            definition,
            used_representation,
            dependent_environment,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MaximumFunction_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaximumFunction<'a> = Id<MaximumFunction_<'a>>;
impl<'a> FromEntity<'a> for MaximumFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MaximumFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MaximumFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MAXIMUM_FUNCTION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MeasureQualification_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub qualified_measure: MeasureWithUnit<'a>,
    pub qualifiers: Vec<ValueQualifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MeasureQualification<'a> = Id<MeasureQualification_<'a>>;
impl<'a> FromEntity<'a> for MeasureQualification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MeasureQualification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MeasureQualification_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MEASURE_QUALIFICATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, qualified_measure) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, qualifiers) = param::<Vec<ValueQualifier<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            qualified_measure,
            qualifiers,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MeasureRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MeasureRepresentationItem<'a> = Id<MeasureRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for MeasureRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MeasureRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MeasureRepresentationItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MEASURE_REPRESENTATION_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            name,
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum MeasureValue<'a> { // select
    AmountOfSubstanceMeasure(AmountOfSubstanceMeasure<'a>),
    AreaMeasure(AreaMeasure<'a>),
    CelsiusTemperatureMeasure(CelsiusTemperatureMeasure<'a>),
    ContextDependentMeasure(ContextDependentMeasure<'a>),
    CountMeasure(CountMeasure<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    ElectricCurrentMeasure(ElectricCurrentMeasure<'a>),
    LengthMeasure(LengthMeasure<'a>),
    LuminousIntensityMeasure(LuminousIntensityMeasure<'a>),
    MassMeasure(MassMeasure<'a>),
    NumericMeasure(NumericMeasure<'a>),
    NonNegativeLengthMeasure(NonNegativeLengthMeasure<'a>),
    ParameterValue(ParameterValue<'a>),
    PlaneAngleMeasure(PlaneAngleMeasure<'a>),
    PositiveLengthMeasure(PositiveLengthMeasure<'a>),
    PositivePlaneAngleMeasure(PositivePlaneAngleMeasure<'a>),
    PositiveRatioMeasure(PositiveRatioMeasure<'a>),
    RatioMeasure(RatioMeasure<'a>),
    SolidAngleMeasure(SolidAngleMeasure<'a>),
    ThermodynamicTemperatureMeasure(ThermodynamicTemperatureMeasure<'a>),
    TimeMeasure(TimeMeasure<'a>),
    VolumeMeasure(VolumeMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MeasureValue<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("AMOUNT_OF_SUBSTANCE_MEASURE("), <AmountOfSubstanceMeasure<'a>>::parse, char(')')), |r| MeasureValue::AmountOfSubstanceMeasure(r)),
            map(delimited(tag("AREA_MEASURE("), <AreaMeasure<'a>>::parse, char(')')), |r| MeasureValue::AreaMeasure(r)),
            map(delimited(tag("CELSIUS_TEMPERATURE_MEASURE("), <CelsiusTemperatureMeasure<'a>>::parse, char(')')), |r| MeasureValue::CelsiusTemperatureMeasure(r)),
            map(delimited(tag("CONTEXT_DEPENDENT_MEASURE("), <ContextDependentMeasure<'a>>::parse, char(')')), |r| MeasureValue::ContextDependentMeasure(r)),
            map(delimited(tag("COUNT_MEASURE("), <CountMeasure<'a>>::parse, char(')')), |r| MeasureValue::CountMeasure(r)),
            map(delimited(tag("DESCRIPTIVE_MEASURE("), <DescriptiveMeasure<'a>>::parse, char(')')), |r| MeasureValue::DescriptiveMeasure(r)),
            map(delimited(tag("ELECTRIC_CURRENT_MEASURE("), <ElectricCurrentMeasure<'a>>::parse, char(')')), |r| MeasureValue::ElectricCurrentMeasure(r)),
            map(delimited(tag("LENGTH_MEASURE("), <LengthMeasure<'a>>::parse, char(')')), |r| MeasureValue::LengthMeasure(r)),
            map(delimited(tag("LUMINOUS_INTENSITY_MEASURE("), <LuminousIntensityMeasure<'a>>::parse, char(')')), |r| MeasureValue::LuminousIntensityMeasure(r)),
            map(delimited(tag("MASS_MEASURE("), <MassMeasure<'a>>::parse, char(')')), |r| MeasureValue::MassMeasure(r)),
            map(delimited(tag("NUMERIC_MEASURE("), <NumericMeasure<'a>>::parse, char(')')), |r| MeasureValue::NumericMeasure(r)),
            map(delimited(tag("NON_NEGATIVE_LENGTH_MEASURE("), <NonNegativeLengthMeasure<'a>>::parse, char(')')), |r| MeasureValue::NonNegativeLengthMeasure(r)),
            map(delimited(tag("PARAMETER_VALUE("), <ParameterValue<'a>>::parse, char(')')), |r| MeasureValue::ParameterValue(r)),
            map(delimited(tag("PLANE_ANGLE_MEASURE("), <PlaneAngleMeasure<'a>>::parse, char(')')), |r| MeasureValue::PlaneAngleMeasure(r)),
            map(delimited(tag("POSITIVE_LENGTH_MEASURE("), <PositiveLengthMeasure<'a>>::parse, char(')')), |r| MeasureValue::PositiveLengthMeasure(r)),
            map(delimited(tag("POSITIVE_PLANE_ANGLE_MEASURE("), <PositivePlaneAngleMeasure<'a>>::parse, char(')')), |r| MeasureValue::PositivePlaneAngleMeasure(r)),
            map(delimited(tag("POSITIVE_RATIO_MEASURE("), <PositiveRatioMeasure<'a>>::parse, char(')')), |r| MeasureValue::PositiveRatioMeasure(r)),
            map(delimited(tag("RATIO_MEASURE("), <RatioMeasure<'a>>::parse, char(')')), |r| MeasureValue::RatioMeasure(r)),
            map(delimited(tag("SOLID_ANGLE_MEASURE("), <SolidAngleMeasure<'a>>::parse, char(')')), |r| MeasureValue::SolidAngleMeasure(r)),
        alt((
            map(delimited(tag("THERMODYNAMIC_TEMPERATURE_MEASURE("), <ThermodynamicTemperatureMeasure<'a>>::parse, char(')')), |r| MeasureValue::ThermodynamicTemperatureMeasure(r)),
            map(delimited(tag("TIME_MEASURE("), <TimeMeasure<'a>>::parse, char(')')), |r| MeasureValue::TimeMeasure(r)),
            map(delimited(tag("VOLUME_MEASURE("), <VolumeMeasure<'a>>::parse, char(')')), |r| MeasureValue::VolumeMeasure(r)),
        ))))(s)
    }
}
#[derive(Debug)]
pub struct MeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MeasureWithUnit<'a> = Id<MeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for MeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MechanicalDesignGeometricPresentationArea_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MechanicalDesignGeometricPresentationArea<'a> = Id<MechanicalDesignGeometricPresentationArea_<'a>>;
impl<'a> FromEntity<'a> for MechanicalDesignGeometricPresentationArea_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MechanicalDesignGeometricPresentationArea(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MechanicalDesignGeometricPresentationArea_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_AREA(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MechanicalDesignGeometricPresentationRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MechanicalDesignGeometricPresentationRepresentation<'a> = Id<MechanicalDesignGeometricPresentationRepresentation_<'a>>;
impl<'a> FromEntity<'a> for MechanicalDesignGeometricPresentationRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MechanicalDesignGeometricPresentationRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MechanicalDesignGeometricPresentationRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Mechanism_<'a> { // entity
    pub structure_definition: KinematicStructure<'a>,
    pub base: KinematicLink<'a>,
    pub containing_property: KinematicPropertyDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Mechanism<'a> = Id<Mechanism_<'a>>;
impl<'a> FromEntity<'a> for Mechanism_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Mechanism(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Mechanism_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MECHANISM(")(s)?;
        let (s, structure_definition) = param::<KinematicStructure<'a>>(false, s)?;
        let (s, base) = param::<KinematicLink<'a>>(false, s)?;
        let (s, containing_property) = param::<KinematicPropertyDefinition<'a>>(true, s)?;
        Ok((s, Self {
            structure_definition,
            base,
            containing_property,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MechanismBasePlacement_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub transformation_operator: Transformation<'a>,
    pub base_of_mechanism: Mechanism<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MechanismBasePlacement<'a> = Id<MechanismBasePlacement_<'a>>;
impl<'a> FromEntity<'a> for MechanismBasePlacement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MechanismBasePlacement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MechanismBasePlacement_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MECHANISM_BASE_PLACEMENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, rep_1) = param::<Representation<'a>>(false, s)?;
        let (s, _) = tag("*,")(s)?;
        let (s, transformation_operator) = param::<Transformation<'a>>(false, s)?;
        let (s, base_of_mechanism) = param::<Mechanism<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            transformation_operator,
            base_of_mechanism,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MinimumFunction_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MinimumFunction<'a> = Id<MinimumFunction_<'a>>;
impl<'a> FromEntity<'a> for MinimumFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MinimumFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MinimumFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MINIMUM_FUNCTION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MinusExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MinusExpression<'a> = Id<MinusExpression_<'a>>;
impl<'a> FromEntity<'a> for MinusExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MinusExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MinusExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MINUS_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MinusFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MinusFunction<'a> = Id<MinusFunction_<'a>>;
impl<'a> FromEntity<'a> for MinusFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MinusFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MinusFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MINUS_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MinuteInHour<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MinuteInHour<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct ModExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ModExpression<'a> = Id<ModExpression_<'a>>;
impl<'a> FromEntity<'a> for ModExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ModExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ModExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MOD_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ModifiedGeometricTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub modifier: LimitCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ModifiedGeometricTolerance<'a> = Id<ModifiedGeometricTolerance_<'a>>;
impl<'a> FromEntity<'a> for ModifiedGeometricTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ModifiedGeometricTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ModifiedGeometricTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MODIFIED_GEOMETRIC_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, modifier) = param::<LimitCondition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            modifier,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ModifiedPattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ModifiedPattern<'a> = Id<ModifiedPattern_<'a>>;
impl<'a> FromEntity<'a> for ModifiedPattern_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ModifiedPattern(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ModifiedPattern_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MODIFIED_PATTERN(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MomentsOfInertiaRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MomentsOfInertiaRepresentation<'a> = Id<MomentsOfInertiaRepresentation_<'a>>;
impl<'a> FromEntity<'a> for MomentsOfInertiaRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MomentsOfInertiaRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MomentsOfInertiaRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MOMENTS_OF_INERTIA_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MonthInYearNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MonthInYearNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct MotionLinkRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub related_frame: RigidPlacement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MotionLinkRelationship<'a> = Id<MotionLinkRelationship_<'a>>;
impl<'a> FromEntity<'a> for MotionLinkRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MotionLinkRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MotionLinkRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MOTION_LINK_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, rep_1) = param::<Representation<'a>>(false, s)?;
        let (s, rep_2) = param::<Representation<'a>>(false, s)?;
        let (s, related_frame) = param::<RigidPlacement<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            related_frame,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum MotionParameterMeasure<'a> { // select
    ParameterValue(ParameterValue<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MotionParameterMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("PARAMETER_VALUE("), <ParameterValue<'a>>::parse, char(')')), |r| MotionParameterMeasure::ParameterValue(r)),
            map(<MeasureWithUnit<'a>>::parse, |r| MotionParameterMeasure::MeasureWithUnit(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct MultExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultExpression<'a> = Id<MultExpression_<'a>>;
impl<'a> FromEntity<'a> for MultExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MultExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MULT_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MultiLanguageAttributeAssignment_<'a> { // entity
    pub attribute_name: Label<'a>,
    pub attribute_value: AttributeType<'a>,
    pub role: AttributeValueRole<'a>,
    pub items: Vec<MultiLanguageAttributeItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultiLanguageAttributeAssignment<'a> = Id<MultiLanguageAttributeAssignment_<'a>>;
impl<'a> FromEntity<'a> for MultiLanguageAttributeAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultiLanguageAttributeAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MultiLanguageAttributeAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT(")(s)?;
        let (s, attribute_name) = param::<Label<'a>>(false, s)?;
        let (s, attribute_value) = param::<AttributeType<'a>>(false, s)?;
        let (s, role) = param::<AttributeValueRole<'a>>(false, s)?;
        let (s, items) = param::<Vec<MultiLanguageAttributeItem<'a>>>(true, s)?;
        Ok((s, Self {
            attribute_name,
            attribute_value,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MultiLanguageAttributeItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type MultiLanguageAttributeItem<'a> = Id<MultiLanguageAttributeItem_<'a>>;

#[derive(Debug)]
pub struct MultipleArityBooleanExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityBooleanExpression<'a> = Id<MultipleArityBooleanExpression_<'a>>;
impl<'a> FromEntity<'a> for MultipleArityBooleanExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultipleArityBooleanExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MultipleArityBooleanExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MULTIPLE_ARITY_BOOLEAN_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MultipleArityFunctionCall_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityFunctionCall<'a> = Id<MultipleArityFunctionCall_<'a>>;
impl<'a> FromEntity<'a> for MultipleArityFunctionCall_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultipleArityFunctionCall(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MultipleArityFunctionCall_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MULTIPLE_ARITY_FUNCTION_CALL(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MultipleArityGenericExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityGenericExpression<'a> = Id<MultipleArityGenericExpression_<'a>>;
impl<'a> FromEntity<'a> for MultipleArityGenericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultipleArityGenericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MultipleArityGenericExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MULTIPLE_ARITY_GENERIC_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct MultipleArityNumericExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityNumericExpression<'a> = Id<MultipleArityNumericExpression_<'a>>;
impl<'a> FromEntity<'a> for MultipleArityNumericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultipleArityNumericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for MultipleArityNumericExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("MULTIPLE_ARITY_NUMERIC_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct NameAssignment_<'a> { // entity
    pub assigned_name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NameAssignment<'a> = Id<NameAssignment_<'a>>;
impl<'a> FromEntity<'a> for NameAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NameAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for NameAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("NAME_ASSIGNMENT(")(s)?;
        let (s, assigned_name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            assigned_name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct NameAttribute_<'a> { // entity
    pub attribute_value: Label<'a>,
    pub named_item: NameAttributeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NameAttribute<'a> = Id<NameAttribute_<'a>>;
impl<'a> FromEntity<'a> for NameAttribute_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NameAttribute(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for NameAttribute_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("NAME_ATTRIBUTE(")(s)?;
        let (s, attribute_value) = param::<Label<'a>>(false, s)?;
        let (s, named_item) = param::<NameAttributeSelect<'a>>(true, s)?;
        Ok((s, Self {
            attribute_value,
            named_item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct NameAttributeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type NameAttributeSelect<'a> = Id<NameAttributeSelect_<'a>>;

#[derive(Debug)]
pub struct NameItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type NameItem<'a> = Id<NameItem_<'a>>;

#[derive(Debug)]
pub struct NamedUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NamedUnit<'a> = Id<NamedUnit_<'a>>;
impl<'a> FromEntity<'a> for NamedUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NamedUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for NamedUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("NAMED_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct NamedUnitVariable_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NamedUnitVariable<'a> = Id<NamedUnitVariable_<'a>>;
impl<'a> FromEntity<'a> for NamedUnitVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NamedUnitVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for NamedUnitVariable_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("NAMED_UNIT_VARIABLE(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct NextAssemblyUsageOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NextAssemblyUsageOccurrence<'a> = Id<NextAssemblyUsageOccurrence_<'a>>;
impl<'a> FromEntity<'a> for NextAssemblyUsageOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NextAssemblyUsageOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for NextAssemblyUsageOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("NEXT_ASSEMBLY_USAGE_OCCURRENCE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, related_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, reference_designator) = param::<Option<Identifier<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            reference_designator,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct NgonClosedProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NgonClosedProfile<'a> = Id<NgonClosedProfile_<'a>>;
impl<'a> FromEntity<'a> for NgonClosedProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NgonClosedProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for NgonClosedProfile_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("NGON_CLOSED_PROFILE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct NonManifoldSurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NonManifoldSurfaceShapeRepresentation<'a> = Id<NonManifoldSurfaceShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for NonManifoldSurfaceShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NonManifoldSurfaceShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for NonManifoldSurfaceShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}

#[derive(Debug)]
pub struct NonNegativeLengthMeasure<'a>(pub LengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for NonNegativeLengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(LengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct NotExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NotExpression<'a> = Id<NotExpression_<'a>>;
impl<'a> FromEntity<'a> for NotExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NotExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for NotExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("NOT_EXPRESSION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum NullStyle<'a> { // enum
    Null,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for NullStyle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use NullStyle::*;
        map(tag(".NULL."), |_| Null)(s)
    }
}
#[derive(Debug)]
pub struct NumericDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NumericDefinedFunction<'a> = Id<NumericDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for NumericDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NumericDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for NumericDefinedFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("NUMERIC_DEFINED_FUNCTION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct NumericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NumericExpression<'a> = Id<NumericExpression_<'a>>;
impl<'a> FromEntity<'a> for NumericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NumericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for NumericExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("NUMERIC_EXPRESSION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct NumericMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for NumericMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct NumericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NumericVariable<'a> = Id<NumericVariable_<'a>>;
impl<'a> FromEntity<'a> for NumericVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NumericVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for NumericVariable_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("NUMERIC_VARIABLE(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ObjectRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ObjectRole<'a> = Id<ObjectRole_<'a>>;
impl<'a> FromEntity<'a> for ObjectRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ObjectRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ObjectRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("OBJECT_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OddFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OddFunction<'a> = Id<OddFunction_<'a>>;
impl<'a> FromEntity<'a> for OddFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OddFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OddFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ODD_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OffsetCurve2d_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub distance: LengthMeasure<'a>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OffsetCurve2d<'a> = Id<OffsetCurve2d_<'a>>;
impl<'a> FromEntity<'a> for OffsetCurve2d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OffsetCurve2d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OffsetCurve2d_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("OFFSET_CURVE_2D(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, basis_curve) = param::<Curve<'a>>(false, s)?;
        let (s, distance) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            basis_curve,
            distance,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OffsetCurve3d_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub distance: LengthMeasure<'a>,
    pub self_intersect: Logical,
    pub ref_direction: Direction<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OffsetCurve3d<'a> = Id<OffsetCurve3d_<'a>>;
impl<'a> FromEntity<'a> for OffsetCurve3d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OffsetCurve3d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OffsetCurve3d_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("OFFSET_CURVE_3D(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, basis_curve) = param::<Curve<'a>>(false, s)?;
        let (s, distance) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, self_intersect) = param::<Logical>(false, s)?;
        let (s, ref_direction) = param::<Direction<'a>>(true, s)?;
        Ok((s, Self {
            name,
            basis_curve,
            distance,
            self_intersect,
            ref_direction,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OffsetSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub distance: LengthMeasure<'a>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OffsetSurface<'a> = Id<OffsetSurface_<'a>>;
impl<'a> FromEntity<'a> for OffsetSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OffsetSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OffsetSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("OFFSET_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, basis_surface) = param::<Surface<'a>>(false, s)?;
        let (s, distance) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            basis_surface,
            distance,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OneDirectionRepeatFactor_<'a> { // entity
    pub name: Label<'a>,
    pub repeat_factor: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OneDirectionRepeatFactor<'a> = Id<OneDirectionRepeatFactor_<'a>>;
impl<'a> FromEntity<'a> for OneDirectionRepeatFactor_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OneDirectionRepeatFactor(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OneDirectionRepeatFactor_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ONE_DIRECTION_REPEAT_FACTOR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, repeat_factor) = param::<Vector<'a>>(true, s)?;
        Ok((s, Self {
            name,
            repeat_factor,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OpenPathProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OpenPathProfile<'a> = Id<OpenPathProfile_<'a>>;
impl<'a> FromEntity<'a> for OpenPathProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OpenPathProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OpenPathProfile_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("OPEN_PATH_PROFILE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OpenShell_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OpenShell<'a> = Id<OpenShell_<'a>>;
impl<'a> FromEntity<'a> for OpenShell_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OpenShell(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OpenShell_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("OPEN_SHELL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, cfs_faces) = param::<Vec<Face<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            cfs_faces,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrExpression<'a> = Id<OrExpression_<'a>>;
impl<'a> FromEntity<'a> for OrExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("OR_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrdinateDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrdinateDimension<'a> = Id<OrdinateDimension_<'a>>;
impl<'a> FromEntity<'a> for OrdinateDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrdinateDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrdinateDimension_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORDINATE_DIMENSION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Organization_<'a> { // entity
    pub id: Option<Identifier<'a>>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Organization<'a> = Id<Organization_<'a>>;
impl<'a> FromEntity<'a> for Organization_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Organization(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Organization_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORGANIZATION(")(s)?;
        let (s, id) = param::<Option<Identifier<'a>>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrganizationAssignment_<'a> { // entity
    pub assigned_organization: Organization<'a>,
    pub role: OrganizationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationAssignment<'a> = Id<OrganizationAssignment_<'a>>;
impl<'a> FromEntity<'a> for OrganizationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrganizationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORGANIZATION_ASSIGNMENT(")(s)?;
        let (s, assigned_organization) = param::<Organization<'a>>(false, s)?;
        let (s, role) = param::<OrganizationRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_organization,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrganizationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type OrganizationItem<'a> = Id<OrganizationItem_<'a>>;

#[derive(Debug)]
pub struct OrganizationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_organization: Organization<'a>,
    pub related_organization: Organization<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationRelationship<'a> = Id<OrganizationRelationship_<'a>>;
impl<'a> FromEntity<'a> for OrganizationRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrganizationRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORGANIZATION_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_organization) = param::<Organization<'a>>(false, s)?;
        let (s, related_organization) = param::<Organization<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_organization,
            related_organization,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrganizationRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationRole<'a> = Id<OrganizationRole_<'a>>;
impl<'a> FromEntity<'a> for OrganizationRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrganizationRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORGANIZATION_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrganizationalAddress_<'a> { // entity
    pub internal_location: Option<Label<'a>>,
    pub street_number: Option<Label<'a>>,
    pub street: Option<Label<'a>>,
    pub postal_box: Option<Label<'a>>,
    pub town: Option<Label<'a>>,
    pub region: Option<Label<'a>>,
    pub postal_code: Option<Label<'a>>,
    pub country: Option<Label<'a>>,
    pub facsimile_number: Option<Label<'a>>,
    pub telephone_number: Option<Label<'a>>,
    pub electronic_mail_address: Option<Label<'a>>,
    pub telex_number: Option<Label<'a>>,
    pub organizations: Vec<Organization<'a>>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalAddress<'a> = Id<OrganizationalAddress_<'a>>;
impl<'a> FromEntity<'a> for OrganizationalAddress_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationalAddress(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrganizationalAddress_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORGANIZATIONAL_ADDRESS(")(s)?;
        let (s, internal_location) = param::<Option<Label<'a>>>(false, s)?;
        let (s, street_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, street) = param::<Option<Label<'a>>>(false, s)?;
        let (s, postal_box) = param::<Option<Label<'a>>>(false, s)?;
        let (s, town) = param::<Option<Label<'a>>>(false, s)?;
        let (s, region) = param::<Option<Label<'a>>>(false, s)?;
        let (s, postal_code) = param::<Option<Label<'a>>>(false, s)?;
        let (s, country) = param::<Option<Label<'a>>>(false, s)?;
        let (s, facsimile_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, telephone_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, electronic_mail_address) = param::<Option<Label<'a>>>(false, s)?;
        let (s, telex_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, organizations) = param::<Vec<Organization<'a>>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            internal_location,
            street_number,
            street,
            postal_box,
            town,
            region,
            postal_code,
            country,
            facsimile_number,
            telephone_number,
            electronic_mail_address,
            telex_number,
            organizations,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrganizationalProject_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub responsible_organizations: Vec<Organization<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProject<'a> = Id<OrganizationalProject_<'a>>;
impl<'a> FromEntity<'a> for OrganizationalProject_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationalProject(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrganizationalProject_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORGANIZATIONAL_PROJECT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, responsible_organizations) = param::<Vec<Organization<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            responsible_organizations,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrganizationalProjectAssignment_<'a> { // entity
    pub assigned_organizational_project: OrganizationalProject<'a>,
    pub role: OrganizationalProjectRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProjectAssignment<'a> = Id<OrganizationalProjectAssignment_<'a>>;
impl<'a> FromEntity<'a> for OrganizationalProjectAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationalProjectAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrganizationalProjectAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORGANIZATIONAL_PROJECT_ASSIGNMENT(")(s)?;
        let (s, assigned_organizational_project) = param::<OrganizationalProject<'a>>(false, s)?;
        let (s, role) = param::<OrganizationalProjectRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_organizational_project,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrganizationalProjectItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type OrganizationalProjectItem<'a> = Id<OrganizationalProjectItem_<'a>>;

#[derive(Debug)]
pub struct OrganizationalProjectRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_organizational_project: OrganizationalProject<'a>,
    pub related_organizational_project: OrganizationalProject<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProjectRelationship<'a> = Id<OrganizationalProjectRelationship_<'a>>;
impl<'a> FromEntity<'a> for OrganizationalProjectRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationalProjectRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrganizationalProjectRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORGANIZATIONAL_PROJECT_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_organizational_project) = param::<OrganizationalProject<'a>>(false, s)?;
        let (s, related_organizational_project) = param::<OrganizationalProject<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_organizational_project,
            related_organizational_project,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrganizationalProjectRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProjectRole<'a> = Id<OrganizationalProjectRole_<'a>>;
impl<'a> FromEntity<'a> for OrganizationalProjectRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationalProjectRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrganizationalProjectRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORGANIZATIONAL_PROJECT_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrientedClosedShell_<'a> { // entity
    pub name: Label<'a>,
    pub closed_shell_element: ClosedShell<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedClosedShell<'a> = Id<OrientedClosedShell_<'a>>;
impl<'a> FromEntity<'a> for OrientedClosedShell_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedClosedShell(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrientedClosedShell_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORIENTED_CLOSED_SHELL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, _) = tag("*,")(s)?;
        let (s, closed_shell_element) = param::<ClosedShell<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            closed_shell_element,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrientedEdge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_element: Edge<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedEdge<'a> = Id<OrientedEdge_<'a>>;
impl<'a> FromEntity<'a> for OrientedEdge_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedEdge(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrientedEdge_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORIENTED_EDGE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, _) = tag("*,")(s)?;
        let (s, _) = tag("*,")(s)?;
        let (s, edge_element) = param::<Edge<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            edge_element,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrientedFace_<'a> { // entity
    pub name: Label<'a>,
    pub face_element: Face<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedFace<'a> = Id<OrientedFace_<'a>>;
impl<'a> FromEntity<'a> for OrientedFace_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedFace(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrientedFace_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORIENTED_FACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, _) = tag("*,")(s)?;
        let (s, face_element) = param::<Face<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            face_element,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrientedOpenShell_<'a> { // entity
    pub name: Label<'a>,
    pub open_shell_element: OpenShell<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedOpenShell<'a> = Id<OrientedOpenShell_<'a>>;
impl<'a> FromEntity<'a> for OrientedOpenShell_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedOpenShell(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrientedOpenShell_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORIENTED_OPEN_SHELL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, _) = tag("*,")(s)?;
        let (s, open_shell_element) = param::<OpenShell<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            open_shell_element,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrientedPath_<'a> { // entity
    pub name: Label<'a>,
    pub path_element: Path<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedPath<'a> = Id<OrientedPath_<'a>>;
impl<'a> FromEntity<'a> for OrientedPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrientedPath_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORIENTED_PATH(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, _) = tag("*,")(s)?;
        let (s, path_element) = param::<Path<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            path_element,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OrientedSurface_<'a> { // entity
    pub name: Label<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedSurface<'a> = Id<OrientedSurface_<'a>>;
impl<'a> FromEntity<'a> for OrientedSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OrientedSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ORIENTED_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OuterBoundaryCurve_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OuterBoundaryCurve<'a> = Id<OuterBoundaryCurve_<'a>>;
impl<'a> FromEntity<'a> for OuterBoundaryCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OuterBoundaryCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OuterBoundaryCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("OUTER_BOUNDARY_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, segments) = param::<Vec<CompositeCurveSegment<'a>>>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            segments,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct OverRidingStyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub over_ridden_style: StyledItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OverRidingStyledItem<'a> = Id<OverRidingStyledItem_<'a>>;
impl<'a> FromEntity<'a> for OverRidingStyledItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OverRidingStyledItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for OverRidingStyledItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("OVER_RIDING_STYLED_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, over_ridden_style) = param::<StyledItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            over_ridden_style,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PackageProductConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PackageProductConceptFeature<'a> = Id<PackageProductConceptFeature_<'a>>;
impl<'a> FromEntity<'a> for PackageProductConceptFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PackageProductConceptFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PackageProductConceptFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PACKAGE_PRODUCT_CONCEPT_FEATURE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PairActuator_<'a> { // entity
    pub actuated_pair: KinematicPair<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PairActuator<'a> = Id<PairActuator_<'a>>;
impl<'a> FromEntity<'a> for PairActuator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PairActuator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PairActuator_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PAIR_ACTUATOR(")(s)?;
        let (s, actuated_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            actuated_pair,
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PairValue<'a> = Id<PairValue_<'a>>;
impl<'a> FromEntity<'a> for PairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Parabola_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub focal_dist: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Parabola<'a> = Id<Parabola_<'a>>;
impl<'a> FromEntity<'a> for Parabola_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Parabola(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Parabola_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PARABOLA(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, focal_dist) = param::<LengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            focal_dist,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ParallelOffset_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub offset: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ParallelOffset<'a> = Id<ParallelOffset_<'a>>;
impl<'a> FromEntity<'a> for ParallelOffset_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ParallelOffset(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ParallelOffset_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PARALLEL_OFFSET(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(false, s)?;
        let (s, offset) = param::<MeasureWithUnit<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            offset,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ParallelismTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ParallelismTolerance<'a> = Id<ParallelismTolerance_<'a>>;
impl<'a> FromEntity<'a> for ParallelismTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ParallelismTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ParallelismTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PARALLELISM_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, datum_system) = param::<Vec<DatumReference<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ParameterValue<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ParameterValue<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct ParametricRepresentationContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ParametricRepresentationContext<'a> = Id<ParametricRepresentationContext_<'a>>;
impl<'a> FromEntity<'a> for ParametricRepresentationContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ParametricRepresentationContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ParametricRepresentationContext_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PARAMETRIC_REPRESENTATION_CONTEXT(")(s)?;
        let (s, context_identifier) = param::<Identifier<'a>>(false, s)?;
        let (s, context_type) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            context_identifier,
            context_type,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PartialCircularProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PartialCircularProfile<'a> = Id<PartialCircularProfile_<'a>>;
impl<'a> FromEntity<'a> for PartialCircularProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PartialCircularProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PartialCircularProfile_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PARTIAL_CIRCULAR_PROFILE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Path_<'a> { // entity
    pub name: Label<'a>,
    pub edge_list: Vec<OrientedEdge<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Path<'a> = Id<Path_<'a>>;
impl<'a> FromEntity<'a> for Path_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Path(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Path_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PATH(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, edge_list) = param::<Vec<OrientedEdge<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            edge_list,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PathFeatureComponent_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PathFeatureComponent<'a> = Id<PathFeatureComponent_<'a>>;
impl<'a> FromEntity<'a> for PathFeatureComponent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PathFeatureComponent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PathFeatureComponent_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PATH_FEATURE_COMPONENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PathShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PathShapeRepresentation<'a> = Id<PathShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PathShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PathShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PathShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PATH_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PatternOffsetMembership_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PatternOffsetMembership<'a> = Id<PatternOffsetMembership_<'a>>;
impl<'a> FromEntity<'a> for PatternOffsetMembership_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PatternOffsetMembership(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PatternOffsetMembership_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PATTERN_OFFSET_MEMBERSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PatternOmitMembership_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PatternOmitMembership<'a> = Id<PatternOmitMembership_<'a>>;
impl<'a> FromEntity<'a> for PatternOmitMembership_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PatternOmitMembership(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PatternOmitMembership_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PATTERN_OMIT_MEMBERSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Pcurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Pcurve<'a> = Id<Pcurve_<'a>>;
impl<'a> FromEntity<'a> for Pcurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Pcurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Pcurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PCURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, basis_surface) = param::<Surface<'a>>(false, s)?;
        let (s, reference_to_curve) = param::<DefinitionalRepresentation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            basis_surface,
            reference_to_curve,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PcurveOrSurface_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PcurveOrSurface<'a> = Id<PcurveOrSurface_<'a>>;

#[derive(Debug)]
pub struct PerpendicularTo_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PerpendicularTo<'a> = Id<PerpendicularTo_<'a>>;
impl<'a> FromEntity<'a> for PerpendicularTo_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PerpendicularTo(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PerpendicularTo_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PERPENDICULAR_TO(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PerpendicularityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PerpendicularityTolerance<'a> = Id<PerpendicularityTolerance_<'a>>;
impl<'a> FromEntity<'a> for PerpendicularityTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PerpendicularityTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PerpendicularityTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PERPENDICULARITY_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, datum_system) = param::<Vec<DatumReference<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Person_<'a> { // entity
    pub id: Identifier<'a>,
    pub last_name: Option<Label<'a>>,
    pub first_name: Option<Label<'a>>,
    pub middle_names: Option<Vec<Label<'a>>>,
    pub prefix_titles: Option<Vec<Label<'a>>>,
    pub suffix_titles: Option<Vec<Label<'a>>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Person<'a> = Id<Person_<'a>>;
impl<'a> FromEntity<'a> for Person_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Person(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Person_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PERSON(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, last_name) = param::<Option<Label<'a>>>(false, s)?;
        let (s, first_name) = param::<Option<Label<'a>>>(false, s)?;
        let (s, middle_names) = param::<Option<Vec<Label<'a>>>>(false, s)?;
        let (s, prefix_titles) = param::<Option<Vec<Label<'a>>>>(false, s)?;
        let (s, suffix_titles) = param::<Option<Vec<Label<'a>>>>(true, s)?;
        Ok((s, Self {
            id,
            last_name,
            first_name,
            middle_names,
            prefix_titles,
            suffix_titles,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PersonAndOrganization_<'a> { // entity
    pub the_person: Person<'a>,
    pub the_organization: Organization<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganization<'a> = Id<PersonAndOrganization_<'a>>;
impl<'a> FromEntity<'a> for PersonAndOrganization_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PersonAndOrganization(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PersonAndOrganization_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PERSON_AND_ORGANIZATION(")(s)?;
        let (s, the_person) = param::<Person<'a>>(false, s)?;
        let (s, the_organization) = param::<Organization<'a>>(true, s)?;
        Ok((s, Self {
            the_person,
            the_organization,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct PersonAndOrganizationAddress_<'a> { // entity
    pub address__internal_location: Option<Label<'a>>,
    pub address__street_number: Option<Label<'a>>,
    pub address__street: Option<Label<'a>>,
    pub address__postal_box: Option<Label<'a>>,
    pub address__town: Option<Label<'a>>,
    pub address__region: Option<Label<'a>>,
    pub address__postal_code: Option<Label<'a>>,
    pub address__country: Option<Label<'a>>,
    pub address__facsimile_number: Option<Label<'a>>,
    pub address__telephone_number: Option<Label<'a>>,
    pub address__electronic_mail_address: Option<Label<'a>>,
    pub address__telex_number: Option<Label<'a>>,
    pub organizations: Vec<Organization<'a>>,
    pub organizational_address__description: Option<Text<'a>>,
    pub people: Vec<Person<'a>>,
    pub personal_address__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganizationAddress<'a> = Id<PersonAndOrganizationAddress_<'a>>;
impl<'a> FromEntity<'a> for PersonAndOrganizationAddress_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PersonAndOrganizationAddress(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PersonAndOrganizationAddress_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PERSON_AND_ORGANIZATION_ADDRESS(")(s)?;
        #[allow(non_snake_case)]
        let (s, address__internal_location) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, address__street_number) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, address__street) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, address__postal_box) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, address__town) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, address__region) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, address__postal_code) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, address__country) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, address__facsimile_number) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, address__telephone_number) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, address__electronic_mail_address) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, address__telex_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, organizations) = param::<Vec<Organization<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, organizational_address__description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, people) = param::<Vec<Person<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, personal_address__description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            address__internal_location,
            address__street_number,
            address__street,
            address__postal_box,
            address__town,
            address__region,
            address__postal_code,
            address__country,
            address__facsimile_number,
            address__telephone_number,
            address__electronic_mail_address,
            address__telex_number,
            organizations,
            organizational_address__description,
            people,
            personal_address__description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PersonAndOrganizationAssignment_<'a> { // entity
    pub assigned_person_and_organization: PersonAndOrganization<'a>,
    pub role: PersonAndOrganizationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganizationAssignment<'a> = Id<PersonAndOrganizationAssignment_<'a>>;
impl<'a> FromEntity<'a> for PersonAndOrganizationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PersonAndOrganizationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PersonAndOrganizationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PERSON_AND_ORGANIZATION_ASSIGNMENT(")(s)?;
        let (s, assigned_person_and_organization) = param::<PersonAndOrganization<'a>>(false, s)?;
        let (s, role) = param::<PersonAndOrganizationRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_person_and_organization,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PersonAndOrganizationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PersonAndOrganizationItem<'a> = Id<PersonAndOrganizationItem_<'a>>;

#[derive(Debug)]
pub struct PersonAndOrganizationRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganizationRole<'a> = Id<PersonAndOrganizationRole_<'a>>;
impl<'a> FromEntity<'a> for PersonAndOrganizationRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PersonAndOrganizationRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PersonAndOrganizationRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PERSON_AND_ORGANIZATION_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PersonOrganizationSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PersonOrganizationSelect<'a> = Id<PersonOrganizationSelect_<'a>>;

#[derive(Debug)]
pub struct PersonalAddress_<'a> { // entity
    pub internal_location: Option<Label<'a>>,
    pub street_number: Option<Label<'a>>,
    pub street: Option<Label<'a>>,
    pub postal_box: Option<Label<'a>>,
    pub town: Option<Label<'a>>,
    pub region: Option<Label<'a>>,
    pub postal_code: Option<Label<'a>>,
    pub country: Option<Label<'a>>,
    pub facsimile_number: Option<Label<'a>>,
    pub telephone_number: Option<Label<'a>>,
    pub electronic_mail_address: Option<Label<'a>>,
    pub telex_number: Option<Label<'a>>,
    pub people: Vec<Person<'a>>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonalAddress<'a> = Id<PersonalAddress_<'a>>;
impl<'a> FromEntity<'a> for PersonalAddress_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PersonalAddress(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PersonalAddress_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PERSONAL_ADDRESS(")(s)?;
        let (s, internal_location) = param::<Option<Label<'a>>>(false, s)?;
        let (s, street_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, street) = param::<Option<Label<'a>>>(false, s)?;
        let (s, postal_box) = param::<Option<Label<'a>>>(false, s)?;
        let (s, town) = param::<Option<Label<'a>>>(false, s)?;
        let (s, region) = param::<Option<Label<'a>>>(false, s)?;
        let (s, postal_code) = param::<Option<Label<'a>>>(false, s)?;
        let (s, country) = param::<Option<Label<'a>>>(false, s)?;
        let (s, facsimile_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, telephone_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, electronic_mail_address) = param::<Option<Label<'a>>>(false, s)?;
        let (s, telex_number) = param::<Option<Label<'a>>>(false, s)?;
        let (s, people) = param::<Vec<Person<'a>>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            internal_location,
            street_number,
            street,
            postal_box,
            town,
            region,
            postal_code,
            country,
            facsimile_number,
            telephone_number,
            electronic_mail_address,
            telex_number,
            people,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PhysicallyModelledProductDefinition_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    pub documentation_ids: Vec<Document<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PhysicallyModelledProductDefinition<'a> = Id<PhysicallyModelledProductDefinition_<'a>>;
impl<'a> FromEntity<'a> for PhysicallyModelledProductDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PhysicallyModelledProductDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PhysicallyModelledProductDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PHYSICALLY_MODELLED_PRODUCT_DEFINITION(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, formation) = param::<ProductDefinitionFormation<'a>>(false, s)?;
        let (s, frame_of_reference) = param::<ProductDefinitionContext<'a>>(false, s)?;
        let (s, documentation_ids) = param::<Vec<Document<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            description,
            formation,
            frame_of_reference,
            documentation_ids,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlacedDatumTargetFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub target_id: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlacedDatumTargetFeature<'a> = Id<PlacedDatumTargetFeature_<'a>>;
impl<'a> FromEntity<'a> for PlacedDatumTargetFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlacedDatumTargetFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlacedDatumTargetFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLACED_DATUM_TARGET_FEATURE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(false, s)?;
        let (s, target_id) = param::<Identifier<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            target_id,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlacedFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlacedFeature<'a> = Id<PlacedFeature_<'a>>;
impl<'a> FromEntity<'a> for PlacedFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlacedFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlacedFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLACED_FEATURE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Placement_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Placement<'a> = Id<Placement_<'a>>;
impl<'a> FromEntity<'a> for Placement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Placement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Placement_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLACEMENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, location) = param::<CartesianPoint<'a>>(true, s)?;
        Ok((s, Self {
            name,
            location,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlanarBox_<'a> { // entity
    pub name: Label<'a>,
    pub size_in_x: LengthMeasure<'a>,
    pub size_in_y: LengthMeasure<'a>,
    pub placement: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarBox<'a> = Id<PlanarBox_<'a>>;
impl<'a> FromEntity<'a> for PlanarBox_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarBox(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlanarBox_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLANAR_BOX(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, size_in_x) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, size_in_y) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, placement) = param::<Axis2Placement<'a>>(true, s)?;
        Ok((s, Self {
            name,
            size_in_x,
            size_in_y,
            placement,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlanarCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub curve_1: Curve<'a>,
    pub curve_2: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarCurvePair<'a> = Id<PlanarCurvePair_<'a>>;
impl<'a> FromEntity<'a> for PlanarCurvePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarCurvePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlanarCurvePair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLANAR_CURVE_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, curve_1) = param::<Curve<'a>>(false, s)?;
        let (s, curve_2) = param::<Curve<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            curve_1,
            curve_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlanarCurvePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_curve_1: TrimmedCurve<'a>,
    pub range_on_curve_2: TrimmedCurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarCurvePairRange<'a> = Id<PlanarCurvePairRange_<'a>>;
impl<'a> FromEntity<'a> for PlanarCurvePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarCurvePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlanarCurvePairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLANAR_CURVE_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, range_on_curve_1) = param::<TrimmedCurve<'a>>(false, s)?;
        let (s, range_on_curve_2) = param::<TrimmedCurve<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            range_on_curve_1,
            range_on_curve_2,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlanarExtent_<'a> { // entity
    pub name: Label<'a>,
    pub size_in_x: LengthMeasure<'a>,
    pub size_in_y: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarExtent<'a> = Id<PlanarExtent_<'a>>;
impl<'a> FromEntity<'a> for PlanarExtent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarExtent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlanarExtent_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLANAR_EXTENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, size_in_x) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, size_in_y) = param::<LengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            size_in_x,
            size_in_y,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlanarPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarPair<'a> = Id<PlanarPair_<'a>>;
impl<'a> FromEntity<'a> for PlanarPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlanarPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLANAR_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlanarPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub lower_limit_actual_translation_x: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation_x: TranslationalRangeMeasure<'a>,
    pub lower_limit_actual_translation_y: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation_y: TranslationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarPairRange<'a> = Id<PlanarPairRange_<'a>>;
impl<'a> FromEntity<'a> for PlanarPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlanarPairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLANAR_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, lower_limit_actual_rotation) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_actual_rotation) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, lower_limit_actual_translation_x) = param::<TranslationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_actual_translation_x) = param::<TranslationalRangeMeasure<'a>>(false, s)?;
        let (s, lower_limit_actual_translation_y) = param::<TranslationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_actual_translation_y) = param::<TranslationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_rotation,
            upper_limit_actual_rotation,
            lower_limit_actual_translation_x,
            upper_limit_actual_translation_x,
            lower_limit_actual_translation_y,
            upper_limit_actual_translation_y,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlanarPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    pub actual_translation_x: LengthMeasure<'a>,
    pub actual_translation_y: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarPairValue<'a> = Id<PlanarPairValue_<'a>>;
impl<'a> FromEntity<'a> for PlanarPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlanarPairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLANAR_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_rotation) = param::<PlaneAngleMeasure<'a>>(false, s)?;
        let (s, actual_translation_x) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, actual_translation_y) = param::<LengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_rotation,
            actual_translation_x,
            actual_translation_y,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlanarShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarShapeRepresentation<'a> = Id<PlanarShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PlanarShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlanarShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLANAR_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Plane_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Plane<'a> = Id<Plane_<'a>>;
impl<'a> FromEntity<'a> for Plane_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Plane(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Plane_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLANE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement3d<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlaneAngleMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for PlaneAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct PlaneAngleMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlaneAngleMeasureWithUnit<'a> = Id<PlaneAngleMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for PlaneAngleMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlaneAngleMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlaneAngleMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLANE_ANGLE_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlaneAngleUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlaneAngleUnit<'a> = Id<PlaneAngleUnit_<'a>>;
impl<'a> FromEntity<'a> for PlaneAngleUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlaneAngleUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlaneAngleUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLANE_ANGLE_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlaneOrPlanarBox_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PlaneOrPlanarBox<'a> = Id<PlaneOrPlanarBox_<'a>>;

#[derive(Debug)]
pub struct PlusExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlusExpression<'a> = Id<PlusExpression_<'a>>;
impl<'a> FromEntity<'a> for PlusExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlusExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlusExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLUS_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PlusMinusTolerance_<'a> { // entity
    pub range: ToleranceMethodDefinition<'a>,
    pub toleranced_dimension: DimensionalCharacteristic<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlusMinusTolerance<'a> = Id<PlusMinusTolerance_<'a>>;
impl<'a> FromEntity<'a> for PlusMinusTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlusMinusTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PlusMinusTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PLUS_MINUS_TOLERANCE(")(s)?;
        let (s, range) = param::<ToleranceMethodDefinition<'a>>(false, s)?;
        let (s, toleranced_dimension) = param::<DimensionalCharacteristic<'a>>(true, s)?;
        Ok((s, Self {
            range,
            toleranced_dimension,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Pocket_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Pocket<'a> = Id<Pocket_<'a>>;
impl<'a> FromEntity<'a> for Pocket_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Pocket(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Pocket_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POCKET(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PocketBottom_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PocketBottom<'a> = Id<PocketBottom_<'a>>;
impl<'a> FromEntity<'a> for PocketBottom_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PocketBottom(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PocketBottom_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POCKET_BOTTOM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Point_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Point<'a> = Id<Point_<'a>>;
impl<'a> FromEntity<'a> for Point_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Point(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Point_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PointOnCurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub point_parameter: ParameterValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnCurve<'a> = Id<PointOnCurve_<'a>>;
impl<'a> FromEntity<'a> for PointOnCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PointOnCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT_ON_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, basis_curve) = param::<Curve<'a>>(false, s)?;
        let (s, point_parameter) = param::<ParameterValue<'a>>(true, s)?;
        Ok((s, Self {
            name,
            basis_curve,
            point_parameter,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PointOnPlanarCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pair_curve: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnPlanarCurvePair<'a> = Id<PointOnPlanarCurvePair_<'a>>;
impl<'a> FromEntity<'a> for PointOnPlanarCurvePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnPlanarCurvePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PointOnPlanarCurvePair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT_ON_PLANAR_CURVE_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, pair_curve) = param::<Curve<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            pair_curve,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PointOnPlanarCurvePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_pair_curve: TrimmedCurve<'a>,
    pub lower_limit_yaw: RotationalRangeMeasure<'a>,
    pub upper_limit_yaw: RotationalRangeMeasure<'a>,
    pub lower_limit_pitch: RotationalRangeMeasure<'a>,
    pub upper_limit_pitch: RotationalRangeMeasure<'a>,
    pub lower_limit_roll: RotationalRangeMeasure<'a>,
    pub upper_limit_roll: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnPlanarCurvePairRange<'a> = Id<PointOnPlanarCurvePairRange_<'a>>;
impl<'a> FromEntity<'a> for PointOnPlanarCurvePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnPlanarCurvePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PointOnPlanarCurvePairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT_ON_PLANAR_CURVE_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, range_on_pair_curve) = param::<TrimmedCurve<'a>>(false, s)?;
        let (s, lower_limit_yaw) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_yaw) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, lower_limit_pitch) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_pitch) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, lower_limit_roll) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_roll) = param::<RotationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            range_on_pair_curve,
            lower_limit_yaw,
            upper_limit_yaw,
            lower_limit_pitch,
            upper_limit_pitch,
            lower_limit_roll,
            upper_limit_roll,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PointOnPlanarCurvePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_curve: PointOnCurve<'a>,
    pub input_orientation: SpatialRotation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnPlanarCurvePairValue<'a> = Id<PointOnPlanarCurvePairValue_<'a>>;
impl<'a> FromEntity<'a> for PointOnPlanarCurvePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnPlanarCurvePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PointOnPlanarCurvePairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT_ON_PLANAR_CURVE_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_point_on_curve) = param::<PointOnCurve<'a>>(false, s)?;
        let (s, input_orientation) = param::<SpatialRotation<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_curve,
            input_orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PointOnSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub point_parameter_u: ParameterValue<'a>,
    pub point_parameter_v: ParameterValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurface<'a> = Id<PointOnSurface_<'a>>;
impl<'a> FromEntity<'a> for PointOnSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PointOnSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT_ON_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, basis_surface) = param::<Surface<'a>>(false, s)?;
        let (s, point_parameter_u) = param::<ParameterValue<'a>>(false, s)?;
        let (s, point_parameter_v) = param::<ParameterValue<'a>>(true, s)?;
        Ok((s, Self {
            name,
            basis_surface,
            point_parameter_u,
            point_parameter_v,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PointOnSurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pair_surface: Surface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurfacePair<'a> = Id<PointOnSurfacePair_<'a>>;
impl<'a> FromEntity<'a> for PointOnSurfacePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnSurfacePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PointOnSurfacePair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT_ON_SURFACE_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, pair_surface) = param::<Surface<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            pair_surface,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PointOnSurfacePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_pair_surface: RectangularTrimmedSurface<'a>,
    pub lower_limit_yaw: RotationalRangeMeasure<'a>,
    pub upper_limit_yaw: RotationalRangeMeasure<'a>,
    pub lower_limit_pitch: RotationalRangeMeasure<'a>,
    pub upper_limit_pitch: RotationalRangeMeasure<'a>,
    pub lower_limit_roll: RotationalRangeMeasure<'a>,
    pub upper_limit_roll: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurfacePairRange<'a> = Id<PointOnSurfacePairRange_<'a>>;
impl<'a> FromEntity<'a> for PointOnSurfacePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnSurfacePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PointOnSurfacePairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT_ON_SURFACE_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, range_on_pair_surface) = param::<RectangularTrimmedSurface<'a>>(false, s)?;
        let (s, lower_limit_yaw) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_yaw) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, lower_limit_pitch) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_pitch) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, lower_limit_roll) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_roll) = param::<RotationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            range_on_pair_surface,
            lower_limit_yaw,
            upper_limit_yaw,
            lower_limit_pitch,
            upper_limit_pitch,
            lower_limit_roll,
            upper_limit_roll,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PointOnSurfacePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_surface: PointOnSurface<'a>,
    pub input_orientation: SpatialRotation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurfacePairValue<'a> = Id<PointOnSurfacePairValue_<'a>>;
impl<'a> FromEntity<'a> for PointOnSurfacePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnSurfacePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PointOnSurfacePairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT_ON_SURFACE_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_point_on_surface) = param::<PointOnSurface<'a>>(false, s)?;
        let (s, input_orientation) = param::<SpatialRotation<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_surface,
            input_orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PointPlacementShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointPlacementShapeRepresentation<'a> = Id<PointPlacementShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PointPlacementShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointPlacementShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PointPlacementShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT_PLACEMENT_SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PointReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_pt: Point<'a>,
    pub transformation: CartesianTransformationOperator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointReplica<'a> = Id<PointReplica_<'a>>;
impl<'a> FromEntity<'a> for PointReplica_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointReplica(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PointReplica_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT_REPLICA(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, parent_pt) = param::<Point<'a>>(false, s)?;
        let (s, transformation) = param::<CartesianTransformationOperator<'a>>(true, s)?;
        Ok((s, Self {
            name,
            parent_pt,
            transformation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PointStyle_<'a> { // entity
    pub name: Label<'a>,
    pub marker: MarkerSelect<'a>,
    pub marker_size: SizeSelect<'a>,
    pub marker_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointStyle<'a> = Id<PointStyle_<'a>>;
impl<'a> FromEntity<'a> for PointStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PointStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POINT_STYLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, marker) = param::<MarkerSelect<'a>>(false, s)?;
        let (s, marker_size) = param::<SizeSelect<'a>>(false, s)?;
        let (s, marker_colour) = param::<Colour<'a>>(true, s)?;
        Ok((s, Self {
            name,
            marker,
            marker_size,
            marker_colour,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct PolyLoop_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub polygon: Vec<CartesianPoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PolyLoop<'a> = Id<PolyLoop_<'a>>;
impl<'a> FromEntity<'a> for PolyLoop_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PolyLoop(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PolyLoop_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POLY_LOOP(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        let (s, polygon) = param::<Vec<CartesianPoint<'a>>>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            polygon,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Polyline_<'a> { // entity
    pub name: Label<'a>,
    pub points: Vec<CartesianPoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Polyline<'a> = Id<Polyline_<'a>>;
impl<'a> FromEntity<'a> for Polyline_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Polyline(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Polyline_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POLYLINE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, points) = param::<Vec<CartesianPoint<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            points,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PositionTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PositionTolerance<'a> = Id<PositionTolerance_<'a>>;
impl<'a> FromEntity<'a> for PositionTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PositionTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PositionTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POSITION_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}

#[derive(Debug)]
pub struct PositiveLengthMeasure<'a>(pub NonNegativeLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositiveLengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(NonNegativeLengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct PositivePlaneAngleMeasure<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositivePlaneAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct PositiveRatioMeasure<'a>(pub RatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositiveRatioMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(RatioMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct PowerExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PowerExpression<'a> = Id<PowerExpression_<'a>>;
impl<'a> FromEntity<'a> for PowerExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PowerExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PowerExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("POWER_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PreDefinedColour_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedColour<'a> = Id<PreDefinedColour_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedColour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedColour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedColour_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_COLOUR(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PreDefinedCurveFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedCurveFont<'a> = Id<PreDefinedCurveFont_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedCurveFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedCurveFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedCurveFont_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_CURVE_FONT(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PreDefinedDimensionSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedDimensionSymbol<'a> = Id<PreDefinedDimensionSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedDimensionSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedDimensionSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedDimensionSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_DIMENSION_SYMBOL(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PreDefinedGeometricalToleranceSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedGeometricalToleranceSymbol<'a> = Id<PreDefinedGeometricalToleranceSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedGeometricalToleranceSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedGeometricalToleranceSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedGeometricalToleranceSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PreDefinedItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedItem<'a> = Id<PreDefinedItem_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PreDefinedMarker_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedMarker<'a> = Id<PreDefinedMarker_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedMarker_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedMarker(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedMarker_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_MARKER(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct PreDefinedPointMarkerSymbol_<'a> { // entity
    pub pre_defined_item__name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedPointMarkerSymbol<'a> = Id<PreDefinedPointMarkerSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedPointMarkerSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedPointMarkerSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedPointMarkerSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_POINT_MARKER_SYMBOL(")(s)?;
        #[allow(non_snake_case)]
        let (s, pre_defined_item__name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            pre_defined_item__name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PreDefinedPresentationStyle_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedPresentationStyle<'a> = Id<PreDefinedPresentationStyle_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedPresentationStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedPresentationStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedPresentationStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_PRESENTATION_STYLE(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PreDefinedSurfaceConditionSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedSurfaceConditionSymbol<'a> = Id<PreDefinedSurfaceConditionSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedSurfaceConditionSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedSurfaceConditionSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedSurfaceConditionSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_SURFACE_CONDITION_SYMBOL(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PreDefinedSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedSymbol<'a> = Id<PreDefinedSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_SYMBOL(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PreDefinedTerminatorSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedTerminatorSymbol<'a> = Id<PreDefinedTerminatorSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedTerminatorSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedTerminatorSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedTerminatorSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_TERMINATOR_SYMBOL(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PreDefinedTextFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedTextFont<'a> = Id<PreDefinedTextFont_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedTextFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedTextFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PreDefinedTextFont_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRE_DEFINED_TEXT_FONT(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PrecisionQualifier_<'a> { // entity
    pub precision_value: i64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrecisionQualifier<'a> = Id<PrecisionQualifier_<'a>>;
impl<'a> FromEntity<'a> for PrecisionQualifier_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PrecisionQualifier(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PrecisionQualifier_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRECISION_QUALIFIER(")(s)?;
        let (s, precision_value) = param::<i64>(true, s)?;
        Ok((s, Self {
            precision_value,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum PreferredSurfaceCurveRepresentation<'a> { // enum
    Curve3d,
    PcurveS1,
    PcurveS2,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for PreferredSurfaceCurveRepresentation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use PreferredSurfaceCurveRepresentation::*;
        alt((
            map(tag(".CURVE_3D."), |_| Curve3d),
            map(tag(".PCURVE_S1."), |_| PcurveS1),
            map(tag(".PCURVE_S2."), |_| PcurveS2),
        ))(s)
    }
}
#[derive(Debug)]
pub struct PresentableText<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for PresentableText<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct PresentationArea_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationArea<'a> = Id<PresentationArea_<'a>>;
impl<'a> FromEntity<'a> for PresentationArea_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationArea(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PresentationArea_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTATION_AREA(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PresentationLayerAssignment_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub assigned_items: Vec<LayeredItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationLayerAssignment<'a> = Id<PresentationLayerAssignment_<'a>>;
impl<'a> FromEntity<'a> for PresentationLayerAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationLayerAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PresentationLayerAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTATION_LAYER_ASSIGNMENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, assigned_items) = param::<Vec<LayeredItem<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            assigned_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PresentationRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationRepresentation<'a> = Id<PresentationRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PresentationRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PresentationRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTATION_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PresentationRepresentationSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PresentationRepresentationSelect<'a> = Id<PresentationRepresentationSelect_<'a>>;

#[derive(Debug)]
pub struct PresentationSet_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationSet<'a> = Id<PresentationSet_<'a>>;
impl<'a> FromEntity<'a> for PresentationSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PresentationSet_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTATION_SET(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PresentationSize_<'a> { // entity
    pub unit: PresentationSizeAssignmentSelect<'a>,
    pub size: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationSize<'a> = Id<PresentationSize_<'a>>;
impl<'a> FromEntity<'a> for PresentationSize_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationSize(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PresentationSize_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTATION_SIZE(")(s)?;
        let (s, unit) = param::<PresentationSizeAssignmentSelect<'a>>(false, s)?;
        let (s, size) = param::<PlanarBox<'a>>(true, s)?;
        Ok((s, Self {
            unit,
            size,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PresentationSizeAssignmentSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PresentationSizeAssignmentSelect<'a> = Id<PresentationSizeAssignmentSelect_<'a>>;

#[derive(Debug)]
pub struct PresentationStyleAssignment_<'a> { // entity
    pub styles: Vec<PresentationStyleSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationStyleAssignment<'a> = Id<PresentationStyleAssignment_<'a>>;
impl<'a> FromEntity<'a> for PresentationStyleAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationStyleAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PresentationStyleAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTATION_STYLE_ASSIGNMENT(")(s)?;
        let (s, styles) = param::<Vec<PresentationStyleSelect<'a>>>(true, s)?;
        Ok((s, Self {
            styles,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PresentationStyleByContext_<'a> { // entity
    pub styles: Vec<PresentationStyleSelect<'a>>,
    pub style_context: StyleContextSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationStyleByContext<'a> = Id<PresentationStyleByContext_<'a>>;
impl<'a> FromEntity<'a> for PresentationStyleByContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationStyleByContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PresentationStyleByContext_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTATION_STYLE_BY_CONTEXT(")(s)?;
        let (s, styles) = param::<Vec<PresentationStyleSelect<'a>>>(false, s)?;
        let (s, style_context) = param::<StyleContextSelect<'a>>(true, s)?;
        Ok((s, Self {
            styles,
            style_context,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum PresentationStyleSelect<'a> { // select
    PreDefinedPresentationStyle(PreDefinedPresentationStyle<'a>),
    PointStyle(PointStyle<'a>),
    CurveStyle(CurveStyle<'a>),
    SurfaceStyleUsage(SurfaceStyleUsage<'a>),
    SymbolStyle(SymbolStyle<'a>),
    FillAreaStyle(FillAreaStyle<'a>),
    TextStyle(TextStyle<'a>),
    ApproximationTolerance(ApproximationTolerance<'a>),
    ExternallyDefinedStyle(ExternallyDefinedStyle<'a>),
    NullStyle(NullStyle<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PresentationStyleSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PreDefinedPresentationStyle<'a>>::parse, |r| PresentationStyleSelect::PreDefinedPresentationStyle(r)),
            map(<PointStyle<'a>>::parse, |r| PresentationStyleSelect::PointStyle(r)),
            map(<CurveStyle<'a>>::parse, |r| PresentationStyleSelect::CurveStyle(r)),
            map(<SurfaceStyleUsage<'a>>::parse, |r| PresentationStyleSelect::SurfaceStyleUsage(r)),
            map(<SymbolStyle<'a>>::parse, |r| PresentationStyleSelect::SymbolStyle(r)),
            map(<FillAreaStyle<'a>>::parse, |r| PresentationStyleSelect::FillAreaStyle(r)),
            map(<TextStyle<'a>>::parse, |r| PresentationStyleSelect::TextStyle(r)),
            map(<ApproximationTolerance<'a>>::parse, |r| PresentationStyleSelect::ApproximationTolerance(r)),
            map(<ExternallyDefinedStyle<'a>>::parse, |r| PresentationStyleSelect::ExternallyDefinedStyle(r)),
            map(delimited(tag("NULL_STYLE("), <NullStyle<'a>>::parse, char(')')), |r| PresentationStyleSelect::NullStyle(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct PresentationView_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationView<'a> = Id<PresentationView_<'a>>;
impl<'a> FromEntity<'a> for PresentationView_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationView(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PresentationView_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTATION_VIEW(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PresentedItem_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentedItem<'a> = Id<PresentedItem_<'a>>;
impl<'a> FromEntity<'a> for PresentedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PresentedItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTED_ITEM(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PresentedItemRepresentation_<'a> { // entity
    pub presentation: PresentationRepresentationSelect<'a>,
    pub item: PresentedItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentedItemRepresentation<'a> = Id<PresentedItemRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PresentedItemRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentedItemRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PresentedItemRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTED_ITEM_REPRESENTATION(")(s)?;
        let (s, presentation) = param::<PresentationRepresentationSelect<'a>>(false, s)?;
        let (s, item) = param::<PresentedItem<'a>>(true, s)?;
        Ok((s, Self {
            presentation,
            item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PresentedItemSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PresentedItemSelect<'a> = Id<PresentedItemSelect_<'a>>;

#[derive(Debug)]
pub struct PrismaticPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrismaticPair<'a> = Id<PrismaticPair_<'a>>;
impl<'a> FromEntity<'a> for PrismaticPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PrismaticPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PrismaticPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRISMATIC_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PrismaticPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_translation: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation: TranslationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrismaticPairRange<'a> = Id<PrismaticPairRange_<'a>>;
impl<'a> FromEntity<'a> for PrismaticPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PrismaticPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PrismaticPairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRISMATIC_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, lower_limit_actual_translation) = param::<TranslationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_actual_translation) = param::<TranslationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_translation,
            upper_limit_actual_translation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PrismaticPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_translation: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrismaticPairValue<'a> = Id<PrismaticPairValue_<'a>>;
impl<'a> FromEntity<'a> for PrismaticPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PrismaticPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PrismaticPairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRISMATIC_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_translation) = param::<LengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_translation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProcessOperation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub consequence: Text<'a>,
    pub purpose: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessOperation<'a> = Id<ProcessOperation_<'a>>;
impl<'a> FromEntity<'a> for ProcessOperation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProcessOperation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProcessOperation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROCESS_OPERATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, consequence) = param::<Text<'a>>(false, s)?;
        let (s, purpose) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            consequence,
            purpose,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProcessPlan_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessPlan<'a> = Id<ProcessPlan_<'a>>;
impl<'a> FromEntity<'a> for ProcessPlan_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProcessPlan(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProcessPlan_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROCESS_PLAN(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, chosen_method) = param::<ActionMethod<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProcessProductAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub defined_product: CharacterizedProductDefinition<'a>,
    pub process: ProductDefinitionProcess<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessProductAssociation<'a> = Id<ProcessProductAssociation_<'a>>;
impl<'a> FromEntity<'a> for ProcessProductAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProcessProductAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProcessProductAssociation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROCESS_PRODUCT_ASSOCIATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, defined_product) = param::<CharacterizedProductDefinition<'a>>(false, s)?;
        let (s, process) = param::<ProductDefinitionProcess<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            defined_product,
            process,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProcessPropertyAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub process: PropertyProcess<'a>,
    pub property_or_shape: PropertyOrShapeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessPropertyAssociation<'a> = Id<ProcessPropertyAssociation_<'a>>;
impl<'a> FromEntity<'a> for ProcessPropertyAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProcessPropertyAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProcessPropertyAssociation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROCESS_PROPERTY_ASSOCIATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, process) = param::<PropertyProcess<'a>>(false, s)?;
        let (s, property_or_shape) = param::<PropertyOrShapeSelect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            process,
            property_or_shape,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Product_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub frame_of_reference: Vec<ProductContext<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Product<'a> = Id<Product_<'a>>;
impl<'a> FromEntity<'a> for Product_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Product(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Product_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, frame_of_reference) = param::<Vec<ProductContext<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            frame_of_reference,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductCategory<'a> = Id<ProductCategory_<'a>>;
impl<'a> FromEntity<'a> for ProductCategory_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductCategory(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductCategory_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_CATEGORY(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductCategoryRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub category: ProductCategory<'a>,
    pub sub_category: ProductCategory<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductCategoryRelationship<'a> = Id<ProductCategoryRelationship_<'a>>;
impl<'a> FromEntity<'a> for ProductCategoryRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductCategoryRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductCategoryRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_CATEGORY_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, category) = param::<ProductCategory<'a>>(false, s)?;
        let (s, sub_category) = param::<ProductCategory<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            category,
            sub_category,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct ProductClass_<'a> { // entity
    pub id: Identifier<'a>,
    pub product_concept__name: Label<'a>,
    pub product_concept__description: Option<Text<'a>>,
    pub market_context: ProductConceptContext<'a>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductClass<'a> = Id<ProductClass_<'a>>;
impl<'a> FromEntity<'a> for ProductClass_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductClass(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductClass_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_CLASS(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, product_concept__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, product_concept__description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, market_context) = param::<ProductConceptContext<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            product_concept__name,
            product_concept__description,
            market_context,
            characterized_object__name,
            characterized_object__description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductConcept_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub market_context: ProductConceptContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConcept<'a> = Id<ProductConcept_<'a>>;
impl<'a> FromEntity<'a> for ProductConcept_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConcept(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductConcept_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_CONCEPT(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, market_context) = param::<ProductConceptContext<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            market_context,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductConceptContext_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    pub market_segment_type: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptContext<'a> = Id<ProductConceptContext_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductConceptContext_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_CONCEPT_CONTEXT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, frame_of_reference) = param::<ApplicationContext<'a>>(false, s)?;
        let (s, market_segment_type) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            frame_of_reference,
            market_segment_type,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeature<'a> = Id<ProductConceptFeature_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductConceptFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_CONCEPT_FEATURE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductConceptFeatureAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub concept: ProductConcept<'a>,
    pub feature: ProductConceptFeature<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeatureAssociation<'a> = Id<ProductConceptFeatureAssociation_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptFeatureAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptFeatureAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductConceptFeatureAssociation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_CONCEPT_FEATURE_ASSOCIATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, concept) = param::<ProductConcept<'a>>(false, s)?;
        let (s, feature) = param::<ProductConceptFeature<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            concept,
            feature,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductConceptFeatureCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeatureCategory<'a> = Id<ProductConceptFeatureCategory_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptFeatureCategory_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptFeatureCategory(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductConceptFeatureCategory_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_CONCEPT_FEATURE_CATEGORY(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductConceptFeatureCategoryUsage_<'a> { // entity
    pub assigned_group: Group<'a>,
    pub items: Vec<CategoryUsageItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeatureCategoryUsage<'a> = Id<ProductConceptFeatureCategoryUsage_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptFeatureCategoryUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptFeatureCategoryUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductConceptFeatureCategoryUsage_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE(")(s)?;
        let (s, assigned_group) = param::<Group<'a>>(false, s)?;
        let (s, items) = param::<Vec<CategoryUsageItem<'a>>>(true, s)?;
        Ok((s, Self {
            assigned_group,
            items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductConceptRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_concept: ProductConcept<'a>,
    pub related_product_concept: ProductConcept<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptRelationship<'a> = Id<ProductConceptRelationship_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductConceptRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_CONCEPT_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_concept) = param::<ProductConcept<'a>>(false, s)?;
        let (s, related_product_concept) = param::<ProductConcept<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_product_concept,
            related_product_concept,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductContext_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    pub discipline_type: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductContext<'a> = Id<ProductContext_<'a>>;
impl<'a> FromEntity<'a> for ProductContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductContext_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_CONTEXT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, frame_of_reference) = param::<ApplicationContext<'a>>(false, s)?;
        let (s, discipline_type) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            frame_of_reference,
            discipline_type,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinition_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinition<'a> = Id<ProductDefinition_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, formation) = param::<ProductDefinitionFormation<'a>>(false, s)?;
        let (s, frame_of_reference) = param::<ProductDefinitionContext<'a>>(true, s)?;
        Ok((s, Self {
            id,
            description,
            formation,
            frame_of_reference,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionContext_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    pub life_cycle_stage: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionContext<'a> = Id<ProductDefinitionContext_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionContext_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_CONTEXT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, frame_of_reference) = param::<ApplicationContext<'a>>(false, s)?;
        let (s, life_cycle_stage) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            frame_of_reference,
            life_cycle_stage,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionContextAssociation_<'a> { // entity
    pub definition: ProductDefinition<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    pub role: ProductDefinitionContextRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionContextAssociation<'a> = Id<ProductDefinitionContextAssociation_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionContextAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionContextAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionContextAssociation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_CONTEXT_ASSOCIATION(")(s)?;
        let (s, definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, frame_of_reference) = param::<ProductDefinitionContext<'a>>(false, s)?;
        let (s, role) = param::<ProductDefinitionContextRole<'a>>(true, s)?;
        Ok((s, Self {
            definition,
            frame_of_reference,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionContextRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionContextRole<'a> = Id<ProductDefinitionContextRole_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionContextRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionContextRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionContextRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_CONTEXT_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub usage: ProductDefinitionRelationship<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionEffectivity<'a> = Id<ProductDefinitionEffectivity_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionEffectivity_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_EFFECTIVITY(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, usage) = param::<ProductDefinitionRelationship<'a>>(true, s)?;
        Ok((s, Self {
            id,
            usage,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionFormation_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub of_product: Product<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionFormation<'a> = Id<ProductDefinitionFormation_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionFormation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionFormation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionFormation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_FORMATION(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_product) = param::<Product<'a>>(true, s)?;
        Ok((s, Self {
            id,
            description,
            of_product,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionFormationRelationship_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition_formation: ProductDefinitionFormation<'a>,
    pub related_product_definition_formation: ProductDefinitionFormation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionFormationRelationship<'a> = Id<ProductDefinitionFormationRelationship_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionFormationRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionFormationRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionFormationRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_FORMATION_RELATIONSHIP(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_definition_formation) = param::<ProductDefinitionFormation<'a>>(false, s)?;
        let (s, related_product_definition_formation) = param::<ProductDefinitionFormation<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition_formation,
            related_product_definition_formation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionFormationWithSpecifiedSource_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub of_product: Product<'a>,
    pub make_or_buy: Source<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionFormationWithSpecifiedSource<'a> = Id<ProductDefinitionFormationWithSpecifiedSource_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionFormationWithSpecifiedSource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionFormationWithSpecifiedSource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionFormationWithSpecifiedSource_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_product) = param::<Product<'a>>(false, s)?;
        let (s, make_or_buy) = param::<Source<'a>>(true, s)?;
        Ok((s, Self {
            id,
            description,
            of_product,
            make_or_buy,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionOccurrenceRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub occurrence: ProductDefinition<'a>,
    pub occurrence_usage: AssemblyComponentUsage<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionOccurrenceRelationship<'a> = Id<ProductDefinitionOccurrenceRelationship_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionOccurrenceRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionOccurrenceRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionOccurrenceRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, occurrence) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, occurrence_usage) = param::<AssemblyComponentUsage<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            occurrence,
            occurrence_usage,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionProcess_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionProcess<'a> = Id<ProductDefinitionProcess_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionProcess_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionProcess(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionProcess_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_PROCESS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, chosen_method) = param::<ActionMethod<'a>>(false, s)?;
        let (s, identification) = param::<Identifier<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            identification,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionRelationship_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionRelationship<'a> = Id<ProductDefinitionRelationship_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_RELATIONSHIP(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, related_product_definition) = param::<ProductDefinition<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct ProductDefinitionResource_<'a> { // entity
    pub name: Label<'a>,
    pub action_resource__description: Option<Text<'a>>,
    pub usage: Vec<SupportedItem<'a>>,
    pub kind: ActionResourceType<'a>,
    pub id: Identifier<'a>,
    pub product_definition__description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionResource<'a> = Id<ProductDefinitionResource_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionResource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionResource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionResource_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_RESOURCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, action_resource__description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, usage) = param::<Vec<SupportedItem<'a>>>(false, s)?;
        let (s, kind) = param::<ActionResourceType<'a>>(false, s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, product_definition__description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, formation) = param::<ProductDefinitionFormation<'a>>(false, s)?;
        let (s, frame_of_reference) = param::<ProductDefinitionContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            action_resource__description,
            usage,
            kind,
            id,
            product_definition__description,
            formation,
            frame_of_reference,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionShape_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionShape<'a> = Id<ProductDefinitionShape_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionShape_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionShape(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionShape_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_SHAPE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, definition) = param::<CharacterizedDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            definition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionSubstitute_<'a> { // entity
    pub description: Option<Text<'a>>,
    pub context_relationship: ProductDefinitionRelationship<'a>,
    pub substitute_definition: ProductDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionSubstitute<'a> = Id<ProductDefinitionSubstitute_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionSubstitute_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionSubstitute(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionSubstitute_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_SUBSTITUTE(")(s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, context_relationship) = param::<ProductDefinitionRelationship<'a>>(false, s)?;
        let (s, substitute_definition) = param::<ProductDefinition<'a>>(true, s)?;
        Ok((s, Self {
            description,
            context_relationship,
            substitute_definition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionUsage_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionUsage<'a> = Id<ProductDefinitionUsage_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionUsage_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_USAGE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, related_product_definition) = param::<ProductDefinition<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductDefinitionWithAssociatedDocuments_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    pub documentation_ids: Vec<Document<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionWithAssociatedDocuments<'a> = Id<ProductDefinitionWithAssociatedDocuments_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionWithAssociatedDocuments_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionWithAssociatedDocuments(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductDefinitionWithAssociatedDocuments_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, formation) = param::<ProductDefinitionFormation<'a>>(false, s)?;
        let (s, frame_of_reference) = param::<ProductDefinitionContext<'a>>(false, s)?;
        let (s, documentation_ids) = param::<Vec<Document<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            description,
            formation,
            frame_of_reference,
            documentation_ids,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct ProductIdentification_<'a> { // entity
    pub id: Identifier<'a>,
    pub configuration_item__name: Label<'a>,
    pub configuration_item__description: Option<Text<'a>>,
    pub item_concept: ProductConcept<'a>,
    pub purpose: Option<Label<'a>>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductIdentification<'a> = Id<ProductIdentification_<'a>>;
impl<'a> FromEntity<'a> for ProductIdentification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductIdentification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductIdentification_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_IDENTIFICATION(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, item_concept) = param::<ProductConcept<'a>>(false, s)?;
        let (s, purpose) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            configuration_item__name,
            configuration_item__description,
            item_concept,
            purpose,
            characterized_object__name,
            characterized_object__description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductOrFormationOrDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ProductOrFormationOrDefinition<'a> = Id<ProductOrFormationOrDefinition_<'a>>;

#[derive(Debug)]
pub enum ProductOrPresentationSpace<'a> { // enum
    ProductShapeSpace,
    PresentationAreaSpace,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ProductOrPresentationSpace<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ProductOrPresentationSpace::*;
        alt((
            map(tag(".PRODUCT_SHAPE_SPACE."), |_| ProductShapeSpace),
            map(tag(".PRESENTATION_AREA_SPACE."), |_| PresentationAreaSpace),
        ))(s)
    }
}
#[derive(Debug)]
pub struct ProductProcessPlan_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductProcessPlan<'a> = Id<ProductProcessPlan_<'a>>;
impl<'a> FromEntity<'a> for ProductProcessPlan_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductProcessPlan(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductProcessPlan_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_PROCESS_PLAN(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, chosen_method) = param::<ActionMethod<'a>>(false, s)?;
        let (s, identification) = param::<Identifier<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            identification,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProductRelatedProductCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub products: Vec<Product<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductRelatedProductCategory<'a> = Id<ProductRelatedProductCategory_<'a>>;
impl<'a> FromEntity<'a> for ProductRelatedProductCategory_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductRelatedProductCategory(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductRelatedProductCategory_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_RELATED_PRODUCT_CATEGORY(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, products) = param::<Vec<Product<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            products,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct ProductSpecification_<'a> { // entity
    pub configuration_item__id: Identifier<'a>,
    pub configuration_item__name: Label<'a>,
    pub configuration_item__description: Option<Text<'a>>,
    pub configuration_item__item_concept: ProductConcept<'a>,
    pub configuration_item__purpose: Option<Label<'a>>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    pub item_concept_feature: Vec<ProductConceptFeatureAssociation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductSpecification<'a> = Id<ProductSpecification_<'a>>;
impl<'a> FromEntity<'a> for ProductSpecification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductSpecification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProductSpecification_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PRODUCT_SPECIFICATION(")(s)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__id) = param::<Identifier<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__description) = param::<Option<Text<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__item_concept) = param::<ProductConcept<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__purpose) = param::<Option<Label<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, item_concept_feature) = param::<Vec<ProductConceptFeatureAssociation<'a>>>(true, s)?;
        Ok((s, Self {
            configuration_item__id,
            configuration_item__name,
            configuration_item__description,
            configuration_item__item_concept,
            configuration_item__purpose,
            characterized_object__name,
            characterized_object__description,
            item_concept_feature,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProjectedZoneDefinition_<'a> { // entity
    pub zone: ToleranceZone<'a>,
    pub boundaries: Vec<ShapeAspect<'a>>,
    pub projection_end: ShapeAspect<'a>,
    pub projected_length: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProjectedZoneDefinition<'a> = Id<ProjectedZoneDefinition_<'a>>;
impl<'a> FromEntity<'a> for ProjectedZoneDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProjectedZoneDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProjectedZoneDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROJECTED_ZONE_DEFINITION(")(s)?;
        let (s, zone) = param::<ToleranceZone<'a>>(false, s)?;
        let (s, boundaries) = param::<Vec<ShapeAspect<'a>>>(false, s)?;
        let (s, projection_end) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, projected_length) = param::<MeasureWithUnit<'a>>(true, s)?;
        Ok((s, Self {
            zone,
            boundaries,
            projection_end,
            projected_length,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProjectionCurve_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProjectionCurve<'a> = Id<ProjectionCurve_<'a>>;
impl<'a> FromEntity<'a> for ProjectionCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProjectionCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProjectionCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROJECTION_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ProjectionDirectedCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProjectionDirectedCallout<'a> = Id<ProjectionDirectedCallout_<'a>>;
impl<'a> FromEntity<'a> for ProjectionDirectedCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProjectionDirectedCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ProjectionDirectedCallout_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROJECTION_DIRECTED_CALLOUT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PromissoryUsageOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PromissoryUsageOccurrence<'a> = Id<PromissoryUsageOccurrence_<'a>>;
impl<'a> FromEntity<'a> for PromissoryUsageOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PromissoryUsageOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PromissoryUsageOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROMISSORY_USAGE_OCCURRENCE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, related_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, reference_designator) = param::<Option<Identifier<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            reference_designator,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PropertyDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyDefinition<'a> = Id<PropertyDefinition_<'a>>;
impl<'a> FromEntity<'a> for PropertyDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PropertyDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PropertyDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROPERTY_DEFINITION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, definition) = param::<CharacterizedDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            definition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PropertyDefinitionRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_property_definition: PropertyDefinition<'a>,
    pub related_property_definition: PropertyDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyDefinitionRelationship<'a> = Id<PropertyDefinitionRelationship_<'a>>;
impl<'a> FromEntity<'a> for PropertyDefinitionRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PropertyDefinitionRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PropertyDefinitionRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROPERTY_DEFINITION_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, relating_property_definition) = param::<PropertyDefinition<'a>>(false, s)?;
        let (s, related_property_definition) = param::<PropertyDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_property_definition,
            related_property_definition,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PropertyDefinitionRepresentation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyDefinitionRepresentation<'a> = Id<PropertyDefinitionRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PropertyDefinitionRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PropertyDefinitionRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PropertyDefinitionRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROPERTY_DEFINITION_REPRESENTATION(")(s)?;
        let (s, definition) = param::<RepresentedDefinition<'a>>(false, s)?;
        let (s, used_representation) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            definition,
            used_representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct PropertyOrShapeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PropertyOrShapeSelect<'a> = Id<PropertyOrShapeSelect_<'a>>;

#[derive(Debug)]
pub struct PropertyProcess_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyProcess<'a> = Id<PropertyProcess_<'a>>;
impl<'a> FromEntity<'a> for PropertyProcess_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PropertyProcess(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for PropertyProcess_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("PROPERTY_PROCESS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, chosen_method) = param::<ActionMethod<'a>>(false, s)?;
        let (s, identification) = param::<Identifier<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            identification,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct QualifiedRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub qualifiers: Vec<ValueQualifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QualifiedRepresentationItem<'a> = Id<QualifiedRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for QualifiedRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::QualifiedRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for QualifiedRepresentationItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("QUALIFIED_REPRESENTATION_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, qualifiers) = param::<Vec<ValueQualifier<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            qualifiers,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct QualitativeUncertainty_<'a> { // entity
    pub measure_name: Label<'a>,
    pub description: Text<'a>,
    pub uncertainty_value: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QualitativeUncertainty<'a> = Id<QualitativeUncertainty_<'a>>;
impl<'a> FromEntity<'a> for QualitativeUncertainty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::QualitativeUncertainty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for QualitativeUncertainty_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("QUALITATIVE_UNCERTAINTY(")(s)?;
        let (s, measure_name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, uncertainty_value) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            measure_name,
            description,
            uncertainty_value,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct QuantifiedAssemblyComponentUsage_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    pub quantity: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QuantifiedAssemblyComponentUsage<'a> = Id<QuantifiedAssemblyComponentUsage_<'a>>;
impl<'a> FromEntity<'a> for QuantifiedAssemblyComponentUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::QuantifiedAssemblyComponentUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for QuantifiedAssemblyComponentUsage_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("QUANTIFIED_ASSEMBLY_COMPONENT_USAGE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, related_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, reference_designator) = param::<Option<Identifier<'a>>>(false, s)?;
        let (s, quantity) = param::<MeasureWithUnit<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            reference_designator,
            quantity,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct QuasiUniformCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QuasiUniformCurve<'a> = Id<QuasiUniformCurve_<'a>>;
impl<'a> FromEntity<'a> for QuasiUniformCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::QuasiUniformCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for QuasiUniformCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("QUASI_UNIFORM_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<CartesianPoint<'a>>>(false, s)?;
        let (s, curve_form) = param::<BSplineCurveForm<'a>>(false, s)?;
        let (s, closed_curve) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct QuasiUniformSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QuasiUniformSurface<'a> = Id<QuasiUniformSurface_<'a>>;
impl<'a> FromEntity<'a> for QuasiUniformSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::QuasiUniformSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for QuasiUniformSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("QUASI_UNIFORM_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, u_degree) = param::<i64>(false, s)?;
        let (s, v_degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<Vec<CartesianPoint<'a>>>>(false, s)?;
        let (s, surface_form) = param::<BSplineSurfaceForm<'a>>(false, s)?;
        let (s, u_closed) = param::<Logical>(false, s)?;
        let (s, v_closed) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RackAndPinionPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pinion_radius: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RackAndPinionPair<'a> = Id<RackAndPinionPair_<'a>>;
impl<'a> FromEntity<'a> for RackAndPinionPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RackAndPinionPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RackAndPinionPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RACK_AND_PINION_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, pinion_radius) = param::<LengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            pinion_radius,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RackAndPinionPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_rack_displacement: TranslationalRangeMeasure<'a>,
    pub upper_limit_rack_displacement: TranslationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RackAndPinionPairRange<'a> = Id<RackAndPinionPairRange_<'a>>;
impl<'a> FromEntity<'a> for RackAndPinionPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RackAndPinionPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RackAndPinionPairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RACK_AND_PINION_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, lower_limit_rack_displacement) = param::<TranslationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_rack_displacement) = param::<TranslationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_rack_displacement,
            upper_limit_rack_displacement,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RackAndPinionPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_displacement: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RackAndPinionPairValue<'a> = Id<RackAndPinionPairValue_<'a>>;
impl<'a> FromEntity<'a> for RackAndPinionPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RackAndPinionPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RackAndPinionPairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RACK_AND_PINION_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_displacement) = param::<LengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_displacement,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RadiusDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RadiusDimension<'a> = Id<RadiusDimension_<'a>>;
impl<'a> FromEntity<'a> for RadiusDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RadiusDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RadiusDimension_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RADIUS_DIMENSION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RatioMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for RatioMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct RatioMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RatioMeasureWithUnit<'a> = Id<RatioMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for RatioMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RatioMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RatioMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RATIO_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RatioUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RatioUnit<'a> = Id<RatioUnit_<'a>>;
impl<'a> FromEntity<'a> for RatioUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RatioUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RatioUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RATIO_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RationalBSplineCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    pub weights_data: Vec<f64>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RationalBSplineCurve<'a> = Id<RationalBSplineCurve_<'a>>;
impl<'a> FromEntity<'a> for RationalBSplineCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RationalBSplineCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RationalBSplineCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RATIONAL_B_SPLINE_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<CartesianPoint<'a>>>(false, s)?;
        let (s, curve_form) = param::<BSplineCurveForm<'a>>(false, s)?;
        let (s, closed_curve) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(false, s)?;
        let (s, weights_data) = param::<Vec<f64>>(true, s)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            weights_data,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RationalBSplineSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    pub weights_data: Vec<Vec<f64>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RationalBSplineSurface<'a> = Id<RationalBSplineSurface_<'a>>;
impl<'a> FromEntity<'a> for RationalBSplineSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RationalBSplineSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RationalBSplineSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RATIONAL_B_SPLINE_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, u_degree) = param::<i64>(false, s)?;
        let (s, v_degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<Vec<CartesianPoint<'a>>>>(false, s)?;
        let (s, surface_form) = param::<BSplineSurfaceForm<'a>>(false, s)?;
        let (s, u_closed) = param::<Logical>(false, s)?;
        let (s, v_closed) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(false, s)?;
        let (s, weights_data) = param::<Vec<Vec<f64>>>(true, s)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            weights_data,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RealDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RealDefinedFunction<'a> = Id<RealDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for RealDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RealDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RealDefinedFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REAL_DEFINED_FUNCTION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RealLiteral_<'a> { // entity
    pub the_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RealLiteral<'a> = Id<RealLiteral_<'a>>;
impl<'a> FromEntity<'a> for RealLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RealLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RealLiteral_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REAL_LITERAL(")(s)?;
        let (s, the_value) = param::<f64>(true, s)?;
        Ok((s, Self {
            the_value,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RealNumericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RealNumericVariable<'a> = Id<RealNumericVariable_<'a>>;
impl<'a> FromEntity<'a> for RealNumericVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RealNumericVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RealNumericVariable_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REAL_NUMERIC_VARIABLE(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RectangularClosedProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularClosedProfile<'a> = Id<RectangularClosedProfile_<'a>>;
impl<'a> FromEntity<'a> for RectangularClosedProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RectangularClosedProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RectangularClosedProfile_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RECTANGULAR_CLOSED_PROFILE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RectangularCompositeSurface_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<Vec<SurfacePatch<'a>>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularCompositeSurface<'a> = Id<RectangularCompositeSurface_<'a>>;
impl<'a> FromEntity<'a> for RectangularCompositeSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RectangularCompositeSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RectangularCompositeSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RECTANGULAR_COMPOSITE_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, segments) = param::<Vec<Vec<SurfacePatch<'a>>>>(true, s)?;
        Ok((s, Self {
            name,
            segments,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RectangularPattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularPattern<'a> = Id<RectangularPattern_<'a>>;
impl<'a> FromEntity<'a> for RectangularPattern_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RectangularPattern(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RectangularPattern_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RECTANGULAR_PATTERN(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RectangularTrimmedSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub u1: ParameterValue<'a>,
    pub u2: ParameterValue<'a>,
    pub v1: ParameterValue<'a>,
    pub v2: ParameterValue<'a>,
    pub usense: bool,
    pub vsense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularTrimmedSurface<'a> = Id<RectangularTrimmedSurface_<'a>>;
impl<'a> FromEntity<'a> for RectangularTrimmedSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RectangularTrimmedSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RectangularTrimmedSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RECTANGULAR_TRIMMED_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, basis_surface) = param::<Surface<'a>>(false, s)?;
        let (s, u1) = param::<ParameterValue<'a>>(false, s)?;
        let (s, u2) = param::<ParameterValue<'a>>(false, s)?;
        let (s, v1) = param::<ParameterValue<'a>>(false, s)?;
        let (s, v2) = param::<ParameterValue<'a>>(false, s)?;
        let (s, usense) = param::<bool>(false, s)?;
        let (s, vsense) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            basis_surface,
            u1,
            u2,
            v1,
            v2,
            usense,
            vsense,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ReferencedModifiedDatum_<'a> { // entity
    pub precedence: i64,
    pub referenced_datum: Datum<'a>,
    pub modifier: LimitCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ReferencedModifiedDatum<'a> = Id<ReferencedModifiedDatum_<'a>>;
impl<'a> FromEntity<'a> for ReferencedModifiedDatum_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ReferencedModifiedDatum(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ReferencedModifiedDatum_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REFERENCED_MODIFIED_DATUM(")(s)?;
        let (s, precedence) = param::<i64>(false, s)?;
        let (s, referenced_datum) = param::<Datum<'a>>(false, s)?;
        let (s, modifier) = param::<LimitCondition<'a>>(true, s)?;
        Ok((s, Self {
            precedence,
            referenced_datum,
            modifier,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RelativeEventOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub base_event: EventOccurrence<'a>,
    pub offset: TimeMeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RelativeEventOccurrence<'a> = Id<RelativeEventOccurrence_<'a>>;
impl<'a> FromEntity<'a> for RelativeEventOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RelativeEventOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RelativeEventOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RELATIVE_EVENT_OCCURRENCE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, base_event) = param::<EventOccurrence<'a>>(false, s)?;
        let (s, offset) = param::<TimeMeasureWithUnit<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            base_event,
            offset,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RenderingPropertiesSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RenderingPropertiesSelect<'a> = Id<RenderingPropertiesSelect_<'a>>;

#[allow(non_snake_case)]
#[derive(Debug)]
pub struct RepItemGroup_<'a> { // entity
    pub group__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub representation_item__name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepItemGroup<'a> = Id<RepItemGroup_<'a>>;
impl<'a> FromEntity<'a> for RepItemGroup_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepItemGroup(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RepItemGroup_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REP_ITEM_GROUP(")(s)?;
        #[allow(non_snake_case)]
        let (s, group__name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            group__name,
            description,
            representation_item__name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ReparametrisedCompositeCurveSegment_<'a> { // entity
    pub transition: TransitionCode<'a>,
    pub same_sense: bool,
    pub parent_curve: Curve<'a>,
    pub param_length: ParameterValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ReparametrisedCompositeCurveSegment<'a> = Id<ReparametrisedCompositeCurveSegment_<'a>>;
impl<'a> FromEntity<'a> for ReparametrisedCompositeCurveSegment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ReparametrisedCompositeCurveSegment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ReparametrisedCompositeCurveSegment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REPARAMETRISED_COMPOSITE_CURVE_SEGMENT(")(s)?;
        let (s, transition) = param::<TransitionCode<'a>>(false, s)?;
        let (s, same_sense) = param::<bool>(false, s)?;
        let (s, parent_curve) = param::<Curve<'a>>(false, s)?;
        let (s, param_length) = param::<ParameterValue<'a>>(true, s)?;
        Ok((s, Self {
            transition,
            same_sense,
            parent_curve,
            param_length,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ReplicateFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ReplicateFeature<'a> = Id<ReplicateFeature_<'a>>;
impl<'a> FromEntity<'a> for ReplicateFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ReplicateFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ReplicateFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REPLICATE_FEATURE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Representation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Representation<'a> = Id<Representation_<'a>>;
impl<'a> FromEntity<'a> for Representation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Representation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Representation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RepresentationContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationContext<'a> = Id<RepresentationContext_<'a>>;
impl<'a> FromEntity<'a> for RepresentationContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepresentationContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RepresentationContext_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REPRESENTATION_CONTEXT(")(s)?;
        let (s, context_identifier) = param::<Identifier<'a>>(false, s)?;
        let (s, context_type) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            context_identifier,
            context_type,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationItem<'a> = Id<RepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for RepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RepresentationItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REPRESENTATION_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RepresentationMap_<'a> { // entity
    pub mapping_origin: RepresentationItem<'a>,
    pub mapped_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationMap<'a> = Id<RepresentationMap_<'a>>;
impl<'a> FromEntity<'a> for RepresentationMap_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepresentationMap(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RepresentationMap_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REPRESENTATION_MAP(")(s)?;
        let (s, mapping_origin) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, mapped_representation) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            mapping_origin,
            mapped_representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RepresentationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationRelationship<'a> = Id<RepresentationRelationship_<'a>>;
impl<'a> FromEntity<'a> for RepresentationRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepresentationRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RepresentationRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REPRESENTATION_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, rep_1) = param::<Representation<'a>>(false, s)?;
        let (s, rep_2) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RepresentationRelationshipWithTransformation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub transformation_operator: Transformation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationRelationshipWithTransformation<'a> = Id<RepresentationRelationshipWithTransformation_<'a>>;
impl<'a> FromEntity<'a> for RepresentationRelationshipWithTransformation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepresentationRelationshipWithTransformation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RepresentationRelationshipWithTransformation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, rep_1) = param::<Representation<'a>>(false, s)?;
        let (s, rep_2) = param::<Representation<'a>>(false, s)?;
        let (s, transformation_operator) = param::<Transformation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            transformation_operator,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RepresentedDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RepresentedDefinition<'a> = Id<RepresentedDefinition_<'a>>;

#[derive(Debug)]
pub struct RequirementForActionResource_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub kind: ResourceRequirementType<'a>,
    pub operations: Vec<CharacterizedActionDefinition<'a>>,
    pub resources: Vec<ActionResource<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RequirementForActionResource<'a> = Id<RequirementForActionResource_<'a>>;
impl<'a> FromEntity<'a> for RequirementForActionResource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RequirementForActionResource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RequirementForActionResource_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REQUIREMENT_FOR_ACTION_RESOURCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, kind) = param::<ResourceRequirementType<'a>>(false, s)?;
        let (s, operations) = param::<Vec<CharacterizedActionDefinition<'a>>>(false, s)?;
        let (s, resources) = param::<Vec<ActionResource<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            kind,
            operations,
            resources,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ResourceProperty_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub resource: CharacterizedResourceDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResourceProperty<'a> = Id<ResourceProperty_<'a>>;
impl<'a> FromEntity<'a> for ResourceProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ResourceProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ResourceProperty_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RESOURCE_PROPERTY(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, resource) = param::<CharacterizedResourceDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            resource,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ResourcePropertyRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub property: ResourceProperty<'a>,
    pub representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResourcePropertyRepresentation<'a> = Id<ResourcePropertyRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ResourcePropertyRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ResourcePropertyRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ResourcePropertyRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RESOURCE_PROPERTY_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, property) = param::<ResourceProperty<'a>>(false, s)?;
        let (s, representation) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            property,
            representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ResourceRequirementType_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResourceRequirementType<'a> = Id<ResourceRequirementType_<'a>>;
impl<'a> FromEntity<'a> for ResourceRequirementType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ResourceRequirementType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ResourceRequirementType_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RESOURCE_REQUIREMENT_TYPE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ResultingPath_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub related_frame: RigidPlacement<'a>,
    pub controlling_joints: Vec<KinematicJoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResultingPath<'a> = Id<ResultingPath_<'a>>;
impl<'a> FromEntity<'a> for ResultingPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ResultingPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ResultingPath_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RESULTING_PATH(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, rep_1) = param::<Representation<'a>>(false, s)?;
        let (s, rep_2) = param::<Representation<'a>>(false, s)?;
        let (s, related_frame) = param::<RigidPlacement<'a>>(false, s)?;
        let (s, controlling_joints) = param::<Vec<KinematicJoint<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            related_frame,
            controlling_joints,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Retention_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Retention<'a> = Id<Retention_<'a>>;
impl<'a> FromEntity<'a> for Retention_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Retention(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Retention_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RETENTION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, chosen_method) = param::<ActionMethod<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum ReversibleTopology<'a> { // select
    ReversibleTopologyItem(ReversibleTopologyItem<'a>),
    ListOfReversibleTopologyItem(Vec<ReversibleTopologyItem<'a>>),
    SetOfReversibleTopologyItem(Vec<ReversibleTopologyItem<'a>>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ReversibleTopology<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ReversibleTopologyItem<'a>>::parse, |r| ReversibleTopology::ReversibleTopologyItem(r)),
            map(delimited(tag("LIST_OF_REVERSIBLE_TOPOLOGY_ITEM("), <Vec<ReversibleTopologyItem<'a>>>::parse, char(')')), |r| ReversibleTopology::ListOfReversibleTopologyItem(r)),
            map(delimited(tag("SET_OF_REVERSIBLE_TOPOLOGY_ITEM("), <Vec<ReversibleTopologyItem<'a>>>::parse, char(')')), |r| ReversibleTopology::SetOfReversibleTopologyItem(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct ReversibleTopologyItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ReversibleTopologyItem<'a> = Id<ReversibleTopologyItem_<'a>>;

#[derive(Debug)]
pub struct RevolutePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolutePair<'a> = Id<RevolutePair_<'a>>;
impl<'a> FromEntity<'a> for RevolutePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RevolutePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RevolutePair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REVOLUTE_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RevolutePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolutePairRange<'a> = Id<RevolutePairRange_<'a>>;
impl<'a> FromEntity<'a> for RevolutePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RevolutePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RevolutePairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REVOLUTE_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, lower_limit_actual_rotation) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_actual_rotation) = param::<RotationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_rotation,
            upper_limit_actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RevolutePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolutePairValue<'a> = Id<RevolutePairValue_<'a>>;
impl<'a> FromEntity<'a> for RevolutePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RevolutePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RevolutePairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REVOLUTE_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_rotation) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RevolvedAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub axis: Axis1Placement<'a>,
    pub angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolvedAreaSolid<'a> = Id<RevolvedAreaSolid_<'a>>;
impl<'a> FromEntity<'a> for RevolvedAreaSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RevolvedAreaSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RevolvedAreaSolid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REVOLVED_AREA_SOLID(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, swept_area) = param::<CurveBoundedSurface<'a>>(false, s)?;
        let (s, axis) = param::<Axis1Placement<'a>>(false, s)?;
        let (s, angle) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            swept_area,
            axis,
            angle,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RevolvedFaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_face: FaceSurface<'a>,
    pub axis: Axis1Placement<'a>,
    pub angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolvedFaceSolid<'a> = Id<RevolvedFaceSolid_<'a>>;
impl<'a> FromEntity<'a> for RevolvedFaceSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RevolvedFaceSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RevolvedFaceSolid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("REVOLVED_FACE_SOLID(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, swept_face) = param::<FaceSurface<'a>>(false, s)?;
        let (s, axis) = param::<Axis1Placement<'a>>(false, s)?;
        let (s, angle) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            swept_face,
            axis,
            angle,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Rib_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Rib<'a> = Id<Rib_<'a>>;
impl<'a> FromEntity<'a> for Rib_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Rib(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Rib_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RIB(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RightAngularWedge_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub x: PositiveLengthMeasure<'a>,
    pub y: PositiveLengthMeasure<'a>,
    pub z: PositiveLengthMeasure<'a>,
    pub ltx: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RightAngularWedge<'a> = Id<RightAngularWedge_<'a>>;
impl<'a> FromEntity<'a> for RightAngularWedge_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RightAngularWedge(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RightAngularWedge_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RIGHT_ANGULAR_WEDGE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement3d<'a>>(false, s)?;
        let (s, x) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, y) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, z) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, ltx) = param::<LengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            x,
            y,
            z,
            ltx,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RightCircularCone_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis1Placement<'a>,
    pub height: PositiveLengthMeasure<'a>,
    pub radius: LengthMeasure<'a>,
    pub semi_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RightCircularCone<'a> = Id<RightCircularCone_<'a>>;
impl<'a> FromEntity<'a> for RightCircularCone_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RightCircularCone(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RightCircularCone_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RIGHT_CIRCULAR_CONE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis1Placement<'a>>(false, s)?;
        let (s, height) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, radius) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, semi_angle) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            height,
            radius,
            semi_angle,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RightCircularCylinder_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis1Placement<'a>,
    pub height: PositiveLengthMeasure<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RightCircularCylinder<'a> = Id<RightCircularCylinder_<'a>>;
impl<'a> FromEntity<'a> for RightCircularCylinder_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RightCircularCylinder(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RightCircularCylinder_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RIGHT_CIRCULAR_CYLINDER(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis1Placement<'a>>(false, s)?;
        let (s, height) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, radius) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            height,
            radius,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RigidPlacement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RigidPlacement<'a> = Id<RigidPlacement_<'a>>;

#[derive(Debug)]
pub struct RoleAssociation_<'a> { // entity
    pub role: ObjectRole<'a>,
    pub item_with_role: RoleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoleAssociation<'a> = Id<RoleAssociation_<'a>>;
impl<'a> FromEntity<'a> for RoleAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RoleAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RoleAssociation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ROLE_ASSOCIATION(")(s)?;
        let (s, role) = param::<ObjectRole<'a>>(false, s)?;
        let (s, item_with_role) = param::<RoleSelect<'a>>(true, s)?;
        Ok((s, Self {
            role,
            item_with_role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RoleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RoleSelect<'a> = Id<RoleSelect_<'a>>;

#[derive(Debug)]
pub struct RollingCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub curve_1: Curve<'a>,
    pub curve_2: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingCurvePair<'a> = Id<RollingCurvePair_<'a>>;
impl<'a> FromEntity<'a> for RollingCurvePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RollingCurvePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RollingCurvePair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ROLLING_CURVE_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, curve_1) = param::<Curve<'a>>(false, s)?;
        let (s, curve_2) = param::<Curve<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            curve_1,
            curve_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RollingCurvePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_curve_1: PointOnCurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingCurvePairValue<'a> = Id<RollingCurvePairValue_<'a>>;
impl<'a> FromEntity<'a> for RollingCurvePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RollingCurvePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RollingCurvePairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ROLLING_CURVE_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_point_on_curve_1) = param::<PointOnCurve<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_curve_1,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RollingSurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub surface_1: Surface<'a>,
    pub surface_2: Surface<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingSurfacePair<'a> = Id<RollingSurfacePair_<'a>>;
impl<'a> FromEntity<'a> for RollingSurfacePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RollingSurfacePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RollingSurfacePair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ROLLING_SURFACE_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, surface_1) = param::<Surface<'a>>(false, s)?;
        let (s, surface_2) = param::<Surface<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            surface_1,
            surface_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RollingSurfacePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_surface: PointOnSurface<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingSurfacePairValue<'a> = Id<RollingSurfacePairValue_<'a>>;
impl<'a> FromEntity<'a> for RollingSurfacePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RollingSurfacePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RollingSurfacePairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ROLLING_SURFACE_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_point_on_surface) = param::<PointOnSurface<'a>>(false, s)?;
        let (s, actual_rotation) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_surface,
            actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RotationAboutDirection_<'a> { // entity
    pub direction_of_axis: Direction<'a>,
    pub rotation_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RotationAboutDirection<'a> = Id<RotationAboutDirection_<'a>>;
impl<'a> FromEntity<'a> for RotationAboutDirection_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RotationAboutDirection(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RotationAboutDirection_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ROTATION_ABOUT_DIRECTION(")(s)?;
        let (s, direction_of_axis) = param::<Direction<'a>>(false, s)?;
        let (s, rotation_angle) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            direction_of_axis,
            rotation_angle,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum RotationalRangeMeasure<'a> { // select
    PlaneAngleMeasure(PlaneAngleMeasure<'a>),
    UnlimitedRange(UnlimitedRange<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for RotationalRangeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("PLANE_ANGLE_MEASURE("), <PlaneAngleMeasure<'a>>::parse, char(')')), |r| RotationalRangeMeasure::PlaneAngleMeasure(r)),
            map(delimited(tag("UNLIMITED_RANGE("), <UnlimitedRange<'a>>::parse, char(')')), |r| RotationalRangeMeasure::UnlimitedRange(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct RoundHole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoundHole<'a> = Id<RoundHole_<'a>>;
impl<'a> FromEntity<'a> for RoundHole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RoundHole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RoundHole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ROUND_HOLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RoundedUProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoundedUProfile<'a> = Id<RoundedUProfile_<'a>>;
impl<'a> FromEntity<'a> for RoundedUProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RoundedUProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RoundedUProfile_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ROUNDED_U_PROFILE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RoundnessTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoundnessTolerance<'a> = Id<RoundnessTolerance_<'a>>;
impl<'a> FromEntity<'a> for RoundnessTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RoundnessTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RoundnessTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("ROUNDNESS_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RuledSurfaceSweptAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub directrix: Curve<'a>,
    pub start_param: f64,
    pub end_param: f64,
    pub reference_surface: Surface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RuledSurfaceSweptAreaSolid<'a> = Id<RuledSurfaceSweptAreaSolid_<'a>>;
impl<'a> FromEntity<'a> for RuledSurfaceSweptAreaSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RuledSurfaceSweptAreaSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RuledSurfaceSweptAreaSolid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RULED_SURFACE_SWEPT_AREA_SOLID(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, swept_area) = param::<CurveBoundedSurface<'a>>(false, s)?;
        let (s, directrix) = param::<Curve<'a>>(false, s)?;
        let (s, start_param) = param::<f64>(false, s)?;
        let (s, end_param) = param::<f64>(false, s)?;
        let (s, reference_surface) = param::<Surface<'a>>(true, s)?;
        Ok((s, Self {
            name,
            swept_area,
            directrix,
            start_param,
            end_param,
            reference_surface,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RunoutZoneDefinition_<'a> { // entity
    pub zone: ToleranceZone<'a>,
    pub boundaries: Vec<ShapeAspect<'a>>,
    pub orientation: RunoutZoneOrientation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RunoutZoneDefinition<'a> = Id<RunoutZoneDefinition_<'a>>;
impl<'a> FromEntity<'a> for RunoutZoneDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RunoutZoneDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RunoutZoneDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RUNOUT_ZONE_DEFINITION(")(s)?;
        let (s, zone) = param::<ToleranceZone<'a>>(false, s)?;
        let (s, boundaries) = param::<Vec<ShapeAspect<'a>>>(false, s)?;
        let (s, orientation) = param::<RunoutZoneOrientation<'a>>(true, s)?;
        Ok((s, Self {
            zone,
            boundaries,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RunoutZoneOrientation_<'a> { // entity
    pub angle: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RunoutZoneOrientation<'a> = Id<RunoutZoneOrientation_<'a>>;
impl<'a> FromEntity<'a> for RunoutZoneOrientation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RunoutZoneOrientation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RunoutZoneOrientation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RUNOUT_ZONE_ORIENTATION(")(s)?;
        let (s, angle) = param::<MeasureWithUnit<'a>>(true, s)?;
        Ok((s, Self {
            angle,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct RunoutZoneOrientationReferenceDirection_<'a> { // entity
    pub angle: MeasureWithUnit<'a>,
    pub orientation_defining_relationship: ShapeAspectRelationship<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RunoutZoneOrientationReferenceDirection<'a> = Id<RunoutZoneOrientationReferenceDirection_<'a>>;
impl<'a> FromEntity<'a> for RunoutZoneOrientationReferenceDirection_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RunoutZoneOrientationReferenceDirection(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for RunoutZoneOrientationReferenceDirection_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION(")(s)?;
        let (s, angle) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, orientation_defining_relationship) = param::<ShapeAspectRelationship<'a>>(true, s)?;
        Ok((s, Self {
            angle,
            orientation_defining_relationship,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ScrewPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pitch: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ScrewPair<'a> = Id<ScrewPair_<'a>>;
impl<'a> FromEntity<'a> for ScrewPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ScrewPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ScrewPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SCREW_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, pitch) = param::<LengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            pitch,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ScrewPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ScrewPairRange<'a> = Id<ScrewPairRange_<'a>>;
impl<'a> FromEntity<'a> for ScrewPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ScrewPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ScrewPairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SCREW_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, lower_limit_actual_rotation) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_actual_rotation) = param::<RotationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_rotation,
            upper_limit_actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ScrewPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ScrewPairValue<'a> = Id<ScrewPairValue_<'a>>;
impl<'a> FromEntity<'a> for ScrewPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ScrewPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ScrewPairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SCREW_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_rotation) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SeamCurve_<'a> { // entity
    pub name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: Vec<PcurveOrSurface<'a>>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SeamCurve<'a> = Id<SeamCurve_<'a>>;
impl<'a> FromEntity<'a> for SeamCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SeamCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SeamCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SEAM_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, curve_3d) = param::<Curve<'a>>(false, s)?;
        let (s, associated_geometry) = param::<Vec<PcurveOrSurface<'a>>>(false, s)?;
        let (s, master_representation) = param::<PreferredSurfaceCurveRepresentation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            curve_3d,
            associated_geometry,
            master_representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SeamEdge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_start: Vertex<'a>,
    pub edge_end: Vertex<'a>,
    pub edge_element: Edge<'a>,
    pub orientation: bool,
    pub pcurve_reference: Pcurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SeamEdge<'a> = Id<SeamEdge_<'a>>;
impl<'a> FromEntity<'a> for SeamEdge_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SeamEdge(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SeamEdge_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SEAM_EDGE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, edge_start) = param::<Vertex<'a>>(false, s)?;
        let (s, edge_end) = param::<Vertex<'a>>(false, s)?;
        let (s, edge_element) = param::<Edge<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(false, s)?;
        let (s, pcurve_reference) = param::<Pcurve<'a>>(true, s)?;
        Ok((s, Self {
            name,
            edge_start,
            edge_end,
            edge_element,
            orientation,
            pcurve_reference,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SecondInMinute<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SecondInMinute<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct SecurityClassification_<'a> { // entity
    pub name: Label<'a>,
    pub purpose: Text<'a>,
    pub security_level: SecurityClassificationLevel<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SecurityClassification<'a> = Id<SecurityClassification_<'a>>;
impl<'a> FromEntity<'a> for SecurityClassification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SecurityClassification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SecurityClassification_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SECURITY_CLASSIFICATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, purpose) = param::<Text<'a>>(false, s)?;
        let (s, security_level) = param::<SecurityClassificationLevel<'a>>(true, s)?;
        Ok((s, Self {
            name,
            purpose,
            security_level,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SecurityClassificationAssignment_<'a> { // entity
    pub assigned_security_classification: SecurityClassification<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SecurityClassificationAssignment<'a> = Id<SecurityClassificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for SecurityClassificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SecurityClassificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SecurityClassificationAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SECURITY_CLASSIFICATION_ASSIGNMENT(")(s)?;
        let (s, assigned_security_classification) = param::<SecurityClassification<'a>>(true, s)?;
        Ok((s, Self {
            assigned_security_classification,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SecurityClassificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SecurityClassificationItem<'a> = Id<SecurityClassificationItem_<'a>>;

#[derive(Debug)]
pub struct SecurityClassificationLevel_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SecurityClassificationLevel<'a> = Id<SecurityClassificationLevel_<'a>>;
impl<'a> FromEntity<'a> for SecurityClassificationLevel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SecurityClassificationLevel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SecurityClassificationLevel_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SECURITY_CLASSIFICATION_LEVEL(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SerialNumberedEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_start_id: Identifier<'a>,
    pub effectivity_end_id: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SerialNumberedEffectivity<'a> = Id<SerialNumberedEffectivity_<'a>>;
impl<'a> FromEntity<'a> for SerialNumberedEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SerialNumberedEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SerialNumberedEffectivity_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SERIAL_NUMBERED_EFFECTIVITY(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, effectivity_start_id) = param::<Identifier<'a>>(false, s)?;
        let (s, effectivity_end_id) = param::<Option<Identifier<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            effectivity_start_id,
            effectivity_end_id,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SetOfReversibleTopologyItem<'a>(pub Vec<ReversibleTopologyItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for SetOfReversibleTopologyItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<ReversibleTopologyItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct SetRepresentationItem<'a>(pub Vec<RepresentationItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for SetRepresentationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<RepresentationItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub enum ShadingCurveMethod<'a> { // enum
    ConstantColour,
    LinearColour,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ShadingCurveMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ShadingCurveMethod::*;
        alt((
            map(tag(".CONSTANT_COLOUR."), |_| ConstantColour),
            map(tag(".LINEAR_COLOUR."), |_| LinearColour),
        ))(s)
    }
}
#[derive(Debug)]
pub enum ShadingSurfaceMethod<'a> { // enum
    ConstantShading,
    ColourShading,
    DotShading,
    NormalShading,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ShadingSurfaceMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ShadingSurfaceMethod::*;
        alt((
            map(tag(".CONSTANT_SHADING."), |_| ConstantShading),
            map(tag(".COLOUR_SHADING."), |_| ColourShading),
            map(tag(".DOT_SHADING."), |_| DotShading),
            map(tag(".NORMAL_SHADING."), |_| NormalShading),
        ))(s)
    }
}
#[derive(Debug)]
pub struct ShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspect<'a> = Id<ShapeAspect_<'a>>;
impl<'a> FromEntity<'a> for ShapeAspect_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeAspect(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShapeAspect_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHAPE_ASPECT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ShapeAspectAssociativity_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectAssociativity<'a> = Id<ShapeAspectAssociativity_<'a>>;
impl<'a> FromEntity<'a> for ShapeAspectAssociativity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeAspectAssociativity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShapeAspectAssociativity_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHAPE_ASPECT_ASSOCIATIVITY(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ShapeAspectDerivingRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectDerivingRelationship<'a> = Id<ShapeAspectDerivingRelationship_<'a>>;
impl<'a> FromEntity<'a> for ShapeAspectDerivingRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeAspectDerivingRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShapeAspectDerivingRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHAPE_ASPECT_DERIVING_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ShapeAspectRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectRelationship<'a> = Id<ShapeAspectRelationship_<'a>>;
impl<'a> FromEntity<'a> for ShapeAspectRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeAspectRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShapeAspectRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHAPE_ASPECT_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ShapeAspectTransition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectTransition<'a> = Id<ShapeAspectTransition_<'a>>;
impl<'a> FromEntity<'a> for ShapeAspectTransition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeAspectTransition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShapeAspectTransition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHAPE_ASPECT_TRANSITION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ShapeDefiningRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeDefiningRelationship<'a> = Id<ShapeDefiningRelationship_<'a>>;
impl<'a> FromEntity<'a> for ShapeDefiningRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeDefiningRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShapeDefiningRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHAPE_DEFINING_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, related_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ShapeDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ShapeDefinition<'a> = Id<ShapeDefinition_<'a>>;

#[derive(Debug)]
pub struct ShapeDefinitionRepresentation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeDefinitionRepresentation<'a> = Id<ShapeDefinitionRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ShapeDefinitionRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeDefinitionRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShapeDefinitionRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHAPE_DEFINITION_REPRESENTATION(")(s)?;
        let (s, definition) = param::<RepresentedDefinition<'a>>(false, s)?;
        let (s, used_representation) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            definition,
            used_representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ShapeDimensionRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeDimensionRepresentation<'a> = Id<ShapeDimensionRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ShapeDimensionRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeDimensionRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShapeDimensionRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHAPE_DIMENSION_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeRepresentation<'a> = Id<ShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShapeRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHAPE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ShapeRepresentationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeRepresentationRelationship<'a> = Id<ShapeRepresentationRelationship_<'a>>;
impl<'a> FromEntity<'a> for ShapeRepresentationRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeRepresentationRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShapeRepresentationRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHAPE_REPRESENTATION_RELATIONSHIP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, rep_1) = param::<Representation<'a>>(false, s)?;
        let (s, rep_2) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ShapeRepresentationWithParameters_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeRepresentationWithParameters<'a> = Id<ShapeRepresentationWithParameters_<'a>>;
impl<'a> FromEntity<'a> for ShapeRepresentationWithParameters_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeRepresentationWithParameters(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShapeRepresentationWithParameters_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHAPE_REPRESENTATION_WITH_PARAMETERS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Shell_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Shell<'a> = Id<Shell_<'a>>;

#[derive(Debug)]
pub struct ShellBasedSurfaceModel_<'a> { // entity
    pub name: Label<'a>,
    pub sbsm_boundary: Vec<Shell<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShellBasedSurfaceModel<'a> = Id<ShellBasedSurfaceModel_<'a>>;
impl<'a> FromEntity<'a> for ShellBasedSurfaceModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShellBasedSurfaceModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ShellBasedSurfaceModel_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SHELL_BASED_SURFACE_MODEL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, sbsm_boundary) = param::<Vec<Shell<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            sbsm_boundary,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum SiPrefix<'a> { // enum
    Exa,
    Peta,
    Tera,
    Giga,
    Mega,
    Kilo,
    Hecto,
    Deca,
    Deci,
    Centi,
    Milli,
    Micro,
    Nano,
    Pico,
    Femto,
    Atto,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SiPrefix<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SiPrefix::*;
        alt((
            map(tag(".EXA."), |_| Exa),
            map(tag(".PETA."), |_| Peta),
            map(tag(".TERA."), |_| Tera),
            map(tag(".GIGA."), |_| Giga),
            map(tag(".MEGA."), |_| Mega),
            map(tag(".KILO."), |_| Kilo),
            map(tag(".HECTO."), |_| Hecto),
            map(tag(".DECA."), |_| Deca),
            map(tag(".DECI."), |_| Deci),
            map(tag(".CENTI."), |_| Centi),
            map(tag(".MILLI."), |_| Milli),
            map(tag(".MICRO."), |_| Micro),
            map(tag(".NANO."), |_| Nano),
            map(tag(".PICO."), |_| Pico),
            map(tag(".FEMTO."), |_| Femto),
            map(tag(".ATTO."), |_| Atto),
        ))(s)
    }
}
#[derive(Debug)]
pub struct SiUnit_<'a> { // entity
    pub prefix: Option<SiPrefix<'a>>,
    pub name: SiUnitName<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SiUnit<'a> = Id<SiUnit_<'a>>;
impl<'a> FromEntity<'a> for SiUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SiUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SiUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SI_UNIT(")(s)?;
        let (s, _) = tag("*,")(s)?;
        let (s, prefix) = param::<Option<SiPrefix<'a>>>(false, s)?;
        let (s, name) = param::<SiUnitName<'a>>(true, s)?;
        Ok((s, Self {
            prefix,
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum SiUnitName<'a> { // enum
    Metre,
    Gram,
    Second,
    Ampere,
    Kelvin,
    Mole,
    Candela,
    Radian,
    Steradian,
    Hertz,
    Newton,
    Pascal,
    Joule,
    Watt,
    Coulomb,
    Volt,
    Farad,
    Ohm,
    Siemens,
    Weber,
    Tesla,
    Henry,
    DegreeCelsius,
    Lumen,
    Lux,
    Becquerel,
    Gray,
    Sievert,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SiUnitName<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SiUnitName::*;
        alt((
            map(tag(".METRE."), |_| Metre),
            map(tag(".GRAM."), |_| Gram),
            map(tag(".SECOND."), |_| Second),
            map(tag(".AMPERE."), |_| Ampere),
            map(tag(".KELVIN."), |_| Kelvin),
            map(tag(".MOLE."), |_| Mole),
            map(tag(".CANDELA."), |_| Candela),
            map(tag(".RADIAN."), |_| Radian),
            map(tag(".STERADIAN."), |_| Steradian),
            map(tag(".HERTZ."), |_| Hertz),
            map(tag(".NEWTON."), |_| Newton),
            map(tag(".PASCAL."), |_| Pascal),
            map(tag(".JOULE."), |_| Joule),
            map(tag(".WATT."), |_| Watt),
            map(tag(".COULOMB."), |_| Coulomb),
            map(tag(".VOLT."), |_| Volt),
            map(tag(".FARAD."), |_| Farad),
            map(tag(".OHM."), |_| Ohm),
            map(tag(".SIEMENS."), |_| Siemens),
        alt((
            map(tag(".WEBER."), |_| Weber),
            map(tag(".TESLA."), |_| Tesla),
            map(tag(".HENRY."), |_| Henry),
            map(tag(".DEGREE_CELSIUS."), |_| DegreeCelsius),
            map(tag(".LUMEN."), |_| Lumen),
            map(tag(".LUX."), |_| Lux),
            map(tag(".BECQUEREL."), |_| Becquerel),
            map(tag(".GRAY."), |_| Gray),
            map(tag(".SIEVERT."), |_| Sievert),
        ))))(s)
    }
}
#[derive(Debug)]
pub struct SimpleBooleanExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleBooleanExpression<'a> = Id<SimpleBooleanExpression_<'a>>;
impl<'a> FromEntity<'a> for SimpleBooleanExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SimpleBooleanExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SimpleBooleanExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SIMPLE_BOOLEAN_EXPRESSION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SimpleGenericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleGenericExpression<'a> = Id<SimpleGenericExpression_<'a>>;
impl<'a> FromEntity<'a> for SimpleGenericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SimpleGenericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SimpleGenericExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SIMPLE_GENERIC_EXPRESSION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SimpleNumericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleNumericExpression<'a> = Id<SimpleNumericExpression_<'a>>;
impl<'a> FromEntity<'a> for SimpleNumericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SimpleNumericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SimpleNumericExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SIMPLE_NUMERIC_EXPRESSION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SimplePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimplePairRange<'a> = Id<SimplePairRange_<'a>>;
impl<'a> FromEntity<'a> for SimplePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SimplePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SimplePairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SIMPLE_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SimpleStringExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleStringExpression<'a> = Id<SimpleStringExpression_<'a>>;
impl<'a> FromEntity<'a> for SimpleStringExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SimpleStringExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SimpleStringExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SIMPLE_STRING_EXPRESSION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SinFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SinFunction<'a> = Id<SinFunction_<'a>>;
impl<'a> FromEntity<'a> for SinFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SinFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SinFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SIN_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum SizeSelect<'a> { // select
    PositiveLengthMeasure(PositiveLengthMeasure<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SizeSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("POSITIVE_LENGTH_MEASURE("), <PositiveLengthMeasure<'a>>::parse, char(')')), |r| SizeSelect::PositiveLengthMeasure(r)),
            map(<MeasureWithUnit<'a>>::parse, |r| SizeSelect::MeasureWithUnit(r)),
            map(delimited(tag("DESCRIPTIVE_MEASURE("), <DescriptiveMeasure<'a>>::parse, char(')')), |r| SizeSelect::DescriptiveMeasure(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct SlashExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlashExpression<'a> = Id<SlashExpression_<'a>>;
impl<'a> FromEntity<'a> for SlashExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlashExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SlashExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SLASH_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SlidingCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub curve_1: Curve<'a>,
    pub curve_2: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingCurvePair<'a> = Id<SlidingCurvePair_<'a>>;
impl<'a> FromEntity<'a> for SlidingCurvePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlidingCurvePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SlidingCurvePair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SLIDING_CURVE_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, curve_1) = param::<Curve<'a>>(false, s)?;
        let (s, curve_2) = param::<Curve<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            curve_1,
            curve_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SlidingCurvePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_curve_1: PointOnCurve<'a>,
    pub actual_point_on_curve_2: PointOnCurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingCurvePairValue<'a> = Id<SlidingCurvePairValue_<'a>>;
impl<'a> FromEntity<'a> for SlidingCurvePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlidingCurvePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SlidingCurvePairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SLIDING_CURVE_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_point_on_curve_1) = param::<PointOnCurve<'a>>(false, s)?;
        let (s, actual_point_on_curve_2) = param::<PointOnCurve<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_curve_1,
            actual_point_on_curve_2,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SlidingSurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub surface_1: Surface<'a>,
    pub surface_2: Surface<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingSurfacePair<'a> = Id<SlidingSurfacePair_<'a>>;
impl<'a> FromEntity<'a> for SlidingSurfacePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlidingSurfacePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SlidingSurfacePair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SLIDING_SURFACE_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, surface_1) = param::<Surface<'a>>(false, s)?;
        let (s, surface_2) = param::<Surface<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            surface_1,
            surface_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SlidingSurfacePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_surface_1: PointOnSurface<'a>,
    pub actual_point_on_surface_2: PointOnSurface<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingSurfacePairValue<'a> = Id<SlidingSurfacePairValue_<'a>>;
impl<'a> FromEntity<'a> for SlidingSurfacePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlidingSurfacePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SlidingSurfacePairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SLIDING_SURFACE_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_point_on_surface_1) = param::<PointOnSurface<'a>>(false, s)?;
        let (s, actual_point_on_surface_2) = param::<PointOnSurface<'a>>(false, s)?;
        let (s, actual_rotation) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_surface_1,
            actual_point_on_surface_2,
            actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Slot_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Slot<'a> = Id<Slot_<'a>>;
impl<'a> FromEntity<'a> for Slot_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Slot(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Slot_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SLOT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SlotEnd_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlotEnd<'a> = Id<SlotEnd_<'a>>;
impl<'a> FromEntity<'a> for SlotEnd_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlotEnd(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SlotEnd_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SLOT_END(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SolidAngleMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SolidAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct SolidAngleMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidAngleMeasureWithUnit<'a> = Id<SolidAngleMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for SolidAngleMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SolidAngleMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SolidAngleMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SOLID_ANGLE_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SolidAngleUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidAngleUnit<'a> = Id<SolidAngleUnit_<'a>>;
impl<'a> FromEntity<'a> for SolidAngleUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SolidAngleUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SolidAngleUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SOLID_ANGLE_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SolidModel_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidModel<'a> = Id<SolidModel_<'a>>;
impl<'a> FromEntity<'a> for SolidModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SolidModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SolidModel_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SOLID_MODEL(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SolidReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_solid: SolidModel<'a>,
    pub transformation: CartesianTransformationOperator3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidReplica<'a> = Id<SolidReplica_<'a>>;
impl<'a> FromEntity<'a> for SolidReplica_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SolidReplica(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SolidReplica_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SOLID_REPLICA(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, parent_solid) = param::<SolidModel<'a>>(false, s)?;
        let (s, transformation) = param::<CartesianTransformationOperator3d<'a>>(true, s)?;
        Ok((s, Self {
            name,
            parent_solid,
            transformation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum Source<'a> { // enum
    Made,
    Bought,
    NotKnown,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for Source<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use Source::*;
        alt((
            map(tag(".MADE."), |_| Made),
            map(tag(".BOUGHT."), |_| Bought),
            map(tag(".NOT_KNOWN."), |_| NotKnown),
        ))(s)
    }
}
#[derive(Debug)]
pub enum SourceItem<'a> { // select
    Identifier(Identifier<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SourceItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(delimited(tag("IDENTIFIER("), <Identifier<'a>>::parse, char(')')), |r| SourceItem::Identifier(r))(s)
    }
}
#[derive(Debug)]
pub enum SpatialRotation<'a> { // select
    YprRotation(Vec<PlaneAngleMeasure<'a>>),
    RotationAboutDirection(RotationAboutDirection<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SpatialRotation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("YPR_ROTATION("), <Vec<PlaneAngleMeasure<'a>>>::parse, char(')')), |r| SpatialRotation::YprRotation(r)),
            map(<RotationAboutDirection<'a>>::parse, |r| SpatialRotation::RotationAboutDirection(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct SpecifiedHigherUsageOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    pub upper_usage: AssemblyComponentUsage<'a>,
    pub next_usage: NextAssemblyUsageOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SpecifiedHigherUsageOccurrence<'a> = Id<SpecifiedHigherUsageOccurrence_<'a>>;
impl<'a> FromEntity<'a> for SpecifiedHigherUsageOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SpecifiedHigherUsageOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SpecifiedHigherUsageOccurrence_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SPECIFIED_HIGHER_USAGE_OCCURRENCE(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, related_product_definition) = param::<ProductDefinition<'a>>(false, s)?;
        let (s, reference_designator) = param::<Option<Identifier<'a>>>(false, s)?;
        let (s, upper_usage) = param::<AssemblyComponentUsage<'a>>(false, s)?;
        let (s, next_usage) = param::<NextAssemblyUsageOccurrence<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            reference_designator,
            upper_usage,
            next_usage,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SpecifiedItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SpecifiedItem<'a> = Id<SpecifiedItem_<'a>>;

#[derive(Debug)]
pub struct Sphere_<'a> { // entity
    pub name: Label<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    pub centre: Point<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Sphere<'a> = Id<Sphere_<'a>>;
impl<'a> FromEntity<'a> for Sphere_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Sphere(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Sphere_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SPHERE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, radius) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, centre) = param::<Point<'a>>(true, s)?;
        Ok((s, Self {
            name,
            radius,
            centre,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SphericalPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalPair<'a> = Id<SphericalPair_<'a>>;
impl<'a> FromEntity<'a> for SphericalPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SphericalPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SphericalPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SPHERICAL_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SphericalPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_yaw: RotationalRangeMeasure<'a>,
    pub upper_limit_yaw: RotationalRangeMeasure<'a>,
    pub lower_limit_pitch: RotationalRangeMeasure<'a>,
    pub upper_limit_pitch: RotationalRangeMeasure<'a>,
    pub lower_limit_roll: RotationalRangeMeasure<'a>,
    pub upper_limit_roll: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalPairRange<'a> = Id<SphericalPairRange_<'a>>;
impl<'a> FromEntity<'a> for SphericalPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SphericalPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SphericalPairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SPHERICAL_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, lower_limit_yaw) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_yaw) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, lower_limit_pitch) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_pitch) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, lower_limit_roll) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_roll) = param::<RotationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_yaw,
            upper_limit_yaw,
            lower_limit_pitch,
            upper_limit_pitch,
            lower_limit_roll,
            upper_limit_roll,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SphericalPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub input_orientation: SpatialRotation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalPairValue<'a> = Id<SphericalPairValue_<'a>>;
impl<'a> FromEntity<'a> for SphericalPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SphericalPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SphericalPairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SPHERICAL_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, input_orientation) = param::<SpatialRotation<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            input_orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SphericalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalSurface<'a> = Id<SphericalSurface_<'a>>;
impl<'a> FromEntity<'a> for SphericalSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SphericalSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SphericalSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SPHERICAL_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement3d<'a>>(false, s)?;
        let (s, radius) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            radius,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SqlMappableDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SqlMappableDefinedFunction<'a> = Id<SqlMappableDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for SqlMappableDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SqlMappableDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SqlMappableDefinedFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SQL_MAPPABLE_DEFINED_FUNCTION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SquareRootFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SquareRootFunction<'a> = Id<SquareRootFunction_<'a>>;
impl<'a> FromEntity<'a> for SquareRootFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SquareRootFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SquareRootFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SQUARE_ROOT_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SquareUProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SquareUProfile<'a> = Id<SquareUProfile_<'a>>;
impl<'a> FromEntity<'a> for SquareUProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SquareUProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SquareUProfile_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SQUARE_U_PROFILE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct StandardUncertainty_<'a> { // entity
    pub measure_name: Label<'a>,
    pub description: Text<'a>,
    pub uncertainty_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StandardUncertainty<'a> = Id<StandardUncertainty_<'a>>;
impl<'a> FromEntity<'a> for StandardUncertainty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StandardUncertainty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for StandardUncertainty_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("STANDARD_UNCERTAINTY(")(s)?;
        let (s, measure_name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, uncertainty_value) = param::<f64>(true, s)?;
        Ok((s, Self {
            measure_name,
            description,
            uncertainty_value,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct StraightnessTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StraightnessTolerance<'a> = Id<StraightnessTolerance_<'a>>;
impl<'a> FromEntity<'a> for StraightnessTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StraightnessTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for StraightnessTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("STRAIGHTNESS_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct StringDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringDefinedFunction<'a> = Id<StringDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for StringDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StringDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for StringDefinedFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("STRING_DEFINED_FUNCTION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct StringExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringExpression<'a> = Id<StringExpression_<'a>>;
impl<'a> FromEntity<'a> for StringExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StringExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for StringExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("STRING_EXPRESSION(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct StringLiteral_<'a> { // entity
    pub the_value: &'a str,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringLiteral<'a> = Id<StringLiteral_<'a>>;
impl<'a> FromEntity<'a> for StringLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StringLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for StringLiteral_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("STRING_LITERAL(")(s)?;
        let (s, the_value) = param::<&'a str>(true, s)?;
        Ok((s, Self {
            the_value,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct StringVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringVariable<'a> = Id<StringVariable_<'a>>;
impl<'a> FromEntity<'a> for StringVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StringVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for StringVariable_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("STRING_VARIABLE(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct StructuredDimensionCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StructuredDimensionCallout<'a> = Id<StructuredDimensionCallout_<'a>>;
impl<'a> FromEntity<'a> for StructuredDimensionCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StructuredDimensionCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for StructuredDimensionCallout_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("STRUCTURED_DIMENSION_CALLOUT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct StyleContextSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type StyleContextSelect<'a> = Id<StyleContextSelect_<'a>>;

#[derive(Debug)]
pub struct StyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StyledItem<'a> = Id<StyledItem_<'a>>;
impl<'a> FromEntity<'a> for StyledItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StyledItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for StyledItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("STYLED_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Subedge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_start: Vertex<'a>,
    pub edge_end: Vertex<'a>,
    pub parent_edge: Edge<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Subedge<'a> = Id<Subedge_<'a>>;
impl<'a> FromEntity<'a> for Subedge_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Subedge(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Subedge_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SUBEDGE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, edge_start) = param::<Vertex<'a>>(false, s)?;
        let (s, edge_end) = param::<Vertex<'a>>(false, s)?;
        let (s, parent_edge) = param::<Edge<'a>>(true, s)?;
        Ok((s, Self {
            name,
            edge_start,
            edge_end,
            parent_edge,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Subface_<'a> { // entity
    pub name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    pub parent_face: Face<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Subface<'a> = Id<Subface_<'a>>;
impl<'a> FromEntity<'a> for Subface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Subface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Subface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SUBFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, bounds) = param::<Vec<FaceBound<'a>>>(false, s)?;
        let (s, parent_face) = param::<Face<'a>>(true, s)?;
        Ok((s, Self {
            name,
            bounds,
            parent_face,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SubstringExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SubstringExpression<'a> = Id<SubstringExpression_<'a>>;
impl<'a> FromEntity<'a> for SubstringExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SubstringExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SubstringExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SUBSTRING_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SupportedItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SupportedItem<'a> = Id<SupportedItem_<'a>>;

#[derive(Debug)]
pub struct Surface_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Surface<'a> = Id<Surface_<'a>>;
impl<'a> FromEntity<'a> for Surface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Surface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Surface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceConditionCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceConditionCallout<'a> = Id<SurfaceConditionCallout_<'a>>;
impl<'a> FromEntity<'a> for SurfaceConditionCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceConditionCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceConditionCallout_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_CONDITION_CALLOUT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, contents) = param::<Vec<DraughtingCalloutElement<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceCurve_<'a> { // entity
    pub name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: Vec<PcurveOrSurface<'a>>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceCurve<'a> = Id<SurfaceCurve_<'a>>;
impl<'a> FromEntity<'a> for SurfaceCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, curve_3d) = param::<Curve<'a>>(false, s)?;
        let (s, associated_geometry) = param::<Vec<PcurveOrSurface<'a>>>(false, s)?;
        let (s, master_representation) = param::<PreferredSurfaceCurveRepresentation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            curve_3d,
            associated_geometry,
            master_representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceCurveSweptAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub directrix: Curve<'a>,
    pub start_param: f64,
    pub end_param: f64,
    pub reference_surface: Surface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceCurveSweptAreaSolid<'a> = Id<SurfaceCurveSweptAreaSolid_<'a>>;
impl<'a> FromEntity<'a> for SurfaceCurveSweptAreaSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceCurveSweptAreaSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceCurveSweptAreaSolid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_CURVE_SWEPT_AREA_SOLID(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, swept_area) = param::<CurveBoundedSurface<'a>>(false, s)?;
        let (s, directrix) = param::<Curve<'a>>(false, s)?;
        let (s, start_param) = param::<f64>(false, s)?;
        let (s, end_param) = param::<f64>(false, s)?;
        let (s, reference_surface) = param::<Surface<'a>>(true, s)?;
        Ok((s, Self {
            name,
            swept_area,
            directrix,
            start_param,
            end_param,
            reference_surface,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceOfLinearExtrusion_<'a> { // entity
    pub name: Label<'a>,
    pub swept_curve: Curve<'a>,
    pub extrusion_axis: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceOfLinearExtrusion<'a> = Id<SurfaceOfLinearExtrusion_<'a>>;
impl<'a> FromEntity<'a> for SurfaceOfLinearExtrusion_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceOfLinearExtrusion(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceOfLinearExtrusion_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_OF_LINEAR_EXTRUSION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, swept_curve) = param::<Curve<'a>>(false, s)?;
        let (s, extrusion_axis) = param::<Vector<'a>>(true, s)?;
        Ok((s, Self {
            name,
            swept_curve,
            extrusion_axis,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceOfRevolution_<'a> { // entity
    pub name: Label<'a>,
    pub swept_curve: Curve<'a>,
    pub axis_position: Axis1Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceOfRevolution<'a> = Id<SurfaceOfRevolution_<'a>>;
impl<'a> FromEntity<'a> for SurfaceOfRevolution_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceOfRevolution(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceOfRevolution_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_OF_REVOLUTION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, swept_curve) = param::<Curve<'a>>(false, s)?;
        let (s, axis_position) = param::<Axis1Placement<'a>>(true, s)?;
        Ok((s, Self {
            name,
            swept_curve,
            axis_position,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub surface_1: Surface<'a>,
    pub surface_2: Surface<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfacePair<'a> = Id<SurfacePair_<'a>>;
impl<'a> FromEntity<'a> for SurfacePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfacePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfacePair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, surface_1) = param::<Surface<'a>>(false, s)?;
        let (s, surface_2) = param::<Surface<'a>>(false, s)?;
        let (s, orientation) = param::<bool>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            surface_1,
            surface_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfacePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_surface_1: RectangularTrimmedSurface<'a>,
    pub range_on_surface_2: RectangularTrimmedSurface<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfacePairRange<'a> = Id<SurfacePairRange_<'a>>;
impl<'a> FromEntity<'a> for SurfacePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfacePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfacePairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, range_on_surface_1) = param::<RectangularTrimmedSurface<'a>>(false, s)?;
        let (s, range_on_surface_2) = param::<RectangularTrimmedSurface<'a>>(false, s)?;
        let (s, lower_limit_actual_rotation) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_actual_rotation) = param::<RotationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            range_on_surface_1,
            range_on_surface_2,
            lower_limit_actual_rotation,
            upper_limit_actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfacePatch_<'a> { // entity
    pub parent_surface: BoundedSurface<'a>,
    pub u_transition: TransitionCode<'a>,
    pub v_transition: TransitionCode<'a>,
    pub u_sense: bool,
    pub v_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfacePatch<'a> = Id<SurfacePatch_<'a>>;
impl<'a> FromEntity<'a> for SurfacePatch_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfacePatch(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfacePatch_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_PATCH(")(s)?;
        let (s, parent_surface) = param::<BoundedSurface<'a>>(false, s)?;
        let (s, u_transition) = param::<TransitionCode<'a>>(false, s)?;
        let (s, v_transition) = param::<TransitionCode<'a>>(false, s)?;
        let (s, u_sense) = param::<bool>(false, s)?;
        let (s, v_sense) = param::<bool>(true, s)?;
        Ok((s, Self {
            parent_surface,
            u_transition,
            v_transition,
            u_sense,
            v_sense,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceProfileTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceProfileTolerance<'a> = Id<SurfaceProfileTolerance_<'a>>;
impl<'a> FromEntity<'a> for SurfaceProfileTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceProfileTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceProfileTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_PROFILE_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceRenderingProperties_<'a> { // entity
    pub rendered_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceRenderingProperties<'a> = Id<SurfaceRenderingProperties_<'a>>;
impl<'a> FromEntity<'a> for SurfaceRenderingProperties_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceRenderingProperties(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceRenderingProperties_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_RENDERING_PROPERTIES(")(s)?;
        let (s, rendered_colour) = param::<Colour<'a>>(true, s)?;
        Ok((s, Self {
            rendered_colour,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_surface: Surface<'a>,
    pub transformation: CartesianTransformationOperator3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceReplica<'a> = Id<SurfaceReplica_<'a>>;
impl<'a> FromEntity<'a> for SurfaceReplica_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceReplica(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceReplica_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_REPLICA(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, parent_surface) = param::<Surface<'a>>(false, s)?;
        let (s, transformation) = param::<CartesianTransformationOperator3d<'a>>(true, s)?;
        Ok((s, Self {
            name,
            parent_surface,
            transformation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum SurfaceSide<'a> { // enum
    Positive,
    Negative,
    Both,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SurfaceSide<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SurfaceSide::*;
        alt((
            map(tag(".POSITIVE."), |_| Positive),
            map(tag(".NEGATIVE."), |_| Negative),
            map(tag(".BOTH."), |_| Both),
        ))(s)
    }
}
#[derive(Debug)]
pub struct SurfaceSideStyle_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<SurfaceStyleElementSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceSideStyle<'a> = Id<SurfaceSideStyle_<'a>>;
impl<'a> FromEntity<'a> for SurfaceSideStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceSideStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceSideStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_SIDE_STYLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<SurfaceStyleElementSelect<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceSideStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SurfaceSideStyleSelect<'a> = Id<SurfaceSideStyleSelect_<'a>>;

#[derive(Debug)]
pub struct SurfaceStyleBoundary_<'a> { // entity
    pub style_of_boundary: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleBoundary<'a> = Id<SurfaceStyleBoundary_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleBoundary_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleBoundary(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleBoundary_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_BOUNDARY(")(s)?;
        let (s, style_of_boundary) = param::<CurveOrRender<'a>>(true, s)?;
        Ok((s, Self {
            style_of_boundary,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleControlGrid_<'a> { // entity
    pub style_of_control_grid: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleControlGrid<'a> = Id<SurfaceStyleControlGrid_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleControlGrid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleControlGrid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleControlGrid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_CONTROL_GRID(")(s)?;
        let (s, style_of_control_grid) = param::<CurveOrRender<'a>>(true, s)?;
        Ok((s, Self {
            style_of_control_grid,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleElementSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SurfaceStyleElementSelect<'a> = Id<SurfaceStyleElementSelect_<'a>>;

#[derive(Debug)]
pub struct SurfaceStyleFillArea_<'a> { // entity
    pub fill_area: FillAreaStyle<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleFillArea<'a> = Id<SurfaceStyleFillArea_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleFillArea_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleFillArea(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleFillArea_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_FILL_AREA(")(s)?;
        let (s, fill_area) = param::<FillAreaStyle<'a>>(true, s)?;
        Ok((s, Self {
            fill_area,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleParameterLine_<'a> { // entity
    pub style_of_parameter_lines: CurveOrRender<'a>,
    pub direction_counts: Vec<DirectionCountSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleParameterLine<'a> = Id<SurfaceStyleParameterLine_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleParameterLine_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleParameterLine(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleParameterLine_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_PARAMETER_LINE(")(s)?;
        let (s, style_of_parameter_lines) = param::<CurveOrRender<'a>>(false, s)?;
        let (s, direction_counts) = param::<Vec<DirectionCountSelect<'a>>>(true, s)?;
        Ok((s, Self {
            style_of_parameter_lines,
            direction_counts,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleReflectanceAmbient_<'a> { // entity
    pub ambient_reflectance: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleReflectanceAmbient<'a> = Id<SurfaceStyleReflectanceAmbient_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleReflectanceAmbient_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleReflectanceAmbient(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleReflectanceAmbient_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_REFLECTANCE_AMBIENT(")(s)?;
        let (s, ambient_reflectance) = param::<f64>(true, s)?;
        Ok((s, Self {
            ambient_reflectance,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleReflectanceAmbientDiffuse_<'a> { // entity
    pub ambient_reflectance: f64,
    pub diffuse_reflectance: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleReflectanceAmbientDiffuse<'a> = Id<SurfaceStyleReflectanceAmbientDiffuse_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleReflectanceAmbientDiffuse_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleReflectanceAmbientDiffuse(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleReflectanceAmbientDiffuse_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE(")(s)?;
        let (s, ambient_reflectance) = param::<f64>(false, s)?;
        let (s, diffuse_reflectance) = param::<f64>(true, s)?;
        Ok((s, Self {
            ambient_reflectance,
            diffuse_reflectance,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a> { // entity
    pub ambient_reflectance: f64,
    pub diffuse_reflectance: f64,
    pub specular_reflectance: f64,
    pub specular_exponent: f64,
    pub specular_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleReflectanceAmbientDiffuseSpecular<'a> = Id<SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleReflectanceAmbientDiffuseSpecular(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE_SPECULAR(")(s)?;
        let (s, ambient_reflectance) = param::<f64>(false, s)?;
        let (s, diffuse_reflectance) = param::<f64>(false, s)?;
        let (s, specular_reflectance) = param::<f64>(false, s)?;
        let (s, specular_exponent) = param::<f64>(false, s)?;
        let (s, specular_colour) = param::<Colour<'a>>(true, s)?;
        Ok((s, Self {
            ambient_reflectance,
            diffuse_reflectance,
            specular_reflectance,
            specular_exponent,
            specular_colour,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleRendering_<'a> { // entity
    pub rendering_method: ShadingSurfaceMethod<'a>,
    pub surface_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleRendering<'a> = Id<SurfaceStyleRendering_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleRendering_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleRendering(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleRendering_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_RENDERING(")(s)?;
        let (s, rendering_method) = param::<ShadingSurfaceMethod<'a>>(false, s)?;
        let (s, surface_colour) = param::<Colour<'a>>(true, s)?;
        Ok((s, Self {
            rendering_method,
            surface_colour,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleRenderingWithProperties_<'a> { // entity
    pub rendering_method: ShadingSurfaceMethod<'a>,
    pub surface_colour: Colour<'a>,
    pub properties: Vec<RenderingPropertiesSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleRenderingWithProperties<'a> = Id<SurfaceStyleRenderingWithProperties_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleRenderingWithProperties_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleRenderingWithProperties(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleRenderingWithProperties_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_RENDERING_WITH_PROPERTIES(")(s)?;
        let (s, rendering_method) = param::<ShadingSurfaceMethod<'a>>(false, s)?;
        let (s, surface_colour) = param::<Colour<'a>>(false, s)?;
        let (s, properties) = param::<Vec<RenderingPropertiesSelect<'a>>>(true, s)?;
        Ok((s, Self {
            rendering_method,
            surface_colour,
            properties,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleSegmentationCurve_<'a> { // entity
    pub style_of_segmentation_curve: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleSegmentationCurve<'a> = Id<SurfaceStyleSegmentationCurve_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleSegmentationCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleSegmentationCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleSegmentationCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_SEGMENTATION_CURVE(")(s)?;
        let (s, style_of_segmentation_curve) = param::<CurveOrRender<'a>>(true, s)?;
        Ok((s, Self {
            style_of_segmentation_curve,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleSilhouette_<'a> { // entity
    pub style_of_silhouette: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleSilhouette<'a> = Id<SurfaceStyleSilhouette_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleSilhouette_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleSilhouette(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleSilhouette_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_SILHOUETTE(")(s)?;
        let (s, style_of_silhouette) = param::<CurveOrRender<'a>>(true, s)?;
        Ok((s, Self {
            style_of_silhouette,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleTransparent_<'a> { // entity
    pub transparency: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleTransparent<'a> = Id<SurfaceStyleTransparent_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleTransparent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleTransparent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleTransparent_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_TRANSPARENT(")(s)?;
        let (s, transparency) = param::<f64>(true, s)?;
        Ok((s, Self {
            transparency,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceStyleUsage_<'a> { // entity
    pub side: SurfaceSide<'a>,
    pub style: SurfaceSideStyleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleUsage<'a> = Id<SurfaceStyleUsage_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceStyleUsage_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_STYLE_USAGE(")(s)?;
        let (s, side) = param::<SurfaceSide<'a>>(false, s)?;
        let (s, style) = param::<SurfaceSideStyleSelect<'a>>(true, s)?;
        Ok((s, Self {
            side,
            style,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SurfaceTextureRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceTextureRepresentation<'a> = Id<SurfaceTextureRepresentation_<'a>>;
impl<'a> FromEntity<'a> for SurfaceTextureRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceTextureRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SurfaceTextureRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SURFACE_TEXTURE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}

#[derive(Debug)]
pub struct SurfaceToleranceDeviation<'a>(pub PositiveLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for SurfaceToleranceDeviation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveLengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct SurfaceToleranceParameter<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SurfaceToleranceParameter<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct SweptAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptAreaSolid<'a> = Id<SweptAreaSolid_<'a>>;
impl<'a> FromEntity<'a> for SweptAreaSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SweptAreaSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SweptAreaSolid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SWEPT_AREA_SOLID(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, swept_area) = param::<CurveBoundedSurface<'a>>(true, s)?;
        Ok((s, Self {
            name,
            swept_area,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SweptDiskSolid_<'a> { // entity
    pub name: Label<'a>,
    pub directrix: Curve<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    pub inner_radius: Option<PositiveLengthMeasure<'a>>,
    pub start_param: f64,
    pub end_param: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptDiskSolid<'a> = Id<SweptDiskSolid_<'a>>;
impl<'a> FromEntity<'a> for SweptDiskSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SweptDiskSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SweptDiskSolid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SWEPT_DISK_SOLID(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, directrix) = param::<Curve<'a>>(false, s)?;
        let (s, radius) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, inner_radius) = param::<Option<PositiveLengthMeasure<'a>>>(false, s)?;
        let (s, start_param) = param::<f64>(false, s)?;
        let (s, end_param) = param::<f64>(true, s)?;
        Ok((s, Self {
            name,
            directrix,
            radius,
            inner_radius,
            start_param,
            end_param,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SweptFaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_face: FaceSurface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptFaceSolid<'a> = Id<SweptFaceSolid_<'a>>;
impl<'a> FromEntity<'a> for SweptFaceSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SweptFaceSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SweptFaceSolid_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SWEPT_FACE_SOLID(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, swept_face) = param::<FaceSurface<'a>>(true, s)?;
        Ok((s, Self {
            name,
            swept_face,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SweptSurface_<'a> { // entity
    pub name: Label<'a>,
    pub swept_curve: Curve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptSurface<'a> = Id<SweptSurface_<'a>>;
impl<'a> FromEntity<'a> for SweptSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SweptSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SweptSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SWEPT_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, swept_curve) = param::<Curve<'a>>(true, s)?;
        Ok((s, Self {
            name,
            swept_curve,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SymbolColour_<'a> { // entity
    pub colour_of_symbol: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolColour<'a> = Id<SymbolColour_<'a>>;
impl<'a> FromEntity<'a> for SymbolColour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymbolColour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SymbolColour_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SYMBOL_COLOUR(")(s)?;
        let (s, colour_of_symbol) = param::<Colour<'a>>(true, s)?;
        Ok((s, Self {
            colour_of_symbol,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SymbolRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolRepresentation<'a> = Id<SymbolRepresentation_<'a>>;
impl<'a> FromEntity<'a> for SymbolRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymbolRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SymbolRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SYMBOL_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SymbolRepresentationMap_<'a> { // entity
    pub mapping_origin: RepresentationItem<'a>,
    pub mapped_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolRepresentationMap<'a> = Id<SymbolRepresentationMap_<'a>>;
impl<'a> FromEntity<'a> for SymbolRepresentationMap_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymbolRepresentationMap(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SymbolRepresentationMap_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SYMBOL_REPRESENTATION_MAP(")(s)?;
        let (s, mapping_origin) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, mapped_representation) = param::<Representation<'a>>(true, s)?;
        Ok((s, Self {
            mapping_origin,
            mapped_representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SymbolStyle_<'a> { // entity
    pub name: Label<'a>,
    pub style_of_symbol: SymbolStyleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolStyle<'a> = Id<SymbolStyle_<'a>>;
impl<'a> FromEntity<'a> for SymbolStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymbolStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SymbolStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SYMBOL_STYLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, style_of_symbol) = param::<SymbolStyleSelect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            style_of_symbol,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SymbolStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SymbolStyleSelect<'a> = Id<SymbolStyleSelect_<'a>>;

#[derive(Debug)]
pub struct SymbolTarget_<'a> { // entity
    pub name: Label<'a>,
    pub placement: Axis2Placement<'a>,
    pub x_scale: PositiveRatioMeasure<'a>,
    pub y_scale: PositiveRatioMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolTarget<'a> = Id<SymbolTarget_<'a>>;
impl<'a> FromEntity<'a> for SymbolTarget_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymbolTarget(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SymbolTarget_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SYMBOL_TARGET(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, placement) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, x_scale) = param::<PositiveRatioMeasure<'a>>(false, s)?;
        let (s, y_scale) = param::<PositiveRatioMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            placement,
            x_scale,
            y_scale,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SymmetricShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymmetricShapeAspect<'a> = Id<SymmetricShapeAspect_<'a>>;
impl<'a> FromEntity<'a> for SymmetricShapeAspect_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymmetricShapeAspect(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SymmetricShapeAspect_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SYMMETRIC_SHAPE_ASPECT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct SymmetryTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymmetryTolerance<'a> = Id<SymmetryTolerance_<'a>>;
impl<'a> FromEntity<'a> for SymmetryTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymmetryTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for SymmetryTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("SYMMETRY_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, datum_system) = param::<Vec<DatumReference<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TactileAppearanceRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TactileAppearanceRepresentation<'a> = Id<TactileAppearanceRepresentation_<'a>>;
impl<'a> FromEntity<'a> for TactileAppearanceRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TactileAppearanceRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TactileAppearanceRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TACTILE_APPEARANCE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TanFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TanFunction<'a> = Id<TanFunction_<'a>>;
impl<'a> FromEntity<'a> for TanFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TanFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TanFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TAN_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Tangent_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Tangent<'a> = Id<Tangent_<'a>>;
impl<'a> FromEntity<'a> for Tangent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Tangent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Tangent_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TANGENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Taper_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Taper<'a> = Id<Taper_<'a>>;
impl<'a> FromEntity<'a> for Taper_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Taper(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Taper_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TAPER(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TeeProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TeeProfile<'a> = Id<TeeProfile_<'a>>;
impl<'a> FromEntity<'a> for TeeProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TeeProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TeeProfile_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEE_PROFILE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TerminatorSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub annotated_curve: AnnotationCurveOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TerminatorSymbol<'a> = Id<TerminatorSymbol_<'a>>;
impl<'a> FromEntity<'a> for TerminatorSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TerminatorSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TerminatorSymbol_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TERMINATOR_SYMBOL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, styles) = param::<Vec<PresentationStyleAssignment<'a>>>(false, s)?;
        let (s, item) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, annotated_curve) = param::<AnnotationCurveOccurrence<'a>>(true, s)?;
        Ok((s, Self {
            name,
            styles,
            item,
            annotated_curve,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Text<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Text<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct TextAlignment<'a>(pub Label<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for TextAlignment<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(Label::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}

#[derive(Debug)]
pub struct TextDelineation<'a>(pub Label<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for TextDelineation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(Label::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct TextLiteral_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteral<'a> = Id<TextLiteral_<'a>>;
impl<'a> FromEntity<'a> for TextLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TextLiteral_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEXT_LITERAL(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, literal) = param::<PresentableText<'a>>(false, s)?;
        let (s, placement) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, alignment) = param::<TextAlignment<'a>>(false, s)?;
        let (s, path) = param::<TextPath<'a>>(false, s)?;
        let (s, font) = param::<FontSelect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TextLiteralWithAssociatedCurves_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub associated_curves: Vec<Curve<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithAssociatedCurves<'a> = Id<TextLiteralWithAssociatedCurves_<'a>>;
impl<'a> FromEntity<'a> for TextLiteralWithAssociatedCurves_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextLiteralWithAssociatedCurves(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TextLiteralWithAssociatedCurves_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEXT_LITERAL_WITH_ASSOCIATED_CURVES(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, literal) = param::<PresentableText<'a>>(false, s)?;
        let (s, placement) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, alignment) = param::<TextAlignment<'a>>(false, s)?;
        let (s, path) = param::<TextPath<'a>>(false, s)?;
        let (s, font) = param::<FontSelect<'a>>(false, s)?;
        let (s, associated_curves) = param::<Vec<Curve<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            associated_curves,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TextLiteralWithBlankingBox_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub blanking: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithBlankingBox<'a> = Id<TextLiteralWithBlankingBox_<'a>>;
impl<'a> FromEntity<'a> for TextLiteralWithBlankingBox_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextLiteralWithBlankingBox(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TextLiteralWithBlankingBox_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEXT_LITERAL_WITH_BLANKING_BOX(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, literal) = param::<PresentableText<'a>>(false, s)?;
        let (s, placement) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, alignment) = param::<TextAlignment<'a>>(false, s)?;
        let (s, path) = param::<TextPath<'a>>(false, s)?;
        let (s, font) = param::<FontSelect<'a>>(false, s)?;
        let (s, blanking) = param::<PlanarBox<'a>>(true, s)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            blanking,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TextLiteralWithDelineation_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub delineation: TextDelineation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithDelineation<'a> = Id<TextLiteralWithDelineation_<'a>>;
impl<'a> FromEntity<'a> for TextLiteralWithDelineation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextLiteralWithDelineation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TextLiteralWithDelineation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEXT_LITERAL_WITH_DELINEATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, literal) = param::<PresentableText<'a>>(false, s)?;
        let (s, placement) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, alignment) = param::<TextAlignment<'a>>(false, s)?;
        let (s, path) = param::<TextPath<'a>>(false, s)?;
        let (s, font) = param::<FontSelect<'a>>(false, s)?;
        let (s, delineation) = param::<TextDelineation<'a>>(true, s)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            delineation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TextLiteralWithExtent_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub extent: PlanarExtent<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithExtent<'a> = Id<TextLiteralWithExtent_<'a>>;
impl<'a> FromEntity<'a> for TextLiteralWithExtent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextLiteralWithExtent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TextLiteralWithExtent_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEXT_LITERAL_WITH_EXTENT(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, literal) = param::<PresentableText<'a>>(false, s)?;
        let (s, placement) = param::<Axis2Placement<'a>>(false, s)?;
        let (s, alignment) = param::<TextAlignment<'a>>(false, s)?;
        let (s, path) = param::<TextPath<'a>>(false, s)?;
        let (s, font) = param::<FontSelect<'a>>(false, s)?;
        let (s, extent) = param::<PlanarExtent<'a>>(true, s)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            extent,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TextOrCharacter_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type TextOrCharacter<'a> = Id<TextOrCharacter_<'a>>;

#[derive(Debug)]
pub enum TextPath<'a> { // enum
    Left,
    Right,
    Up,
    Down,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TextPath<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TextPath::*;
        alt((
            map(tag(".LEFT."), |_| Left),
            map(tag(".RIGHT."), |_| Right),
            map(tag(".UP."), |_| Up),
            map(tag(".DOWN."), |_| Down),
        ))(s)
    }
}
#[derive(Debug)]
pub struct TextStringRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStringRepresentation<'a> = Id<TextStringRepresentation_<'a>>;
impl<'a> FromEntity<'a> for TextStringRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStringRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TextStringRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEXT_STRING_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TextStringRepresentationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type TextStringRepresentationItem<'a> = Id<TextStringRepresentationItem_<'a>>;

#[derive(Debug)]
pub struct TextStyle_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyle<'a> = Id<TextStyle_<'a>>;
impl<'a> FromEntity<'a> for TextStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TextStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEXT_STYLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, character_appearance) = param::<CharacterStyleSelect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            character_appearance,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TextStyleForDefinedFont_<'a> { // entity
    pub text_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleForDefinedFont<'a> = Id<TextStyleForDefinedFont_<'a>>;
impl<'a> FromEntity<'a> for TextStyleForDefinedFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStyleForDefinedFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TextStyleForDefinedFont_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEXT_STYLE_FOR_DEFINED_FONT(")(s)?;
        let (s, text_colour) = param::<Colour<'a>>(true, s)?;
        Ok((s, Self {
            text_colour,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TextStyleWithBoxCharacteristics_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    pub characteristics: Vec<BoxCharacteristicSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleWithBoxCharacteristics<'a> = Id<TextStyleWithBoxCharacteristics_<'a>>;
impl<'a> FromEntity<'a> for TextStyleWithBoxCharacteristics_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStyleWithBoxCharacteristics(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TextStyleWithBoxCharacteristics_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEXT_STYLE_WITH_BOX_CHARACTERISTICS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, character_appearance) = param::<CharacterStyleSelect<'a>>(false, s)?;
        let (s, characteristics) = param::<Vec<BoxCharacteristicSelect<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            character_appearance,
            characteristics,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TextStyleWithMirror_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    pub mirror_placement: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleWithMirror<'a> = Id<TextStyleWithMirror_<'a>>;
impl<'a> FromEntity<'a> for TextStyleWithMirror_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStyleWithMirror(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TextStyleWithMirror_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEXT_STYLE_WITH_MIRROR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, character_appearance) = param::<CharacterStyleSelect<'a>>(false, s)?;
        let (s, mirror_placement) = param::<Axis2Placement<'a>>(true, s)?;
        Ok((s, Self {
            name,
            character_appearance,
            mirror_placement,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TextStyleWithSpacing_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    pub character_spacing: CharacterSpacingSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleWithSpacing<'a> = Id<TextStyleWithSpacing_<'a>>;
impl<'a> FromEntity<'a> for TextStyleWithSpacing_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStyleWithSpacing(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TextStyleWithSpacing_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TEXT_STYLE_WITH_SPACING(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, character_appearance) = param::<CharacterStyleSelect<'a>>(false, s)?;
        let (s, character_spacing) = param::<CharacterSpacingSelect<'a>>(true, s)?;
        Ok((s, Self {
            name,
            character_appearance,
            character_spacing,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ThermodynamicTemperatureMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ThermodynamicTemperatureMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct ThermodynamicTemperatureMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ThermodynamicTemperatureMeasureWithUnit<'a> = Id<ThermodynamicTemperatureMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for ThermodynamicTemperatureMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ThermodynamicTemperatureMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ThermodynamicTemperatureMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ThermodynamicTemperatureUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ThermodynamicTemperatureUnit<'a> = Id<ThermodynamicTemperatureUnit_<'a>>;
impl<'a> FromEntity<'a> for ThermodynamicTemperatureUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ThermodynamicTemperatureUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ThermodynamicTemperatureUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("THERMODYNAMIC_TEMPERATURE_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Thread_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Thread<'a> = Id<Thread_<'a>>;
impl<'a> FromEntity<'a> for Thread_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Thread(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Thread_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("THREAD(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TimeInterval_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeInterval<'a> = Id<TimeInterval_<'a>>;
impl<'a> FromEntity<'a> for TimeInterval_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeInterval(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TimeInterval_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TIME_INTERVAL(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TimeIntervalAssignment_<'a> { // entity
    pub assigned_time_interval: TimeInterval<'a>,
    pub role: TimeIntervalRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalAssignment<'a> = Id<TimeIntervalAssignment_<'a>>;
impl<'a> FromEntity<'a> for TimeIntervalAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeIntervalAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TimeIntervalAssignment_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TIME_INTERVAL_ASSIGNMENT(")(s)?;
        let (s, assigned_time_interval) = param::<TimeInterval<'a>>(false, s)?;
        let (s, role) = param::<TimeIntervalRole<'a>>(true, s)?;
        Ok((s, Self {
            assigned_time_interval,
            role,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TimeIntervalBasedEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_period: TimeInterval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalBasedEffectivity<'a> = Id<TimeIntervalBasedEffectivity_<'a>>;
impl<'a> FromEntity<'a> for TimeIntervalBasedEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeIntervalBasedEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TimeIntervalBasedEffectivity_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TIME_INTERVAL_BASED_EFFECTIVITY(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, effectivity_period) = param::<TimeInterval<'a>>(true, s)?;
        Ok((s, Self {
            id,
            effectivity_period,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TimeIntervalItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type TimeIntervalItem<'a> = Id<TimeIntervalItem_<'a>>;

#[derive(Debug)]
pub struct TimeIntervalRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalRole<'a> = Id<TimeIntervalRole_<'a>>;
impl<'a> FromEntity<'a> for TimeIntervalRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeIntervalRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TimeIntervalRole_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TIME_INTERVAL_ROLE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TimeIntervalWithBounds_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub primary_bound: Option<DateTimeOrEventOccurrence<'a>>,
    pub secondary_bound: Option<DateTimeOrEventOccurrence<'a>>,
    pub duration: Option<TimeMeasureWithUnit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalWithBounds<'a> = Id<TimeIntervalWithBounds_<'a>>;
impl<'a> FromEntity<'a> for TimeIntervalWithBounds_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeIntervalWithBounds(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TimeIntervalWithBounds_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TIME_INTERVAL_WITH_BOUNDS(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, primary_bound) = param::<Option<DateTimeOrEventOccurrence<'a>>>(false, s)?;
        let (s, secondary_bound) = param::<Option<DateTimeOrEventOccurrence<'a>>>(false, s)?;
        let (s, duration) = param::<Option<TimeMeasureWithUnit<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            primary_bound,
            secondary_bound,
            duration,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TimeMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for TimeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct TimeMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeMeasureWithUnit<'a> = Id<TimeMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for TimeMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TimeMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TIME_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TimeUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeUnit<'a> = Id<TimeUnit_<'a>>;
impl<'a> FromEntity<'a> for TimeUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TimeUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TIME_UNIT(")(s)?;
        let (s, dimensions) = param::<DimensionalExponents<'a>>(true, s)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum ToleranceDeviationSelect<'a> { // select
    CurveToleranceDeviation(CurveToleranceDeviation<'a>),
    SurfaceToleranceDeviation(SurfaceToleranceDeviation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ToleranceDeviationSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("CURVE_TOLERANCE_DEVIATION("), <CurveToleranceDeviation<'a>>::parse, char(')')), |r| ToleranceDeviationSelect::CurveToleranceDeviation(r)),
            map(delimited(tag("SURFACE_TOLERANCE_DEVIATION("), <SurfaceToleranceDeviation<'a>>::parse, char(')')), |r| ToleranceDeviationSelect::SurfaceToleranceDeviation(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct ToleranceMethodDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ToleranceMethodDefinition<'a> = Id<ToleranceMethodDefinition_<'a>>;

#[derive(Debug)]
pub enum ToleranceParameterSelect<'a> { // select
    CurveToleranceParameter(CurveToleranceParameter<'a>),
    SurfaceToleranceParameter(SurfaceToleranceParameter<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ToleranceParameterSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("CURVE_TOLERANCE_PARAMETER("), <CurveToleranceParameter<'a>>::parse, char(')')), |r| ToleranceParameterSelect::CurveToleranceParameter(r)),
            map(delimited(tag("SURFACE_TOLERANCE_PARAMETER("), <SurfaceToleranceParameter<'a>>::parse, char(')')), |r| ToleranceParameterSelect::SurfaceToleranceParameter(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct ToleranceSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ToleranceSelect<'a> = Id<ToleranceSelect_<'a>>;

#[derive(Debug)]
pub struct ToleranceValue_<'a> { // entity
    pub lower_bound: MeasureWithUnit<'a>,
    pub upper_bound: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceValue<'a> = Id<ToleranceValue_<'a>>;
impl<'a> FromEntity<'a> for ToleranceValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ToleranceValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ToleranceValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TOLERANCE_VALUE(")(s)?;
        let (s, lower_bound) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, upper_bound) = param::<MeasureWithUnit<'a>>(true, s)?;
        Ok((s, Self {
            lower_bound,
            upper_bound,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ToleranceZone_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub defining_tolerance: Vec<GeometricTolerance<'a>>,
    pub form: ToleranceZoneForm<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceZone<'a> = Id<ToleranceZone_<'a>>;
impl<'a> FromEntity<'a> for ToleranceZone_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ToleranceZone(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ToleranceZone_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TOLERANCE_ZONE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(false, s)?;
        let (s, defining_tolerance) = param::<Vec<GeometricTolerance<'a>>>(false, s)?;
        let (s, form) = param::<ToleranceZoneForm<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            defining_tolerance,
            form,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ToleranceZoneDefinition_<'a> { // entity
    pub zone: ToleranceZone<'a>,
    pub boundaries: Vec<ShapeAspect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceZoneDefinition<'a> = Id<ToleranceZoneDefinition_<'a>>;
impl<'a> FromEntity<'a> for ToleranceZoneDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ToleranceZoneDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ToleranceZoneDefinition_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TOLERANCE_ZONE_DEFINITION(")(s)?;
        let (s, zone) = param::<ToleranceZone<'a>>(false, s)?;
        let (s, boundaries) = param::<Vec<ShapeAspect<'a>>>(true, s)?;
        Ok((s, Self {
            zone,
            boundaries,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ToleranceZoneForm_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceZoneForm<'a> = Id<ToleranceZoneForm_<'a>>;
impl<'a> FromEntity<'a> for ToleranceZoneForm_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ToleranceZoneForm(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ToleranceZoneForm_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TOLERANCE_ZONE_FORM(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TopologicalRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TopologicalRepresentationItem<'a> = Id<TopologicalRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for TopologicalRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TopologicalRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TopologicalRepresentationItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TOPOLOGICAL_REPRESENTATION_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ToroidalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub major_radius: PositiveLengthMeasure<'a>,
    pub minor_radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToroidalSurface<'a> = Id<ToroidalSurface_<'a>>;
impl<'a> FromEntity<'a> for ToroidalSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ToroidalSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ToroidalSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TOROIDAL_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis2Placement3d<'a>>(false, s)?;
        let (s, major_radius) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, minor_radius) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            major_radius,
            minor_radius,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Torus_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis1Placement<'a>,
    pub major_radius: PositiveLengthMeasure<'a>,
    pub minor_radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Torus<'a> = Id<Torus_<'a>>;
impl<'a> FromEntity<'a> for Torus_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Torus(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Torus_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TORUS(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, position) = param::<Axis1Placement<'a>>(false, s)?;
        let (s, major_radius) = param::<PositiveLengthMeasure<'a>>(false, s)?;
        let (s, minor_radius) = param::<PositiveLengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            position,
            major_radius,
            minor_radius,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TotalRunoutTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TotalRunoutTolerance<'a> = Id<TotalRunoutTolerance_<'a>>;
impl<'a> FromEntity<'a> for TotalRunoutTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TotalRunoutTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TotalRunoutTolerance_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TOTAL_RUNOUT_TOLERANCE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(false, s)?;
        let (s, magnitude) = param::<MeasureWithUnit<'a>>(false, s)?;
        let (s, toleranced_shape_aspect) = param::<ShapeAspect<'a>>(false, s)?;
        let (s, datum_system) = param::<Vec<DatumReference<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Transformation_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Transformation<'a> = Id<Transformation_<'a>>;

#[derive(Debug)]
pub enum TransitionCode<'a> { // enum
    Discontinuous,
    Continuous,
    ContSameGradient,
    ContSameGradientSameCurvature,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TransitionCode<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TransitionCode::*;
        alt((
            map(tag(".DISCONTINUOUS."), |_| Discontinuous),
            map(tag(".CONTINUOUS."), |_| Continuous),
            map(tag(".CONT_SAME_GRADIENT."), |_| ContSameGradient),
            map(tag(".CONT_SAME_GRADIENT_SAME_CURVATURE."), |_| ContSameGradientSameCurvature),
        ))(s)
    }
}
#[derive(Debug)]
pub struct TransitionFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TransitionFeature<'a> = Id<TransitionFeature_<'a>>;
impl<'a> FromEntity<'a> for TransitionFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TransitionFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TransitionFeature_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TRANSITION_FEATURE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum TranslationalRangeMeasure<'a> { // select
    LengthMeasure(LengthMeasure<'a>),
    UnlimitedRange(UnlimitedRange<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for TranslationalRangeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LENGTH_MEASURE("), <LengthMeasure<'a>>::parse, char(')')), |r| TranslationalRangeMeasure::LengthMeasure(r)),
            map(delimited(tag("UNLIMITED_RANGE("), <UnlimitedRange<'a>>::parse, char(')')), |r| TranslationalRangeMeasure::UnlimitedRange(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct TrimmedCurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub trim_1: Vec<TrimmingSelect<'a>>,
    pub trim_2: Vec<TrimmingSelect<'a>>,
    pub sense_agreement: bool,
    pub master_representation: TrimmingPreference<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TrimmedCurve<'a> = Id<TrimmedCurve_<'a>>;
impl<'a> FromEntity<'a> for TrimmedCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TrimmedCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TrimmedCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TRIMMED_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, basis_curve) = param::<Curve<'a>>(false, s)?;
        let (s, trim_1) = param::<Vec<TrimmingSelect<'a>>>(false, s)?;
        let (s, trim_2) = param::<Vec<TrimmingSelect<'a>>>(false, s)?;
        let (s, sense_agreement) = param::<bool>(false, s)?;
        let (s, master_representation) = param::<TrimmingPreference<'a>>(true, s)?;
        Ok((s, Self {
            name,
            basis_curve,
            trim_1,
            trim_2,
            sense_agreement,
            master_representation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum TrimmingPreference<'a> { // enum
    Cartesian,
    Parameter,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TrimmingPreference<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TrimmingPreference::*;
        alt((
            map(tag(".CARTESIAN."), |_| Cartesian),
            map(tag(".PARAMETER."), |_| Parameter),
            map(tag(".UNSPECIFIED."), |_| Unspecified),
        ))(s)
    }
}
#[derive(Debug)]
pub enum TrimmingSelect<'a> { // select
    CartesianPoint(CartesianPoint<'a>),
    ParameterValue(ParameterValue<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for TrimmingSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<CartesianPoint<'a>>::parse, |r| TrimmingSelect::CartesianPoint(r)),
            map(delimited(tag("PARAMETER_VALUE("), <ParameterValue<'a>>::parse, char(')')), |r| TrimmingSelect::ParameterValue(r)),
        ))(s)
    }
}
#[derive(Debug)]
pub struct TwoDirectionRepeatFactor_<'a> { // entity
    pub name: Label<'a>,
    pub repeat_factor: Vector<'a>,
    pub second_repeat_factor: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TwoDirectionRepeatFactor<'a> = Id<TwoDirectionRepeatFactor_<'a>>;
impl<'a> FromEntity<'a> for TwoDirectionRepeatFactor_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TwoDirectionRepeatFactor(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TwoDirectionRepeatFactor_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TWO_DIRECTION_REPEAT_FACTOR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, repeat_factor) = param::<Vector<'a>>(false, s)?;
        let (s, second_repeat_factor) = param::<Vector<'a>>(true, s)?;
        Ok((s, Self {
            name,
            repeat_factor,
            second_repeat_factor,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct TypeQualifier_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TypeQualifier<'a> = Id<TypeQualifier_<'a>>;
impl<'a> FromEntity<'a> for TypeQualifier_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TypeQualifier(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for TypeQualifier_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("TYPE_QUALIFIER(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UDirectionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for UDirectionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct UnaryBooleanExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryBooleanExpression<'a> = Id<UnaryBooleanExpression_<'a>>;
impl<'a> FromEntity<'a> for UnaryBooleanExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnaryBooleanExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UnaryBooleanExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNARY_BOOLEAN_EXPRESSION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UnaryFunctionCall_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryFunctionCall<'a> = Id<UnaryFunctionCall_<'a>>;
impl<'a> FromEntity<'a> for UnaryFunctionCall_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnaryFunctionCall(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UnaryFunctionCall_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNARY_FUNCTION_CALL(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UnaryGenericExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryGenericExpression<'a> = Id<UnaryGenericExpression_<'a>>;
impl<'a> FromEntity<'a> for UnaryGenericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnaryGenericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UnaryGenericExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNARY_GENERIC_EXPRESSION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UnaryNumericExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryNumericExpression<'a> = Id<UnaryNumericExpression_<'a>>;
impl<'a> FromEntity<'a> for UnaryNumericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnaryNumericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UnaryNumericExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNARY_NUMERIC_EXPRESSION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UncertaintyAssignedRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    pub uncertainty: Vec<UncertaintyMeasureWithUnit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UncertaintyAssignedRepresentation<'a> = Id<UncertaintyAssignedRepresentation_<'a>>;
impl<'a> FromEntity<'a> for UncertaintyAssignedRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UncertaintyAssignedRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UncertaintyAssignedRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNCERTAINTY_ASSIGNED_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(false, s)?;
        let (s, uncertainty) = param::<Vec<UncertaintyMeasureWithUnit<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            uncertainty,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UncertaintyMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UncertaintyMeasureWithUnit<'a> = Id<UncertaintyMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for UncertaintyMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UncertaintyMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UncertaintyMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNCERTAINTY_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UncertaintyQualifier_<'a> { // entity
    pub measure_name: Label<'a>,
    pub description: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UncertaintyQualifier<'a> = Id<UncertaintyQualifier_<'a>>;
impl<'a> FromEntity<'a> for UncertaintyQualifier_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UncertaintyQualifier(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UncertaintyQualifier_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNCERTAINTY_QUALIFIER(")(s)?;
        let (s, measure_name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Text<'a>>(true, s)?;
        Ok((s, Self {
            measure_name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UnconstrainedPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnconstrainedPair<'a> = Id<UnconstrainedPair_<'a>>;
impl<'a> FromEntity<'a> for UnconstrainedPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnconstrainedPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UnconstrainedPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNCONSTRAINED_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UnconstrainedPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_placement: Axis2Placement3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnconstrainedPairValue<'a> = Id<UnconstrainedPairValue_<'a>>;
impl<'a> FromEntity<'a> for UnconstrainedPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnconstrainedPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UnconstrainedPairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNCONSTRAINED_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, actual_placement) = param::<Axis2Placement3d<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            actual_placement,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UniformCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniformCurve<'a> = Id<UniformCurve_<'a>>;
impl<'a> FromEntity<'a> for UniformCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UniformCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UniformCurve_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNIFORM_CURVE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<CartesianPoint<'a>>>(false, s)?;
        let (s, curve_form) = param::<BSplineCurveForm<'a>>(false, s)?;
        let (s, closed_curve) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UniformSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniformSurface<'a> = Id<UniformSurface_<'a>>;
impl<'a> FromEntity<'a> for UniformSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UniformSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UniformSurface_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNIFORM_SURFACE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, u_degree) = param::<i64>(false, s)?;
        let (s, v_degree) = param::<i64>(false, s)?;
        let (s, control_points_list) = param::<Vec<Vec<CartesianPoint<'a>>>>(false, s)?;
        let (s, surface_form) = param::<BSplineSurfaceForm<'a>>(false, s)?;
        let (s, u_closed) = param::<Logical>(false, s)?;
        let (s, v_closed) = param::<Logical>(false, s)?;
        let (s, self_intersect) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Unit_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Unit<'a> = Id<Unit_<'a>>;

#[derive(Debug)]
pub struct UniversalPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub input_skew_angle: Option<PlaneAngleMeasure<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniversalPair<'a> = Id<UniversalPair_<'a>>;
impl<'a> FromEntity<'a> for UniversalPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UniversalPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UniversalPair_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNIVERSAL_PAIR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, transform_item_1) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, transform_item_2) = param::<RepresentationItem<'a>>(false, s)?;
        let (s, joint) = param::<KinematicJoint<'a>>(false, s)?;
        let (s, input_skew_angle) = param::<Option<PlaneAngleMeasure<'a>>>(true, s)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            input_skew_angle,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UniversalPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_first_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_first_rotation: RotationalRangeMeasure<'a>,
    pub lower_limit_second_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_second_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniversalPairRange<'a> = Id<UniversalPairRange_<'a>>;
impl<'a> FromEntity<'a> for UniversalPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UniversalPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UniversalPairRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNIVERSAL_PAIR_RANGE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, lower_limit_first_rotation) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_first_rotation) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, lower_limit_second_rotation) = param::<RotationalRangeMeasure<'a>>(false, s)?;
        let (s, upper_limit_second_rotation) = param::<RotationalRangeMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_first_rotation,
            upper_limit_first_rotation,
            lower_limit_second_rotation,
            upper_limit_second_rotation,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct UniversalPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub first_rotation_angle: PlaneAngleMeasure<'a>,
    pub second_rotation_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniversalPairValue<'a> = Id<UniversalPairValue_<'a>>;
impl<'a> FromEntity<'a> for UniversalPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UniversalPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for UniversalPairValue_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("UNIVERSAL_PAIR_VALUE(")(s)?;
        let (s, applies_to_pair) = param::<KinematicPair<'a>>(false, s)?;
        let (s, first_rotation_angle) = param::<PlaneAngleMeasure<'a>>(false, s)?;
        let (s, second_rotation_angle) = param::<PlaneAngleMeasure<'a>>(true, s)?;
        Ok((s, Self {
            applies_to_pair,
            first_rotation_angle,
            second_rotation_angle,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub enum UnlimitedRange<'a> { // enum
    Unlimited,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for UnlimitedRange<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use UnlimitedRange::*;
        map(tag(".UNLIMITED."), |_| Unlimited)(s)
    }
}
#[derive(Debug)]
pub struct VDirectionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for VDirectionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct ValueFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ValueFunction<'a> = Id<ValueFunction_<'a>>;
impl<'a> FromEntity<'a> for ValueFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ValueFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ValueFunction_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VALUE_FUNCTION(")(s)?;
        let (s, operand) = param::<GenericExpression<'a>>(true, s)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ValueQualifier_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ValueQualifier<'a> = Id<ValueQualifier_<'a>>;

#[derive(Debug)]
pub struct ValueRange_<'a> { // entity
    pub name: Label<'a>,
    pub item_element: CompoundItemDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ValueRange<'a> = Id<ValueRange_<'a>>;
impl<'a> FromEntity<'a> for ValueRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ValueRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ValueRange_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VALUE_RANGE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, item_element) = param::<CompoundItemDefinition<'a>>(true, s)?;
        Ok((s, Self {
            name,
            item_element,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ValueRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub value_component: MeasureValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ValueRepresentationItem<'a> = Id<ValueRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for ValueRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ValueRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ValueRepresentationItem_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VALUE_REPRESENTATION_ITEM(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(true, s)?;
        Ok((s, Self {
            name,
            value_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Variable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Variable<'a> = Id<Variable_<'a>>;
impl<'a> FromEntity<'a> for Variable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Variable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Variable_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VARIABLE(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct VariableSemantics_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VariableSemantics<'a> = Id<VariableSemantics_<'a>>;
impl<'a> FromEntity<'a> for VariableSemantics_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VariableSemantics(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for VariableSemantics_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VARIABLE_SEMANTICS(")(s)?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Vector_<'a> { // entity
    pub name: Label<'a>,
    pub orientation: Direction<'a>,
    pub magnitude: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Vector<'a> = Id<Vector_<'a>>;
impl<'a> FromEntity<'a> for Vector_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Vector(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Vector_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VECTOR(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, orientation) = param::<Direction<'a>>(false, s)?;
        let (s, magnitude) = param::<LengthMeasure<'a>>(true, s)?;
        Ok((s, Self {
            name,
            orientation,
            magnitude,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct VectorOrDirection_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type VectorOrDirection<'a> = Id<VectorOrDirection_<'a>>;

#[allow(non_snake_case)]
#[derive(Debug)]
pub struct VectorStyle_<'a> { // entity
    pub pre_defined_item__name: Label<'a>,
    pub curve_style__name: Label<'a>,
    pub curve_font: CurveFontOrScaledCurveFontSelect<'a>,
    pub curve_width: SizeSelect<'a>,
    pub curve_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VectorStyle<'a> = Id<VectorStyle_<'a>>;
impl<'a> FromEntity<'a> for VectorStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VectorStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for VectorStyle_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VECTOR_STYLE(")(s)?;
        #[allow(non_snake_case)]
        let (s, pre_defined_item__name) = param::<Label<'a>>(false, s)?;
        #[allow(non_snake_case)]
        let (s, curve_style__name) = param::<Label<'a>>(false, s)?;
        let (s, curve_font) = param::<CurveFontOrScaledCurveFontSelect<'a>>(false, s)?;
        let (s, curve_width) = param::<SizeSelect<'a>>(false, s)?;
        let (s, curve_colour) = param::<Colour<'a>>(true, s)?;
        Ok((s, Self {
            pre_defined_item__name,
            curve_style__name,
            curve_font,
            curve_width,
            curve_colour,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct VeeProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VeeProfile<'a> = Id<VeeProfile_<'a>>;
impl<'a> FromEntity<'a> for VeeProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VeeProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for VeeProfile_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VEE_PROFILE(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, of_shape) = param::<ProductDefinitionShape<'a>>(false, s)?;
        let (s, product_definitional) = param::<Logical>(true, s)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct VersionedActionRequest_<'a> { // entity
    pub id: Identifier<'a>,
    pub version: Label<'a>,
    pub purpose: Text<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VersionedActionRequest<'a> = Id<VersionedActionRequest_<'a>>;
impl<'a> FromEntity<'a> for VersionedActionRequest_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VersionedActionRequest(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for VersionedActionRequest_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VERSIONED_ACTION_REQUEST(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, version) = param::<Label<'a>>(false, s)?;
        let (s, purpose) = param::<Text<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(true, s)?;
        Ok((s, Self {
            id,
            version,
            purpose,
            description,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct VersionedActionRequestRelationship_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_versioned_action_request: VersionedActionRequest<'a>,
    pub related_versioned_action_request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VersionedActionRequestRelationship<'a> = Id<VersionedActionRequestRelationship_<'a>>;
impl<'a> FromEntity<'a> for VersionedActionRequestRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VersionedActionRequestRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for VersionedActionRequestRelationship_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VERSIONED_ACTION_REQUEST_RELATIONSHIP(")(s)?;
        let (s, id) = param::<Identifier<'a>>(false, s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, description) = param::<Option<Text<'a>>>(false, s)?;
        let (s, relating_versioned_action_request) = param::<VersionedActionRequest<'a>>(false, s)?;
        let (s, related_versioned_action_request) = param::<VersionedActionRequest<'a>>(true, s)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_versioned_action_request,
            related_versioned_action_request,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct Vertex_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Vertex<'a> = Id<Vertex_<'a>>;
impl<'a> FromEntity<'a> for Vertex_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Vertex(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for Vertex_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VERTEX(")(s)?;
        let (s, name) = param::<Label<'a>>(true, s)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct VertexLoop_<'a> { // entity
    pub name: Label<'a>,
    pub loop_vertex: Vertex<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VertexLoop<'a> = Id<VertexLoop_<'a>>;
impl<'a> FromEntity<'a> for VertexLoop_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VertexLoop(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for VertexLoop_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VERTEX_LOOP(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, loop_vertex) = param::<Vertex<'a>>(true, s)?;
        Ok((s, Self {
            name,
            loop_vertex,
            _marker: std::marker::PhantomData}))
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct VertexPoint_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub vertex_geometry: Point<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VertexPoint<'a> = Id<VertexPoint_<'a>>;
impl<'a> FromEntity<'a> for VertexPoint_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VertexPoint(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for VertexPoint_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VERTEX_POINT(")(s)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param::<Label<'a>>(false, s)?;
        let (s, vertex_geometry) = param::<Point<'a>>(true, s)?;
        Ok((s, Self {
            representation_item__name,
            vertex_geometry,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct ViewVolume_<'a> { // entity
    pub projection_type: CentralOrParallel<'a>,
    pub projection_point: CartesianPoint<'a>,
    pub view_plane_distance: LengthMeasure<'a>,
    pub front_plane_distance: LengthMeasure<'a>,
    pub front_plane_clipping: bool,
    pub back_plane_distance: LengthMeasure<'a>,
    pub back_plane_clipping: bool,
    pub view_volume_sides_clipping: bool,
    pub view_window: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ViewVolume<'a> = Id<ViewVolume_<'a>>;
impl<'a> FromEntity<'a> for ViewVolume_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ViewVolume(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for ViewVolume_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VIEW_VOLUME(")(s)?;
        let (s, projection_type) = param::<CentralOrParallel<'a>>(false, s)?;
        let (s, projection_point) = param::<CartesianPoint<'a>>(false, s)?;
        let (s, view_plane_distance) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, front_plane_distance) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, front_plane_clipping) = param::<bool>(false, s)?;
        let (s, back_plane_distance) = param::<LengthMeasure<'a>>(false, s)?;
        let (s, back_plane_clipping) = param::<bool>(false, s)?;
        let (s, view_volume_sides_clipping) = param::<bool>(false, s)?;
        let (s, view_window) = param::<PlanarBox<'a>>(true, s)?;
        Ok((s, Self {
            projection_type,
            projection_point,
            view_plane_distance,
            front_plane_distance,
            front_plane_clipping,
            back_plane_distance,
            back_plane_clipping,
            view_volume_sides_clipping,
            view_window,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct VisualAppearanceRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VisualAppearanceRepresentation<'a> = Id<VisualAppearanceRepresentation_<'a>>;
impl<'a> FromEntity<'a> for VisualAppearanceRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VisualAppearanceRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for VisualAppearanceRepresentation_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VISUAL_APPEARANCE_REPRESENTATION(")(s)?;
        let (s, name) = param::<Label<'a>>(false, s)?;
        let (s, items) = param::<Vec<RepresentationItem<'a>>>(false, s)?;
        let (s, context_of_items) = param::<RepresentationContext<'a>>(true, s)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct VolumeMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for VolumeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub struct VolumeMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VolumeMeasureWithUnit<'a> = Id<VolumeMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for VolumeMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VolumeMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for VolumeMeasureWithUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VOLUME_MEASURE_WITH_UNIT(")(s)?;
        let (s, value_component) = param::<MeasureValue<'a>>(false, s)?;
        let (s, unit_component) = param::<Unit<'a>>(true, s)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct VolumeUnit_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VolumeUnit<'a> = Id<VolumeUnit_<'a>>;
impl<'a> FromEntity<'a> for VolumeUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VolumeUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for VolumeUnit_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("VOLUME_UNIT(")(s)?;
        let (s, elements) = param::<Vec<DerivedUnitElement<'a>>>(true, s)?;
        Ok((s, Self {
            elements,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct XorExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type XorExpression<'a> = Id<XorExpression_<'a>>;
impl<'a> FromEntity<'a> for XorExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::XorExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> Parse<'a> for XorExpression_<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (s, _) = tag("XOR_EXPRESSION(")(s)?;
        let (s, operands) = param::<Vec<GenericExpression<'a>>>(true, s)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
#[derive(Debug)]
pub struct YearNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for YearNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub enum YprEnumeration<'a> { // enum
    Yaw,
    Pitch,
    Roll,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for YprEnumeration<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use YprEnumeration::*;
        alt((
            map(tag(".YAW."), |_| Yaw),
            map(tag(".PITCH."), |_| Pitch),
            map(tag(".ROLL."), |_| Roll),
        ))(s)
    }
}
#[derive(Debug)]
pub struct YprRotation<'a>(pub Vec<PlaneAngleMeasure<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for YprRotation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<PlaneAngleMeasure<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
#[derive(Debug)]
pub enum Entity<'a> {
    AbsFunction(AbsFunction_<'a>),
    AcosFunction(AcosFunction_<'a>),
    Action(Action_<'a>),
    ActionAssignment(ActionAssignment_<'a>),
    ActionDirective(ActionDirective_<'a>),
    ActionMethod(ActionMethod_<'a>),
    ActionMethodRelationship(ActionMethodRelationship_<'a>),
    ActionProperty(ActionProperty_<'a>),
    ActionPropertyRepresentation(ActionPropertyRepresentation_<'a>),
    ActionRelationship(ActionRelationship_<'a>),
    ActionRequestAssignment(ActionRequestAssignment_<'a>),
    ActionRequestSolution(ActionRequestSolution_<'a>),
    ActionRequestStatus(ActionRequestStatus_<'a>),
    ActionResource(ActionResource_<'a>),
    ActionResourceRequirement(ActionResourceRequirement_<'a>),
    ActionResourceType(ActionResourceType_<'a>),
    ActionStatus(ActionStatus_<'a>),
    Address(Address_<'a>),
    AdvancedBrepShapeRepresentation(AdvancedBrepShapeRepresentation_<'a>),
    AdvancedFace(AdvancedFace_<'a>),
    AlternateProductRelationship(AlternateProductRelationship_<'a>),
    AmountOfSubstanceMeasureWithUnit(AmountOfSubstanceMeasureWithUnit_<'a>),
    AmountOfSubstanceUnit(AmountOfSubstanceUnit_<'a>),
    AndExpression(AndExpression_<'a>),
    AngularDimension(AngularDimension_<'a>),
    AngularLocation(AngularLocation_<'a>),
    AngularSize(AngularSize_<'a>),
    AngularityTolerance(AngularityTolerance_<'a>),
    AnnotationCurveOccurrence(AnnotationCurveOccurrence_<'a>),
    AnnotationFillArea(AnnotationFillArea_<'a>),
    AnnotationFillAreaOccurrence(AnnotationFillAreaOccurrence_<'a>),
    AnnotationOccurrence(AnnotationOccurrence_<'a>),
    AnnotationOccurrenceAssociativity(AnnotationOccurrenceAssociativity_<'a>),
    AnnotationOccurrenceRelationship(AnnotationOccurrenceRelationship_<'a>),
    AnnotationPlane(AnnotationPlane_<'a>),
    AnnotationSubfigureOccurrence(AnnotationSubfigureOccurrence_<'a>),
    AnnotationSymbol(AnnotationSymbol_<'a>),
    AnnotationSymbolOccurrence(AnnotationSymbolOccurrence_<'a>),
    AnnotationText(AnnotationText_<'a>),
    AnnotationTextCharacter(AnnotationTextCharacter_<'a>),
    AnnotationTextOccurrence(AnnotationTextOccurrence_<'a>),
    Apex(Apex_<'a>),
    ApplicationContext(ApplicationContext_<'a>),
    ApplicationContextElement(ApplicationContextElement_<'a>),
    ApplicationContextRelationship(ApplicationContextRelationship_<'a>),
    ApplicationProtocolDefinition(ApplicationProtocolDefinition_<'a>),
    AppliedActionAssignment(AppliedActionAssignment_<'a>),
    AppliedActionRequestAssignment(AppliedActionRequestAssignment_<'a>),
    AppliedApprovalAssignment(AppliedApprovalAssignment_<'a>),
    AppliedArea(AppliedArea_<'a>),
    AppliedCertificationAssignment(AppliedCertificationAssignment_<'a>),
    AppliedClassificationAssignment(AppliedClassificationAssignment_<'a>),
    AppliedContractAssignment(AppliedContractAssignment_<'a>),
    AppliedDateAndTimeAssignment(AppliedDateAndTimeAssignment_<'a>),
    AppliedDateAssignment(AppliedDateAssignment_<'a>),
    AppliedDocumentReference(AppliedDocumentReference_<'a>),
    AppliedDocumentUsageConstraintAssignment(AppliedDocumentUsageConstraintAssignment_<'a>),
    AppliedEffectivityAssignment(AppliedEffectivityAssignment_<'a>),
    AppliedEventOccurrenceAssignment(AppliedEventOccurrenceAssignment_<'a>),
    AppliedExternalIdentificationAssignment(AppliedExternalIdentificationAssignment_<'a>),
    AppliedGroupAssignment(AppliedGroupAssignment_<'a>),
    AppliedIdentificationAssignment(AppliedIdentificationAssignment_<'a>),
    AppliedIneffectivityAssignment(AppliedIneffectivityAssignment_<'a>),
    AppliedNameAssignment(AppliedNameAssignment_<'a>),
    AppliedOrganizationAssignment(AppliedOrganizationAssignment_<'a>),
    AppliedOrganizationalProjectAssignment(AppliedOrganizationalProjectAssignment_<'a>),
    AppliedPersonAndOrganizationAssignment(AppliedPersonAndOrganizationAssignment_<'a>),
    AppliedPresentedItem(AppliedPresentedItem_<'a>),
    AppliedSecurityClassificationAssignment(AppliedSecurityClassificationAssignment_<'a>),
    AppliedTimeIntervalAssignment(AppliedTimeIntervalAssignment_<'a>),
    Approval(Approval_<'a>),
    ApprovalAssignment(ApprovalAssignment_<'a>),
    ApprovalDateTime(ApprovalDateTime_<'a>),
    ApprovalPersonOrganization(ApprovalPersonOrganization_<'a>),
    ApprovalRelationship(ApprovalRelationship_<'a>),
    ApprovalRole(ApprovalRole_<'a>),
    ApprovalStatus(ApprovalStatus_<'a>),
    ApproximationTolerance(ApproximationTolerance_<'a>),
    ApproximationToleranceDeviation(ApproximationToleranceDeviation_<'a>),
    ApproximationToleranceParameter(ApproximationToleranceParameter_<'a>),
    AreaInSet(AreaInSet_<'a>),
    AreaMeasureWithUnit(AreaMeasureWithUnit_<'a>),
    AreaUnit(AreaUnit_<'a>),
    AsinFunction(AsinFunction_<'a>),
    AssemblyComponentUsage(AssemblyComponentUsage_<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute_<'a>),
    AtanFunction(AtanFunction_<'a>),
    AttributeClassificationAssignment(AttributeClassificationAssignment_<'a>),
    AttributeLanguageAssignment(AttributeLanguageAssignment_<'a>),
    AttributeValueAssignment(AttributeValueAssignment_<'a>),
    AttributeValueRole(AttributeValueRole_<'a>),
    Axis1Placement(Axis1Placement_<'a>),
    Axis2Placement2d(Axis2Placement2d_<'a>),
    Axis2Placement3d(Axis2Placement3d_<'a>),
    BSplineCurve(BSplineCurve_<'a>),
    BSplineCurveWithKnots(BSplineCurveWithKnots_<'a>),
    BSplineSurface(BSplineSurface_<'a>),
    BSplineSurfaceWithKnots(BSplineSurfaceWithKnots_<'a>),
    BackgroundColour(BackgroundColour_<'a>),
    BarringHole(BarringHole_<'a>),
    Bead(Bead_<'a>),
    BeadEnd(BeadEnd_<'a>),
    BezierCurve(BezierCurve_<'a>),
    BezierSurface(BezierSurface_<'a>),
    BinaryBooleanExpression(BinaryBooleanExpression_<'a>),
    BinaryFunctionCall(BinaryFunctionCall_<'a>),
    BinaryGenericExpression(BinaryGenericExpression_<'a>),
    BinaryNumericExpression(BinaryNumericExpression_<'a>),
    Block(Block_<'a>),
    BooleanDefinedFunction(BooleanDefinedFunction_<'a>),
    BooleanExpression(BooleanExpression_<'a>),
    BooleanLiteral(BooleanLiteral_<'a>),
    BooleanResult(BooleanResult_<'a>),
    BooleanVariable(BooleanVariable_<'a>),
    Boss(Boss_<'a>),
    BossTop(BossTop_<'a>),
    BoundaryCurve(BoundaryCurve_<'a>),
    BoundedCurve(BoundedCurve_<'a>),
    BoundedPcurve(BoundedPcurve_<'a>),
    BoundedSurface(BoundedSurface_<'a>),
    BoundedSurfaceCurve(BoundedSurfaceCurve_<'a>),
    BoxDomain(BoxDomain_<'a>),
    BoxedHalfSpace(BoxedHalfSpace_<'a>),
    BrepWithVoids(BrepWithVoids_<'a>),
    CalendarDate(CalendarDate_<'a>),
    CameraImage(CameraImage_<'a>),
    CameraImage2dWithScale(CameraImage2dWithScale_<'a>),
    CameraImage3dWithScale(CameraImage3dWithScale_<'a>),
    CameraModel(CameraModel_<'a>),
    CameraModelD2(CameraModelD2_<'a>),
    CameraModelD3(CameraModelD3_<'a>),
    CameraModelD3WithHlhsr(CameraModelD3WithHlhsr_<'a>),
    CameraUsage(CameraUsage_<'a>),
    CartesianPoint(CartesianPoint_<'a>),
    CartesianTransformationOperator(CartesianTransformationOperator_<'a>),
    CartesianTransformationOperator2d(CartesianTransformationOperator2d_<'a>),
    CartesianTransformationOperator3d(CartesianTransformationOperator3d_<'a>),
    CelsiusTemperatureMeasureWithUnit(CelsiusTemperatureMeasureWithUnit_<'a>),
    CentreOfSymmetry(CentreOfSymmetry_<'a>),
    Certification(Certification_<'a>),
    CertificationAssignment(CertificationAssignment_<'a>),
    CertificationType(CertificationType_<'a>),
    Chamfer(Chamfer_<'a>),
    ChamferOffset(ChamferOffset_<'a>),
    CharacterGlyphSymbol(CharacterGlyphSymbol_<'a>),
    CharacterizedClass(CharacterizedClass_<'a>),
    CharacterizedObject(CharacterizedObject_<'a>),
    Circle(Circle_<'a>),
    CircularClosedProfile(CircularClosedProfile_<'a>),
    CircularPattern(CircularPattern_<'a>),
    CircularRunoutTolerance(CircularRunoutTolerance_<'a>),
    Class(Class_<'a>),
    ClassSystem(ClassSystem_<'a>),
    ClassUsageEffectivityContextAssignment(ClassUsageEffectivityContextAssignment_<'a>),
    ClassificationAssignment(ClassificationAssignment_<'a>),
    ClassificationRole(ClassificationRole_<'a>),
    ClosedPathProfile(ClosedPathProfile_<'a>),
    ClosedShell(ClosedShell_<'a>),
    CoaxialityTolerance(CoaxialityTolerance_<'a>),
    Colour(Colour_<'a>),
    ColourRgb(ColourRgb_<'a>),
    ColourSpecification(ColourSpecification_<'a>),
    CommonDatum(CommonDatum_<'a>),
    ComparisonEqual(ComparisonEqual_<'a>),
    ComparisonExpression(ComparisonExpression_<'a>),
    ComparisonGreater(ComparisonGreater_<'a>),
    ComparisonGreaterEqual(ComparisonGreaterEqual_<'a>),
    ComparisonLess(ComparisonLess_<'a>),
    ComparisonLessEqual(ComparisonLessEqual_<'a>),
    ComparisonNotEqual(ComparisonNotEqual_<'a>),
    CompositeCurve(CompositeCurve_<'a>),
    CompositeCurveOnSurface(CompositeCurveOnSurface_<'a>),
    CompositeCurveSegment(CompositeCurveSegment_<'a>),
    CompositeHole(CompositeHole_<'a>),
    CompositeShapeAspect(CompositeShapeAspect_<'a>),
    CompositeText(CompositeText_<'a>),
    CompositeTextWithAssociatedCurves(CompositeTextWithAssociatedCurves_<'a>),
    CompositeTextWithBlankingBox(CompositeTextWithBlankingBox_<'a>),
    CompositeTextWithExtent(CompositeTextWithExtent_<'a>),
    CompoundFeature(CompoundFeature_<'a>),
    CompoundRepresentationItem(CompoundRepresentationItem_<'a>),
    CompoundShapeRepresentation(CompoundShapeRepresentation_<'a>),
    ConcatExpression(ConcatExpression_<'a>),
    ConcentricityTolerance(ConcentricityTolerance_<'a>),
    ConceptFeatureOperator(ConceptFeatureOperator_<'a>),
    ConceptFeatureRelationship(ConceptFeatureRelationship_<'a>),
    ConceptFeatureRelationshipWithCondition(ConceptFeatureRelationshipWithCondition_<'a>),
    ConditionalConceptFeature(ConditionalConceptFeature_<'a>),
    ConfigurableItem(ConfigurableItem_<'a>),
    ConfigurationDefinition(ConfigurationDefinition_<'a>),
    ConfigurationDesign(ConfigurationDesign_<'a>),
    ConfigurationEffectivity(ConfigurationEffectivity_<'a>),
    ConfigurationInterpolation(ConfigurationInterpolation_<'a>),
    ConfigurationItem(ConfigurationItem_<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment_<'a>),
    ConfiguredEffectivityContextAssignment(ConfiguredEffectivityContextAssignment_<'a>),
    Conic(Conic_<'a>),
    ConicalSurface(ConicalSurface_<'a>),
    ConnectedEdgeSet(ConnectedEdgeSet_<'a>),
    ConnectedFaceSet(ConnectedFaceSet_<'a>),
    ConnectedFaceSubSet(ConnectedFaceSubSet_<'a>),
    ConstructiveGeometryRepresentation(ConstructiveGeometryRepresentation_<'a>),
    ConstructiveGeometryRepresentationRelationship(ConstructiveGeometryRepresentationRelationship_<'a>),
    ContactRatioRepresentation(ContactRatioRepresentation_<'a>),
    ContextDependentInvisibility(ContextDependentInvisibility_<'a>),
    ContextDependentOverRidingStyledItem(ContextDependentOverRidingStyledItem_<'a>),
    ContextDependentShapeRepresentation(ContextDependentShapeRepresentation_<'a>),
    ContextDependentUnit(ContextDependentUnit_<'a>),
    Contract(Contract_<'a>),
    ContractAssignment(ContractAssignment_<'a>),
    ContractType(ContractType_<'a>),
    ConversionBasedUnit(ConversionBasedUnit_<'a>),
    CoordinatedUniversalTimeOffset(CoordinatedUniversalTimeOffset_<'a>),
    CosFunction(CosFunction_<'a>),
    CsgShapeRepresentation(CsgShapeRepresentation_<'a>),
    CsgSolid(CsgSolid_<'a>),
    Curve(Curve_<'a>),
    CurveBoundedSurface(CurveBoundedSurface_<'a>),
    CurveDimension(CurveDimension_<'a>),
    CurveReplica(CurveReplica_<'a>),
    CurveStyle(CurveStyle_<'a>),
    CurveStyleFont(CurveStyleFont_<'a>),
    CurveStyleFontPattern(CurveStyleFontPattern_<'a>),
    CurveStyleRendering(CurveStyleRendering_<'a>),
    CurveSweptSolidShapeRepresentation(CurveSweptSolidShapeRepresentation_<'a>),
    CylindricalPair(CylindricalPair_<'a>),
    CylindricalPairRange(CylindricalPairRange_<'a>),
    CylindricalPairValue(CylindricalPairValue_<'a>),
    CylindricalSurface(CylindricalSurface_<'a>),
    CylindricityTolerance(CylindricityTolerance_<'a>),
    DataEnvironment(DataEnvironment_<'a>),
    Date(Date_<'a>),
    DateAndTime(DateAndTime_<'a>),
    DateAndTimeAssignment(DateAndTimeAssignment_<'a>),
    DateAssignment(DateAssignment_<'a>),
    DateRole(DateRole_<'a>),
    DateTimeRole(DateTimeRole_<'a>),
    DatedEffectivity(DatedEffectivity_<'a>),
    Datum(Datum_<'a>),
    DatumFeature(DatumFeature_<'a>),
    DatumFeatureCallout(DatumFeatureCallout_<'a>),
    DatumReference(DatumReference_<'a>),
    DatumTarget(DatumTarget_<'a>),
    DatumTargetCallout(DatumTargetCallout_<'a>),
    DefaultToleranceTable(DefaultToleranceTable_<'a>),
    DefaultToleranceTableCell(DefaultToleranceTableCell_<'a>),
    DefinedCharacterGlyph(DefinedCharacterGlyph_<'a>),
    DefinedFunction(DefinedFunction_<'a>),
    DefinedSymbol(DefinedSymbol_<'a>),
    DefinitionalRepresentation(DefinitionalRepresentation_<'a>),
    DegeneratePcurve(DegeneratePcurve_<'a>),
    DegenerateToroidalSurface(DegenerateToroidalSurface_<'a>),
    DerivedShapeAspect(DerivedShapeAspect_<'a>),
    DerivedUnit(DerivedUnit_<'a>),
    DerivedUnitElement(DerivedUnitElement_<'a>),
    DerivedUnitVariable(DerivedUnitVariable_<'a>),
    DescriptionAttribute(DescriptionAttribute_<'a>),
    DescriptiveRepresentationItem(DescriptiveRepresentationItem_<'a>),
    DiameterDimension(DiameterDimension_<'a>),
    DimensionCallout(DimensionCallout_<'a>),
    DimensionCalloutComponentRelationship(DimensionCalloutComponentRelationship_<'a>),
    DimensionCalloutRelationship(DimensionCalloutRelationship_<'a>),
    DimensionCurve(DimensionCurve_<'a>),
    DimensionCurveDirectedCallout(DimensionCurveDirectedCallout_<'a>),
    DimensionCurveTerminator(DimensionCurveTerminator_<'a>),
    DimensionPair(DimensionPair_<'a>),
    DimensionRelatedToleranceZoneElement(DimensionRelatedToleranceZoneElement_<'a>),
    DimensionTextAssociativity(DimensionTextAssociativity_<'a>),
    DimensionalCharacteristicRepresentation(DimensionalCharacteristicRepresentation_<'a>),
    DimensionalExponents(DimensionalExponents_<'a>),
    DimensionalLocation(DimensionalLocation_<'a>),
    DimensionalLocationWithPath(DimensionalLocationWithPath_<'a>),
    DimensionalSize(DimensionalSize_<'a>),
    DimensionalSizeWithPath(DimensionalSizeWithPath_<'a>),
    DirectedAction(DirectedAction_<'a>),
    DirectedAngle(DirectedAngle_<'a>),
    DirectedDimensionalLocation(DirectedDimensionalLocation_<'a>),
    Direction(Direction_<'a>),
    DirectionShapeRepresentation(DirectionShapeRepresentation_<'a>),
    DivExpression(DivExpression_<'a>),
    Document(Document_<'a>),
    DocumentFile(DocumentFile_<'a>),
    DocumentProductAssociation(DocumentProductAssociation_<'a>),
    DocumentProductEquivalence(DocumentProductEquivalence_<'a>),
    DocumentReference(DocumentReference_<'a>),
    DocumentRelationship(DocumentRelationship_<'a>),
    DocumentRepresentationType(DocumentRepresentationType_<'a>),
    DocumentType(DocumentType_<'a>),
    DocumentUsageConstraint(DocumentUsageConstraint_<'a>),
    DocumentUsageConstraintAssignment(DocumentUsageConstraintAssignment_<'a>),
    DocumentUsageRole(DocumentUsageRole_<'a>),
    DraughtingAnnotationOccurrence(DraughtingAnnotationOccurrence_<'a>),
    DraughtingCallout(DraughtingCallout_<'a>),
    DraughtingCalloutRelationship(DraughtingCalloutRelationship_<'a>),
    DraughtingElements(DraughtingElements_<'a>),
    DraughtingModel(DraughtingModel_<'a>),
    DraughtingModelItemAssociation(DraughtingModelItemAssociation_<'a>),
    DraughtingPreDefinedColour(DraughtingPreDefinedColour_<'a>),
    DraughtingPreDefinedCurveFont(DraughtingPreDefinedCurveFont_<'a>),
    DraughtingPreDefinedTextFont(DraughtingPreDefinedTextFont_<'a>),
    DraughtingSpecificationReference(DraughtingSpecificationReference_<'a>),
    DraughtingSubfigureRepresentation(DraughtingSubfigureRepresentation_<'a>),
    DraughtingSymbolRepresentation(DraughtingSymbolRepresentation_<'a>),
    DraughtingTextLiteralWithDelineation(DraughtingTextLiteralWithDelineation_<'a>),
    DraughtingTitle(DraughtingTitle_<'a>),
    DrawingDefinition(DrawingDefinition_<'a>),
    DrawingRevision(DrawingRevision_<'a>),
    DrawingRevisionSequence(DrawingRevisionSequence_<'a>),
    DrawingSheetLayout(DrawingSheetLayout_<'a>),
    DrawingSheetRevision(DrawingSheetRevision_<'a>),
    DrawingSheetRevisionUsage(DrawingSheetRevisionUsage_<'a>),
    Edge(Edge_<'a>),
    EdgeBasedWireframeModel(EdgeBasedWireframeModel_<'a>),
    EdgeBasedWireframeShapeRepresentation(EdgeBasedWireframeShapeRepresentation_<'a>),
    EdgeCurve(EdgeCurve_<'a>),
    EdgeLoop(EdgeLoop_<'a>),
    EdgeRound(EdgeRound_<'a>),
    Effectivity(Effectivity_<'a>),
    EffectivityAssignment(EffectivityAssignment_<'a>),
    EffectivityContextAssignment(EffectivityContextAssignment_<'a>),
    EffectivityContextRole(EffectivityContextRole_<'a>),
    EffectivityRelationship(EffectivityRelationship_<'a>),
    ElectricCurrentMeasureWithUnit(ElectricCurrentMeasureWithUnit_<'a>),
    ElectricCurrentUnit(ElectricCurrentUnit_<'a>),
    ElementDelivery(ElementDelivery_<'a>),
    ElementarySurface(ElementarySurface_<'a>),
    Ellipse(Ellipse_<'a>),
    Environment(Environment_<'a>),
    EqualsExpression(EqualsExpression_<'a>),
    EvaluatedDegeneratePcurve(EvaluatedDegeneratePcurve_<'a>),
    EventOccurrence(EventOccurrence_<'a>),
    EventOccurrenceAssignment(EventOccurrenceAssignment_<'a>),
    EventOccurrenceContextAssignment(EventOccurrenceContextAssignment_<'a>),
    EventOccurrenceContextRole(EventOccurrenceContextRole_<'a>),
    EventOccurrenceRole(EventOccurrenceRole_<'a>),
    ExclusiveProductConceptFeatureCategory(ExclusiveProductConceptFeatureCategory_<'a>),
    ExecutedAction(ExecutedAction_<'a>),
    ExpFunction(ExpFunction_<'a>),
    Expression(Expression_<'a>),
    ExpressionConversionBasedUnit(ExpressionConversionBasedUnit_<'a>),
    Extension(Extension_<'a>),
    ExternalIdentificationAssignment(ExternalIdentificationAssignment_<'a>),
    ExternalSource(ExternalSource_<'a>),
    ExternallyDefinedCharacterGlyph(ExternallyDefinedCharacterGlyph_<'a>),
    ExternallyDefinedClass(ExternallyDefinedClass_<'a>),
    ExternallyDefinedCurveFont(ExternallyDefinedCurveFont_<'a>),
    ExternallyDefinedDimensionDefinition(ExternallyDefinedDimensionDefinition_<'a>),
    ExternallyDefinedFeatureDefinition(ExternallyDefinedFeatureDefinition_<'a>),
    ExternallyDefinedGeneralProperty(ExternallyDefinedGeneralProperty_<'a>),
    ExternallyDefinedHatchStyle(ExternallyDefinedHatchStyle_<'a>),
    ExternallyDefinedItem(ExternallyDefinedItem_<'a>),
    ExternallyDefinedItemRelationship(ExternallyDefinedItemRelationship_<'a>),
    ExternallyDefinedStyle(ExternallyDefinedStyle_<'a>),
    ExternallyDefinedSymbol(ExternallyDefinedSymbol_<'a>),
    ExternallyDefinedTextFont(ExternallyDefinedTextFont_<'a>),
    ExternallyDefinedTileStyle(ExternallyDefinedTileStyle_<'a>),
    ExtrudedAreaSolid(ExtrudedAreaSolid_<'a>),
    ExtrudedFaceSolid(ExtrudedFaceSolid_<'a>),
    Face(Face_<'a>),
    FaceBasedSurfaceModel(FaceBasedSurfaceModel_<'a>),
    FaceBound(FaceBound_<'a>),
    FaceOuterBound(FaceOuterBound_<'a>),
    FaceShapeRepresentation(FaceShapeRepresentation_<'a>),
    FaceSurface(FaceSurface_<'a>),
    FacetedBrep(FacetedBrep_<'a>),
    FacetedBrepShapeRepresentation(FacetedBrepShapeRepresentation_<'a>),
    FeatureComponentDefinition(FeatureComponentDefinition_<'a>),
    FeatureComponentRelationship(FeatureComponentRelationship_<'a>),
    FeatureDefinition(FeatureDefinition_<'a>),
    FeatureInPanel(FeatureInPanel_<'a>),
    FeaturePattern(FeaturePattern_<'a>),
    FeaturedShape(FeaturedShape_<'a>),
    FillAreaStyle(FillAreaStyle_<'a>),
    FillAreaStyleColour(FillAreaStyleColour_<'a>),
    FillAreaStyleHatching(FillAreaStyleHatching_<'a>),
    FillAreaStyleTileSymbolWithStyle(FillAreaStyleTileSymbolWithStyle_<'a>),
    FillAreaStyleTiles(FillAreaStyleTiles_<'a>),
    Fillet(Fillet_<'a>),
    FlatnessTolerance(FlatnessTolerance_<'a>),
    FormatFunction(FormatFunction_<'a>),
    FoundedItem(FoundedItem_<'a>),
    FoundedKinematicPath(FoundedKinematicPath_<'a>),
    FullyConstrainedPair(FullyConstrainedPair_<'a>),
    FunctionallyDefinedTransformation(FunctionallyDefinedTransformation_<'a>),
    GearPair(GearPair_<'a>),
    GearPairRange(GearPairRange_<'a>),
    GearPairValue(GearPairValue_<'a>),
    GeneralFeature(GeneralFeature_<'a>),
    GeneralMaterialProperty(GeneralMaterialProperty_<'a>),
    GeneralProperty(GeneralProperty_<'a>),
    GeneralPropertyAssociation(GeneralPropertyAssociation_<'a>),
    GeneralPropertyRelationship(GeneralPropertyRelationship_<'a>),
    GenericCharacterGlyphSymbol(GenericCharacterGlyphSymbol_<'a>),
    GenericExpression(GenericExpression_<'a>),
    GenericLiteral(GenericLiteral_<'a>),
    GenericVariable(GenericVariable_<'a>),
    GeometricAlignment(GeometricAlignment_<'a>),
    GeometricCurveSet(GeometricCurveSet_<'a>),
    GeometricIntersection(GeometricIntersection_<'a>),
    GeometricItemSpecificUsage(GeometricItemSpecificUsage_<'a>),
    GeometricRepresentationContext(GeometricRepresentationContext_<'a>),
    GeometricRepresentationItem(GeometricRepresentationItem_<'a>),
    GeometricSet(GeometricSet_<'a>),
    GeometricTolerance(GeometricTolerance_<'a>),
    GeometricToleranceRelationship(GeometricToleranceRelationship_<'a>),
    GeometricToleranceWithDatumReference(GeometricToleranceWithDatumReference_<'a>),
    GeometricToleranceWithDefinedUnit(GeometricToleranceWithDefinedUnit_<'a>),
    GeometricalToleranceCallout(GeometricalToleranceCallout_<'a>),
    GeometricallyBounded2dWireframeRepresentation(GeometricallyBounded2dWireframeRepresentation_<'a>),
    GeometricallyBoundedSurfaceShapeRepresentation(GeometricallyBoundedSurfaceShapeRepresentation_<'a>),
    GeometricallyBoundedWireframeShapeRepresentation(GeometricallyBoundedWireframeShapeRepresentation_<'a>),
    GlobalUncertaintyAssignedContext(GlobalUncertaintyAssignedContext_<'a>),
    GlobalUnitAssignedContext(GlobalUnitAssignedContext_<'a>),
    Group(Group_<'a>),
    GroupAssignment(GroupAssignment_<'a>),
    GroupRelationship(GroupRelationship_<'a>),
    HalfSpaceSolid(HalfSpaceSolid_<'a>),
    HardnessRepresentation(HardnessRepresentation_<'a>),
    HiddenElementOverRidingStyledItem(HiddenElementOverRidingStyledItem_<'a>),
    HoleBottom(HoleBottom_<'a>),
    HoleInPanel(HoleInPanel_<'a>),
    HomokineticPair(HomokineticPair_<'a>),
    Hyperbola(Hyperbola_<'a>),
    IdAttribute(IdAttribute_<'a>),
    IdentificationAssignment(IdentificationAssignment_<'a>),
    IdentificationRole(IdentificationRole_<'a>),
    InclusionProductConceptFeature(InclusionProductConceptFeature_<'a>),
    IndexExpression(IndexExpression_<'a>),
    InitialState(InitialState_<'a>),
    InstancedFeature(InstancedFeature_<'a>),
    IntLiteral(IntLiteral_<'a>),
    IntNumericVariable(IntNumericVariable_<'a>),
    IntValueFunction(IntValueFunction_<'a>),
    IntegerDefinedFunction(IntegerDefinedFunction_<'a>),
    InterpolatedConfigurationSequence(InterpolatedConfigurationSequence_<'a>),
    IntersectionCurve(IntersectionCurve_<'a>),
    IntervalExpression(IntervalExpression_<'a>),
    Invisibility(Invisibility_<'a>),
    ItemDefinedTransformation(ItemDefinedTransformation_<'a>),
    ItemIdentifiedRepresentationUsage(ItemIdentifiedRepresentationUsage_<'a>),
    Joggle(Joggle_<'a>),
    JoggleTermination(JoggleTermination_<'a>),
    KinematicAnalysisConsistency(KinematicAnalysisConsistency_<'a>),
    KinematicAnalysisResult(KinematicAnalysisResult_<'a>),
    KinematicControl(KinematicControl_<'a>),
    KinematicFrameBackgroundRepresentation(KinematicFrameBackgroundRepresentation_<'a>),
    KinematicFrameBackgroundRepresentationAssociation(KinematicFrameBackgroundRepresentationAssociation_<'a>),
    KinematicFrameBasedTransformation(KinematicFrameBasedTransformation_<'a>),
    KinematicGroundRepresentation(KinematicGroundRepresentation_<'a>),
    KinematicJoint(KinematicJoint_<'a>),
    KinematicLink(KinematicLink_<'a>),
    KinematicLinkRepresentation(KinematicLinkRepresentation_<'a>),
    KinematicLinkRepresentationAssociation(KinematicLinkRepresentationAssociation_<'a>),
    KinematicLinkRepresentationRelation(KinematicLinkRepresentationRelation_<'a>),
    KinematicPair(KinematicPair_<'a>),
    KinematicPath(KinematicPath_<'a>),
    KinematicPropertyDefinition(KinematicPropertyDefinition_<'a>),
    KinematicPropertyRepresentationRelation(KinematicPropertyRepresentationRelation_<'a>),
    KinematicStructure(KinematicStructure_<'a>),
    KnownSource(KnownSource_<'a>),
    Language(Language_<'a>),
    LanguageAssignment(LanguageAssignment_<'a>),
    LeaderCurve(LeaderCurve_<'a>),
    LeaderDirectedCallout(LeaderDirectedCallout_<'a>),
    LeaderDirectedDimension(LeaderDirectedDimension_<'a>),
    LeaderTerminator(LeaderTerminator_<'a>),
    LengthFunction(LengthFunction_<'a>),
    LengthMeasureWithUnit(LengthMeasureWithUnit_<'a>),
    LengthUnit(LengthUnit_<'a>),
    LightSource(LightSource_<'a>),
    LightSourceAmbient(LightSourceAmbient_<'a>),
    LightSourceDirectional(LightSourceDirectional_<'a>),
    LightSourcePositional(LightSourcePositional_<'a>),
    LightSourceSpot(LightSourceSpot_<'a>),
    LikeExpression(LikeExpression_<'a>),
    LimitsAndFits(LimitsAndFits_<'a>),
    Line(Line_<'a>),
    LineProfileTolerance(LineProfileTolerance_<'a>),
    LinearDimension(LinearDimension_<'a>),
    LiteralNumber(LiteralNumber_<'a>),
    LocalTime(LocalTime_<'a>),
    LocationShapeRepresentation(LocationShapeRepresentation_<'a>),
    Locator(Locator_<'a>),
    Log10Function(Log10Function_<'a>),
    Log2Function(Log2Function_<'a>),
    LogFunction(LogFunction_<'a>),
    Loop(Loop_<'a>),
    LotEffectivity(LotEffectivity_<'a>),
    LuminousIntensityMeasureWithUnit(LuminousIntensityMeasureWithUnit_<'a>),
    LuminousIntensityUnit(LuminousIntensityUnit_<'a>),
    MakeFromUsageOption(MakeFromUsageOption_<'a>),
    ManifoldSolidBrep(ManifoldSolidBrep_<'a>),
    ManifoldSubsurfaceShapeRepresentation(ManifoldSubsurfaceShapeRepresentation_<'a>),
    ManifoldSurfaceShapeRepresentation(ManifoldSurfaceShapeRepresentation_<'a>),
    MappedItem(MappedItem_<'a>),
    MassMeasureWithUnit(MassMeasureWithUnit_<'a>),
    MassUnit(MassUnit_<'a>),
    MaterialDesignation(MaterialDesignation_<'a>),
    MaterialDesignationCharacterization(MaterialDesignationCharacterization_<'a>),
    MaterialProperty(MaterialProperty_<'a>),
    MaterialPropertyRepresentation(MaterialPropertyRepresentation_<'a>),
    MaximumFunction(MaximumFunction_<'a>),
    MeasureQualification(MeasureQualification_<'a>),
    MeasureRepresentationItem(MeasureRepresentationItem_<'a>),
    MeasureWithUnit(MeasureWithUnit_<'a>),
    MechanicalDesignGeometricPresentationArea(MechanicalDesignGeometricPresentationArea_<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation_<'a>),
    Mechanism(Mechanism_<'a>),
    MechanismBasePlacement(MechanismBasePlacement_<'a>),
    MinimumFunction(MinimumFunction_<'a>),
    MinusExpression(MinusExpression_<'a>),
    MinusFunction(MinusFunction_<'a>),
    ModExpression(ModExpression_<'a>),
    ModifiedGeometricTolerance(ModifiedGeometricTolerance_<'a>),
    ModifiedPattern(ModifiedPattern_<'a>),
    MomentsOfInertiaRepresentation(MomentsOfInertiaRepresentation_<'a>),
    MotionLinkRelationship(MotionLinkRelationship_<'a>),
    MultExpression(MultExpression_<'a>),
    MultiLanguageAttributeAssignment(MultiLanguageAttributeAssignment_<'a>),
    MultipleArityBooleanExpression(MultipleArityBooleanExpression_<'a>),
    MultipleArityFunctionCall(MultipleArityFunctionCall_<'a>),
    MultipleArityGenericExpression(MultipleArityGenericExpression_<'a>),
    MultipleArityNumericExpression(MultipleArityNumericExpression_<'a>),
    NameAssignment(NameAssignment_<'a>),
    NameAttribute(NameAttribute_<'a>),
    NamedUnit(NamedUnit_<'a>),
    NamedUnitVariable(NamedUnitVariable_<'a>),
    NextAssemblyUsageOccurrence(NextAssemblyUsageOccurrence_<'a>),
    NgonClosedProfile(NgonClosedProfile_<'a>),
    NonManifoldSurfaceShapeRepresentation(NonManifoldSurfaceShapeRepresentation_<'a>),
    NotExpression(NotExpression_<'a>),
    NumericDefinedFunction(NumericDefinedFunction_<'a>),
    NumericExpression(NumericExpression_<'a>),
    NumericVariable(NumericVariable_<'a>),
    ObjectRole(ObjectRole_<'a>),
    OddFunction(OddFunction_<'a>),
    OffsetCurve2d(OffsetCurve2d_<'a>),
    OffsetCurve3d(OffsetCurve3d_<'a>),
    OffsetSurface(OffsetSurface_<'a>),
    OneDirectionRepeatFactor(OneDirectionRepeatFactor_<'a>),
    OpenPathProfile(OpenPathProfile_<'a>),
    OpenShell(OpenShell_<'a>),
    OrExpression(OrExpression_<'a>),
    OrdinateDimension(OrdinateDimension_<'a>),
    Organization(Organization_<'a>),
    OrganizationAssignment(OrganizationAssignment_<'a>),
    OrganizationRelationship(OrganizationRelationship_<'a>),
    OrganizationRole(OrganizationRole_<'a>),
    OrganizationalAddress(OrganizationalAddress_<'a>),
    OrganizationalProject(OrganizationalProject_<'a>),
    OrganizationalProjectAssignment(OrganizationalProjectAssignment_<'a>),
    OrganizationalProjectRelationship(OrganizationalProjectRelationship_<'a>),
    OrganizationalProjectRole(OrganizationalProjectRole_<'a>),
    OrientedClosedShell(OrientedClosedShell_<'a>),
    OrientedEdge(OrientedEdge_<'a>),
    OrientedFace(OrientedFace_<'a>),
    OrientedOpenShell(OrientedOpenShell_<'a>),
    OrientedPath(OrientedPath_<'a>),
    OrientedSurface(OrientedSurface_<'a>),
    OuterBoundaryCurve(OuterBoundaryCurve_<'a>),
    OverRidingStyledItem(OverRidingStyledItem_<'a>),
    PackageProductConceptFeature(PackageProductConceptFeature_<'a>),
    PairActuator(PairActuator_<'a>),
    PairValue(PairValue_<'a>),
    Parabola(Parabola_<'a>),
    ParallelOffset(ParallelOffset_<'a>),
    ParallelismTolerance(ParallelismTolerance_<'a>),
    ParametricRepresentationContext(ParametricRepresentationContext_<'a>),
    PartialCircularProfile(PartialCircularProfile_<'a>),
    Path(Path_<'a>),
    PathFeatureComponent(PathFeatureComponent_<'a>),
    PathShapeRepresentation(PathShapeRepresentation_<'a>),
    PatternOffsetMembership(PatternOffsetMembership_<'a>),
    PatternOmitMembership(PatternOmitMembership_<'a>),
    Pcurve(Pcurve_<'a>),
    PerpendicularTo(PerpendicularTo_<'a>),
    PerpendicularityTolerance(PerpendicularityTolerance_<'a>),
    Person(Person_<'a>),
    PersonAndOrganization(PersonAndOrganization_<'a>),
    PersonAndOrganizationAddress(PersonAndOrganizationAddress_<'a>),
    PersonAndOrganizationAssignment(PersonAndOrganizationAssignment_<'a>),
    PersonAndOrganizationRole(PersonAndOrganizationRole_<'a>),
    PersonalAddress(PersonalAddress_<'a>),
    PhysicallyModelledProductDefinition(PhysicallyModelledProductDefinition_<'a>),
    PlacedDatumTargetFeature(PlacedDatumTargetFeature_<'a>),
    PlacedFeature(PlacedFeature_<'a>),
    Placement(Placement_<'a>),
    PlanarBox(PlanarBox_<'a>),
    PlanarCurvePair(PlanarCurvePair_<'a>),
    PlanarCurvePairRange(PlanarCurvePairRange_<'a>),
    PlanarExtent(PlanarExtent_<'a>),
    PlanarPair(PlanarPair_<'a>),
    PlanarPairRange(PlanarPairRange_<'a>),
    PlanarPairValue(PlanarPairValue_<'a>),
    PlanarShapeRepresentation(PlanarShapeRepresentation_<'a>),
    Plane(Plane_<'a>),
    PlaneAngleMeasureWithUnit(PlaneAngleMeasureWithUnit_<'a>),
    PlaneAngleUnit(PlaneAngleUnit_<'a>),
    PlusExpression(PlusExpression_<'a>),
    PlusMinusTolerance(PlusMinusTolerance_<'a>),
    Pocket(Pocket_<'a>),
    PocketBottom(PocketBottom_<'a>),
    Point(Point_<'a>),
    PointOnCurve(PointOnCurve_<'a>),
    PointOnPlanarCurvePair(PointOnPlanarCurvePair_<'a>),
    PointOnPlanarCurvePairRange(PointOnPlanarCurvePairRange_<'a>),
    PointOnPlanarCurvePairValue(PointOnPlanarCurvePairValue_<'a>),
    PointOnSurface(PointOnSurface_<'a>),
    PointOnSurfacePair(PointOnSurfacePair_<'a>),
    PointOnSurfacePairRange(PointOnSurfacePairRange_<'a>),
    PointOnSurfacePairValue(PointOnSurfacePairValue_<'a>),
    PointPlacementShapeRepresentation(PointPlacementShapeRepresentation_<'a>),
    PointReplica(PointReplica_<'a>),
    PointStyle(PointStyle_<'a>),
    PolyLoop(PolyLoop_<'a>),
    Polyline(Polyline_<'a>),
    PositionTolerance(PositionTolerance_<'a>),
    PowerExpression(PowerExpression_<'a>),
    PreDefinedColour(PreDefinedColour_<'a>),
    PreDefinedCurveFont(PreDefinedCurveFont_<'a>),
    PreDefinedDimensionSymbol(PreDefinedDimensionSymbol_<'a>),
    PreDefinedGeometricalToleranceSymbol(PreDefinedGeometricalToleranceSymbol_<'a>),
    PreDefinedItem(PreDefinedItem_<'a>),
    PreDefinedMarker(PreDefinedMarker_<'a>),
    PreDefinedPointMarkerSymbol(PreDefinedPointMarkerSymbol_<'a>),
    PreDefinedPresentationStyle(PreDefinedPresentationStyle_<'a>),
    PreDefinedSurfaceConditionSymbol(PreDefinedSurfaceConditionSymbol_<'a>),
    PreDefinedSymbol(PreDefinedSymbol_<'a>),
    PreDefinedTerminatorSymbol(PreDefinedTerminatorSymbol_<'a>),
    PreDefinedTextFont(PreDefinedTextFont_<'a>),
    PrecisionQualifier(PrecisionQualifier_<'a>),
    PresentationArea(PresentationArea_<'a>),
    PresentationLayerAssignment(PresentationLayerAssignment_<'a>),
    PresentationRepresentation(PresentationRepresentation_<'a>),
    PresentationSet(PresentationSet_<'a>),
    PresentationSize(PresentationSize_<'a>),
    PresentationStyleAssignment(PresentationStyleAssignment_<'a>),
    PresentationStyleByContext(PresentationStyleByContext_<'a>),
    PresentationView(PresentationView_<'a>),
    PresentedItem(PresentedItem_<'a>),
    PresentedItemRepresentation(PresentedItemRepresentation_<'a>),
    PrismaticPair(PrismaticPair_<'a>),
    PrismaticPairRange(PrismaticPairRange_<'a>),
    PrismaticPairValue(PrismaticPairValue_<'a>),
    ProcessOperation(ProcessOperation_<'a>),
    ProcessPlan(ProcessPlan_<'a>),
    ProcessProductAssociation(ProcessProductAssociation_<'a>),
    ProcessPropertyAssociation(ProcessPropertyAssociation_<'a>),
    Product(Product_<'a>),
    ProductCategory(ProductCategory_<'a>),
    ProductCategoryRelationship(ProductCategoryRelationship_<'a>),
    ProductClass(ProductClass_<'a>),
    ProductConcept(ProductConcept_<'a>),
    ProductConceptContext(ProductConceptContext_<'a>),
    ProductConceptFeature(ProductConceptFeature_<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation_<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory_<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage_<'a>),
    ProductConceptRelationship(ProductConceptRelationship_<'a>),
    ProductContext(ProductContext_<'a>),
    ProductDefinition(ProductDefinition_<'a>),
    ProductDefinitionContext(ProductDefinitionContext_<'a>),
    ProductDefinitionContextAssociation(ProductDefinitionContextAssociation_<'a>),
    ProductDefinitionContextRole(ProductDefinitionContextRole_<'a>),
    ProductDefinitionEffectivity(ProductDefinitionEffectivity_<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation_<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship_<'a>),
    ProductDefinitionFormationWithSpecifiedSource(ProductDefinitionFormationWithSpecifiedSource_<'a>),
    ProductDefinitionOccurrenceRelationship(ProductDefinitionOccurrenceRelationship_<'a>),
    ProductDefinitionProcess(ProductDefinitionProcess_<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship_<'a>),
    ProductDefinitionResource(ProductDefinitionResource_<'a>),
    ProductDefinitionShape(ProductDefinitionShape_<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute_<'a>),
    ProductDefinitionUsage(ProductDefinitionUsage_<'a>),
    ProductDefinitionWithAssociatedDocuments(ProductDefinitionWithAssociatedDocuments_<'a>),
    ProductIdentification(ProductIdentification_<'a>),
    ProductProcessPlan(ProductProcessPlan_<'a>),
    ProductRelatedProductCategory(ProductRelatedProductCategory_<'a>),
    ProductSpecification(ProductSpecification_<'a>),
    ProjectedZoneDefinition(ProjectedZoneDefinition_<'a>),
    ProjectionCurve(ProjectionCurve_<'a>),
    ProjectionDirectedCallout(ProjectionDirectedCallout_<'a>),
    PromissoryUsageOccurrence(PromissoryUsageOccurrence_<'a>),
    PropertyDefinition(PropertyDefinition_<'a>),
    PropertyDefinitionRelationship(PropertyDefinitionRelationship_<'a>),
    PropertyDefinitionRepresentation(PropertyDefinitionRepresentation_<'a>),
    PropertyProcess(PropertyProcess_<'a>),
    QualifiedRepresentationItem(QualifiedRepresentationItem_<'a>),
    QualitativeUncertainty(QualitativeUncertainty_<'a>),
    QuantifiedAssemblyComponentUsage(QuantifiedAssemblyComponentUsage_<'a>),
    QuasiUniformCurve(QuasiUniformCurve_<'a>),
    QuasiUniformSurface(QuasiUniformSurface_<'a>),
    RackAndPinionPair(RackAndPinionPair_<'a>),
    RackAndPinionPairRange(RackAndPinionPairRange_<'a>),
    RackAndPinionPairValue(RackAndPinionPairValue_<'a>),
    RadiusDimension(RadiusDimension_<'a>),
    RatioMeasureWithUnit(RatioMeasureWithUnit_<'a>),
    RatioUnit(RatioUnit_<'a>),
    RationalBSplineCurve(RationalBSplineCurve_<'a>),
    RationalBSplineSurface(RationalBSplineSurface_<'a>),
    RealDefinedFunction(RealDefinedFunction_<'a>),
    RealLiteral(RealLiteral_<'a>),
    RealNumericVariable(RealNumericVariable_<'a>),
    RectangularClosedProfile(RectangularClosedProfile_<'a>),
    RectangularCompositeSurface(RectangularCompositeSurface_<'a>),
    RectangularPattern(RectangularPattern_<'a>),
    RectangularTrimmedSurface(RectangularTrimmedSurface_<'a>),
    ReferencedModifiedDatum(ReferencedModifiedDatum_<'a>),
    RelativeEventOccurrence(RelativeEventOccurrence_<'a>),
    RepItemGroup(RepItemGroup_<'a>),
    ReparametrisedCompositeCurveSegment(ReparametrisedCompositeCurveSegment_<'a>),
    ReplicateFeature(ReplicateFeature_<'a>),
    Representation(Representation_<'a>),
    RepresentationContext(RepresentationContext_<'a>),
    RepresentationItem(RepresentationItem_<'a>),
    RepresentationMap(RepresentationMap_<'a>),
    RepresentationRelationship(RepresentationRelationship_<'a>),
    RepresentationRelationshipWithTransformation(RepresentationRelationshipWithTransformation_<'a>),
    RequirementForActionResource(RequirementForActionResource_<'a>),
    ResourceProperty(ResourceProperty_<'a>),
    ResourcePropertyRepresentation(ResourcePropertyRepresentation_<'a>),
    ResourceRequirementType(ResourceRequirementType_<'a>),
    ResultingPath(ResultingPath_<'a>),
    Retention(Retention_<'a>),
    RevolutePair(RevolutePair_<'a>),
    RevolutePairRange(RevolutePairRange_<'a>),
    RevolutePairValue(RevolutePairValue_<'a>),
    RevolvedAreaSolid(RevolvedAreaSolid_<'a>),
    RevolvedFaceSolid(RevolvedFaceSolid_<'a>),
    Rib(Rib_<'a>),
    RightAngularWedge(RightAngularWedge_<'a>),
    RightCircularCone(RightCircularCone_<'a>),
    RightCircularCylinder(RightCircularCylinder_<'a>),
    RoleAssociation(RoleAssociation_<'a>),
    RollingCurvePair(RollingCurvePair_<'a>),
    RollingCurvePairValue(RollingCurvePairValue_<'a>),
    RollingSurfacePair(RollingSurfacePair_<'a>),
    RollingSurfacePairValue(RollingSurfacePairValue_<'a>),
    RotationAboutDirection(RotationAboutDirection_<'a>),
    RoundHole(RoundHole_<'a>),
    RoundedUProfile(RoundedUProfile_<'a>),
    RoundnessTolerance(RoundnessTolerance_<'a>),
    RuledSurfaceSweptAreaSolid(RuledSurfaceSweptAreaSolid_<'a>),
    RunoutZoneDefinition(RunoutZoneDefinition_<'a>),
    RunoutZoneOrientation(RunoutZoneOrientation_<'a>),
    RunoutZoneOrientationReferenceDirection(RunoutZoneOrientationReferenceDirection_<'a>),
    ScrewPair(ScrewPair_<'a>),
    ScrewPairRange(ScrewPairRange_<'a>),
    ScrewPairValue(ScrewPairValue_<'a>),
    SeamCurve(SeamCurve_<'a>),
    SeamEdge(SeamEdge_<'a>),
    SecurityClassification(SecurityClassification_<'a>),
    SecurityClassificationAssignment(SecurityClassificationAssignment_<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel_<'a>),
    SerialNumberedEffectivity(SerialNumberedEffectivity_<'a>),
    ShapeAspect(ShapeAspect_<'a>),
    ShapeAspectAssociativity(ShapeAspectAssociativity_<'a>),
    ShapeAspectDerivingRelationship(ShapeAspectDerivingRelationship_<'a>),
    ShapeAspectRelationship(ShapeAspectRelationship_<'a>),
    ShapeAspectTransition(ShapeAspectTransition_<'a>),
    ShapeDefiningRelationship(ShapeDefiningRelationship_<'a>),
    ShapeDefinitionRepresentation(ShapeDefinitionRepresentation_<'a>),
    ShapeDimensionRepresentation(ShapeDimensionRepresentation_<'a>),
    ShapeRepresentation(ShapeRepresentation_<'a>),
    ShapeRepresentationRelationship(ShapeRepresentationRelationship_<'a>),
    ShapeRepresentationWithParameters(ShapeRepresentationWithParameters_<'a>),
    ShellBasedSurfaceModel(ShellBasedSurfaceModel_<'a>),
    SiUnit(SiUnit_<'a>),
    SimpleBooleanExpression(SimpleBooleanExpression_<'a>),
    SimpleGenericExpression(SimpleGenericExpression_<'a>),
    SimpleNumericExpression(SimpleNumericExpression_<'a>),
    SimplePairRange(SimplePairRange_<'a>),
    SimpleStringExpression(SimpleStringExpression_<'a>),
    SinFunction(SinFunction_<'a>),
    SlashExpression(SlashExpression_<'a>),
    SlidingCurvePair(SlidingCurvePair_<'a>),
    SlidingCurvePairValue(SlidingCurvePairValue_<'a>),
    SlidingSurfacePair(SlidingSurfacePair_<'a>),
    SlidingSurfacePairValue(SlidingSurfacePairValue_<'a>),
    Slot(Slot_<'a>),
    SlotEnd(SlotEnd_<'a>),
    SolidAngleMeasureWithUnit(SolidAngleMeasureWithUnit_<'a>),
    SolidAngleUnit(SolidAngleUnit_<'a>),
    SolidModel(SolidModel_<'a>),
    SolidReplica(SolidReplica_<'a>),
    SpecifiedHigherUsageOccurrence(SpecifiedHigherUsageOccurrence_<'a>),
    Sphere(Sphere_<'a>),
    SphericalPair(SphericalPair_<'a>),
    SphericalPairRange(SphericalPairRange_<'a>),
    SphericalPairValue(SphericalPairValue_<'a>),
    SphericalSurface(SphericalSurface_<'a>),
    SqlMappableDefinedFunction(SqlMappableDefinedFunction_<'a>),
    SquareRootFunction(SquareRootFunction_<'a>),
    SquareUProfile(SquareUProfile_<'a>),
    StandardUncertainty(StandardUncertainty_<'a>),
    StraightnessTolerance(StraightnessTolerance_<'a>),
    StringDefinedFunction(StringDefinedFunction_<'a>),
    StringExpression(StringExpression_<'a>),
    StringLiteral(StringLiteral_<'a>),
    StringVariable(StringVariable_<'a>),
    StructuredDimensionCallout(StructuredDimensionCallout_<'a>),
    StyledItem(StyledItem_<'a>),
    Subedge(Subedge_<'a>),
    Subface(Subface_<'a>),
    SubstringExpression(SubstringExpression_<'a>),
    Surface(Surface_<'a>),
    SurfaceConditionCallout(SurfaceConditionCallout_<'a>),
    SurfaceCurve(SurfaceCurve_<'a>),
    SurfaceCurveSweptAreaSolid(SurfaceCurveSweptAreaSolid_<'a>),
    SurfaceOfLinearExtrusion(SurfaceOfLinearExtrusion_<'a>),
    SurfaceOfRevolution(SurfaceOfRevolution_<'a>),
    SurfacePair(SurfacePair_<'a>),
    SurfacePairRange(SurfacePairRange_<'a>),
    SurfacePatch(SurfacePatch_<'a>),
    SurfaceProfileTolerance(SurfaceProfileTolerance_<'a>),
    SurfaceRenderingProperties(SurfaceRenderingProperties_<'a>),
    SurfaceReplica(SurfaceReplica_<'a>),
    SurfaceSideStyle(SurfaceSideStyle_<'a>),
    SurfaceStyleBoundary(SurfaceStyleBoundary_<'a>),
    SurfaceStyleControlGrid(SurfaceStyleControlGrid_<'a>),
    SurfaceStyleFillArea(SurfaceStyleFillArea_<'a>),
    SurfaceStyleParameterLine(SurfaceStyleParameterLine_<'a>),
    SurfaceStyleReflectanceAmbient(SurfaceStyleReflectanceAmbient_<'a>),
    SurfaceStyleReflectanceAmbientDiffuse(SurfaceStyleReflectanceAmbientDiffuse_<'a>),
    SurfaceStyleReflectanceAmbientDiffuseSpecular(SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a>),
    SurfaceStyleRendering(SurfaceStyleRendering_<'a>),
    SurfaceStyleRenderingWithProperties(SurfaceStyleRenderingWithProperties_<'a>),
    SurfaceStyleSegmentationCurve(SurfaceStyleSegmentationCurve_<'a>),
    SurfaceStyleSilhouette(SurfaceStyleSilhouette_<'a>),
    SurfaceStyleTransparent(SurfaceStyleTransparent_<'a>),
    SurfaceStyleUsage(SurfaceStyleUsage_<'a>),
    SurfaceTextureRepresentation(SurfaceTextureRepresentation_<'a>),
    SweptAreaSolid(SweptAreaSolid_<'a>),
    SweptDiskSolid(SweptDiskSolid_<'a>),
    SweptFaceSolid(SweptFaceSolid_<'a>),
    SweptSurface(SweptSurface_<'a>),
    SymbolColour(SymbolColour_<'a>),
    SymbolRepresentation(SymbolRepresentation_<'a>),
    SymbolRepresentationMap(SymbolRepresentationMap_<'a>),
    SymbolStyle(SymbolStyle_<'a>),
    SymbolTarget(SymbolTarget_<'a>),
    SymmetricShapeAspect(SymmetricShapeAspect_<'a>),
    SymmetryTolerance(SymmetryTolerance_<'a>),
    TactileAppearanceRepresentation(TactileAppearanceRepresentation_<'a>),
    TanFunction(TanFunction_<'a>),
    Tangent(Tangent_<'a>),
    Taper(Taper_<'a>),
    TeeProfile(TeeProfile_<'a>),
    TerminatorSymbol(TerminatorSymbol_<'a>),
    TextLiteral(TextLiteral_<'a>),
    TextLiteralWithAssociatedCurves(TextLiteralWithAssociatedCurves_<'a>),
    TextLiteralWithBlankingBox(TextLiteralWithBlankingBox_<'a>),
    TextLiteralWithDelineation(TextLiteralWithDelineation_<'a>),
    TextLiteralWithExtent(TextLiteralWithExtent_<'a>),
    TextStringRepresentation(TextStringRepresentation_<'a>),
    TextStyle(TextStyle_<'a>),
    TextStyleForDefinedFont(TextStyleForDefinedFont_<'a>),
    TextStyleWithBoxCharacteristics(TextStyleWithBoxCharacteristics_<'a>),
    TextStyleWithMirror(TextStyleWithMirror_<'a>),
    TextStyleWithSpacing(TextStyleWithSpacing_<'a>),
    ThermodynamicTemperatureMeasureWithUnit(ThermodynamicTemperatureMeasureWithUnit_<'a>),
    ThermodynamicTemperatureUnit(ThermodynamicTemperatureUnit_<'a>),
    Thread(Thread_<'a>),
    TimeInterval(TimeInterval_<'a>),
    TimeIntervalAssignment(TimeIntervalAssignment_<'a>),
    TimeIntervalBasedEffectivity(TimeIntervalBasedEffectivity_<'a>),
    TimeIntervalRole(TimeIntervalRole_<'a>),
    TimeIntervalWithBounds(TimeIntervalWithBounds_<'a>),
    TimeMeasureWithUnit(TimeMeasureWithUnit_<'a>),
    TimeUnit(TimeUnit_<'a>),
    ToleranceValue(ToleranceValue_<'a>),
    ToleranceZone(ToleranceZone_<'a>),
    ToleranceZoneDefinition(ToleranceZoneDefinition_<'a>),
    ToleranceZoneForm(ToleranceZoneForm_<'a>),
    TopologicalRepresentationItem(TopologicalRepresentationItem_<'a>),
    ToroidalSurface(ToroidalSurface_<'a>),
    Torus(Torus_<'a>),
    TotalRunoutTolerance(TotalRunoutTolerance_<'a>),
    TransitionFeature(TransitionFeature_<'a>),
    TrimmedCurve(TrimmedCurve_<'a>),
    TwoDirectionRepeatFactor(TwoDirectionRepeatFactor_<'a>),
    TypeQualifier(TypeQualifier_<'a>),
    UnaryBooleanExpression(UnaryBooleanExpression_<'a>),
    UnaryFunctionCall(UnaryFunctionCall_<'a>),
    UnaryGenericExpression(UnaryGenericExpression_<'a>),
    UnaryNumericExpression(UnaryNumericExpression_<'a>),
    UncertaintyAssignedRepresentation(UncertaintyAssignedRepresentation_<'a>),
    UncertaintyMeasureWithUnit(UncertaintyMeasureWithUnit_<'a>),
    UncertaintyQualifier(UncertaintyQualifier_<'a>),
    UnconstrainedPair(UnconstrainedPair_<'a>),
    UnconstrainedPairValue(UnconstrainedPairValue_<'a>),
    UniformCurve(UniformCurve_<'a>),
    UniformSurface(UniformSurface_<'a>),
    UniversalPair(UniversalPair_<'a>),
    UniversalPairRange(UniversalPairRange_<'a>),
    UniversalPairValue(UniversalPairValue_<'a>),
    ValueFunction(ValueFunction_<'a>),
    ValueRange(ValueRange_<'a>),
    ValueRepresentationItem(ValueRepresentationItem_<'a>),
    Variable(Variable_<'a>),
    VariableSemantics(VariableSemantics_<'a>),
    Vector(Vector_<'a>),
    VectorStyle(VectorStyle_<'a>),
    VeeProfile(VeeProfile_<'a>),
    VersionedActionRequest(VersionedActionRequest_<'a>),
    VersionedActionRequestRelationship(VersionedActionRequestRelationship_<'a>),
    Vertex(Vertex_<'a>),
    VertexLoop(VertexLoop_<'a>),
    VertexPoint(VertexPoint_<'a>),
    ViewVolume(ViewVolume_<'a>),
    VisualAppearanceRepresentation(VisualAppearanceRepresentation_<'a>),
    VolumeMeasureWithUnit(VolumeMeasureWithUnit_<'a>),
    VolumeUnit(VolumeUnit_<'a>),
    XorExpression(XorExpression_<'a>),
  _ComplexMapping,
    _FailedToParse,
    _EmptySlot,
}
impl<'a> Parse<'a> for Entity<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        let (_, r) = recognize(pair(
            alt((alpha0, tag("_"))),
            many0(alt((alphanumeric1, tag("_")))),
        ))(s)?;
        match r {
            "ABS_FUNCTION" => map(AbsFunction_::parse, Entity::AbsFunction)(s),
            "ACOS_FUNCTION" => map(AcosFunction_::parse, Entity::AcosFunction)(s),
            "ACTION" => map(Action_::parse, Entity::Action)(s),
            "ACTION_ASSIGNMENT" => map(ActionAssignment_::parse, Entity::ActionAssignment)(s),
            "ACTION_DIRECTIVE" => map(ActionDirective_::parse, Entity::ActionDirective)(s),
            "ACTION_METHOD" => map(ActionMethod_::parse, Entity::ActionMethod)(s),
            "ACTION_METHOD_RELATIONSHIP" => map(ActionMethodRelationship_::parse, Entity::ActionMethodRelationship)(s),
            "ACTION_PROPERTY" => map(ActionProperty_::parse, Entity::ActionProperty)(s),
            "ACTION_PROPERTY_REPRESENTATION" => map(ActionPropertyRepresentation_::parse, Entity::ActionPropertyRepresentation)(s),
            "ACTION_RELATIONSHIP" => map(ActionRelationship_::parse, Entity::ActionRelationship)(s),
            "ACTION_REQUEST_ASSIGNMENT" => map(ActionRequestAssignment_::parse, Entity::ActionRequestAssignment)(s),
            "ACTION_REQUEST_SOLUTION" => map(ActionRequestSolution_::parse, Entity::ActionRequestSolution)(s),
            "ACTION_REQUEST_STATUS" => map(ActionRequestStatus_::parse, Entity::ActionRequestStatus)(s),
            "ACTION_RESOURCE" => map(ActionResource_::parse, Entity::ActionResource)(s),
            "ACTION_RESOURCE_REQUIREMENT" => map(ActionResourceRequirement_::parse, Entity::ActionResourceRequirement)(s),
            "ACTION_RESOURCE_TYPE" => map(ActionResourceType_::parse, Entity::ActionResourceType)(s),
            "ACTION_STATUS" => map(ActionStatus_::parse, Entity::ActionStatus)(s),
            "ADDRESS" => map(Address_::parse, Entity::Address)(s),
            "ADVANCED_BREP_SHAPE_REPRESENTATION" => map(AdvancedBrepShapeRepresentation_::parse, Entity::AdvancedBrepShapeRepresentation)(s),
            "ADVANCED_FACE" => map(AdvancedFace_::parse, Entity::AdvancedFace)(s),
            "ALTERNATE_PRODUCT_RELATIONSHIP" => map(AlternateProductRelationship_::parse, Entity::AlternateProductRelationship)(s),
            "AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT" => map(AmountOfSubstanceMeasureWithUnit_::parse, Entity::AmountOfSubstanceMeasureWithUnit)(s),
            "AMOUNT_OF_SUBSTANCE_UNIT" => map(AmountOfSubstanceUnit_::parse, Entity::AmountOfSubstanceUnit)(s),
            "AND_EXPRESSION" => map(AndExpression_::parse, Entity::AndExpression)(s),
            "ANGULAR_DIMENSION" => map(AngularDimension_::parse, Entity::AngularDimension)(s),
            "ANGULAR_LOCATION" => map(AngularLocation_::parse, Entity::AngularLocation)(s),
            "ANGULAR_SIZE" => map(AngularSize_::parse, Entity::AngularSize)(s),
            "ANGULARITY_TOLERANCE" => map(AngularityTolerance_::parse, Entity::AngularityTolerance)(s),
            "ANNOTATION_CURVE_OCCURRENCE" => map(AnnotationCurveOccurrence_::parse, Entity::AnnotationCurveOccurrence)(s),
            "ANNOTATION_FILL_AREA" => map(AnnotationFillArea_::parse, Entity::AnnotationFillArea)(s),
            "ANNOTATION_FILL_AREA_OCCURRENCE" => map(AnnotationFillAreaOccurrence_::parse, Entity::AnnotationFillAreaOccurrence)(s),
            "ANNOTATION_OCCURRENCE" => map(AnnotationOccurrence_::parse, Entity::AnnotationOccurrence)(s),
            "ANNOTATION_OCCURRENCE_ASSOCIATIVITY" => map(AnnotationOccurrenceAssociativity_::parse, Entity::AnnotationOccurrenceAssociativity)(s),
            "ANNOTATION_OCCURRENCE_RELATIONSHIP" => map(AnnotationOccurrenceRelationship_::parse, Entity::AnnotationOccurrenceRelationship)(s),
            "ANNOTATION_PLANE" => map(AnnotationPlane_::parse, Entity::AnnotationPlane)(s),
            "ANNOTATION_SUBFIGURE_OCCURRENCE" => map(AnnotationSubfigureOccurrence_::parse, Entity::AnnotationSubfigureOccurrence)(s),
            "ANNOTATION_SYMBOL" => map(AnnotationSymbol_::parse, Entity::AnnotationSymbol)(s),
            "ANNOTATION_SYMBOL_OCCURRENCE" => map(AnnotationSymbolOccurrence_::parse, Entity::AnnotationSymbolOccurrence)(s),
            "ANNOTATION_TEXT" => map(AnnotationText_::parse, Entity::AnnotationText)(s),
            "ANNOTATION_TEXT_CHARACTER" => map(AnnotationTextCharacter_::parse, Entity::AnnotationTextCharacter)(s),
            "ANNOTATION_TEXT_OCCURRENCE" => map(AnnotationTextOccurrence_::parse, Entity::AnnotationTextOccurrence)(s),
            "APEX" => map(Apex_::parse, Entity::Apex)(s),
            "APPLICATION_CONTEXT" => map(ApplicationContext_::parse, Entity::ApplicationContext)(s),
            "APPLICATION_CONTEXT_ELEMENT" => map(ApplicationContextElement_::parse, Entity::ApplicationContextElement)(s),
            "APPLICATION_CONTEXT_RELATIONSHIP" => map(ApplicationContextRelationship_::parse, Entity::ApplicationContextRelationship)(s),
            "APPLICATION_PROTOCOL_DEFINITION" => map(ApplicationProtocolDefinition_::parse, Entity::ApplicationProtocolDefinition)(s),
            "APPLIED_ACTION_ASSIGNMENT" => map(AppliedActionAssignment_::parse, Entity::AppliedActionAssignment)(s),
            "APPLIED_ACTION_REQUEST_ASSIGNMENT" => map(AppliedActionRequestAssignment_::parse, Entity::AppliedActionRequestAssignment)(s),
            "APPLIED_APPROVAL_ASSIGNMENT" => map(AppliedApprovalAssignment_::parse, Entity::AppliedApprovalAssignment)(s),
            "APPLIED_AREA" => map(AppliedArea_::parse, Entity::AppliedArea)(s),
            "APPLIED_CERTIFICATION_ASSIGNMENT" => map(AppliedCertificationAssignment_::parse, Entity::AppliedCertificationAssignment)(s),
            "APPLIED_CLASSIFICATION_ASSIGNMENT" => map(AppliedClassificationAssignment_::parse, Entity::AppliedClassificationAssignment)(s),
            "APPLIED_CONTRACT_ASSIGNMENT" => map(AppliedContractAssignment_::parse, Entity::AppliedContractAssignment)(s),
            "APPLIED_DATE_AND_TIME_ASSIGNMENT" => map(AppliedDateAndTimeAssignment_::parse, Entity::AppliedDateAndTimeAssignment)(s),
            "APPLIED_DATE_ASSIGNMENT" => map(AppliedDateAssignment_::parse, Entity::AppliedDateAssignment)(s),
            "APPLIED_DOCUMENT_REFERENCE" => map(AppliedDocumentReference_::parse, Entity::AppliedDocumentReference)(s),
            "APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => map(AppliedDocumentUsageConstraintAssignment_::parse, Entity::AppliedDocumentUsageConstraintAssignment)(s),
            "APPLIED_EFFECTIVITY_ASSIGNMENT" => map(AppliedEffectivityAssignment_::parse, Entity::AppliedEffectivityAssignment)(s),
            "APPLIED_EVENT_OCCURRENCE_ASSIGNMENT" => map(AppliedEventOccurrenceAssignment_::parse, Entity::AppliedEventOccurrenceAssignment)(s),
            "APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT" => map(AppliedExternalIdentificationAssignment_::parse, Entity::AppliedExternalIdentificationAssignment)(s),
            "APPLIED_GROUP_ASSIGNMENT" => map(AppliedGroupAssignment_::parse, Entity::AppliedGroupAssignment)(s),
            "APPLIED_IDENTIFICATION_ASSIGNMENT" => map(AppliedIdentificationAssignment_::parse, Entity::AppliedIdentificationAssignment)(s),
            "APPLIED_INEFFECTIVITY_ASSIGNMENT" => map(AppliedIneffectivityAssignment_::parse, Entity::AppliedIneffectivityAssignment)(s),
            "APPLIED_NAME_ASSIGNMENT" => map(AppliedNameAssignment_::parse, Entity::AppliedNameAssignment)(s),
            "APPLIED_ORGANIZATION_ASSIGNMENT" => map(AppliedOrganizationAssignment_::parse, Entity::AppliedOrganizationAssignment)(s),
            "APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT" => map(AppliedOrganizationalProjectAssignment_::parse, Entity::AppliedOrganizationalProjectAssignment)(s),
            "APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT" => map(AppliedPersonAndOrganizationAssignment_::parse, Entity::AppliedPersonAndOrganizationAssignment)(s),
            "APPLIED_PRESENTED_ITEM" => map(AppliedPresentedItem_::parse, Entity::AppliedPresentedItem)(s),
            "APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT" => map(AppliedSecurityClassificationAssignment_::parse, Entity::AppliedSecurityClassificationAssignment)(s),
            "APPLIED_TIME_INTERVAL_ASSIGNMENT" => map(AppliedTimeIntervalAssignment_::parse, Entity::AppliedTimeIntervalAssignment)(s),
            "APPROVAL" => map(Approval_::parse, Entity::Approval)(s),
            "APPROVAL_ASSIGNMENT" => map(ApprovalAssignment_::parse, Entity::ApprovalAssignment)(s),
            "APPROVAL_DATE_TIME" => map(ApprovalDateTime_::parse, Entity::ApprovalDateTime)(s),
            "APPROVAL_PERSON_ORGANIZATION" => map(ApprovalPersonOrganization_::parse, Entity::ApprovalPersonOrganization)(s),
            "APPROVAL_RELATIONSHIP" => map(ApprovalRelationship_::parse, Entity::ApprovalRelationship)(s),
            "APPROVAL_ROLE" => map(ApprovalRole_::parse, Entity::ApprovalRole)(s),
            "APPROVAL_STATUS" => map(ApprovalStatus_::parse, Entity::ApprovalStatus)(s),
            "APPROXIMATION_TOLERANCE" => map(ApproximationTolerance_::parse, Entity::ApproximationTolerance)(s),
            "APPROXIMATION_TOLERANCE_DEVIATION" => map(ApproximationToleranceDeviation_::parse, Entity::ApproximationToleranceDeviation)(s),
            "APPROXIMATION_TOLERANCE_PARAMETER" => map(ApproximationToleranceParameter_::parse, Entity::ApproximationToleranceParameter)(s),
            "AREA_IN_SET" => map(AreaInSet_::parse, Entity::AreaInSet)(s),
            "AREA_MEASURE_WITH_UNIT" => map(AreaMeasureWithUnit_::parse, Entity::AreaMeasureWithUnit)(s),
            "AREA_UNIT" => map(AreaUnit_::parse, Entity::AreaUnit)(s),
            "ASIN_FUNCTION" => map(AsinFunction_::parse, Entity::AsinFunction)(s),
            "ASSEMBLY_COMPONENT_USAGE" => map(AssemblyComponentUsage_::parse, Entity::AssemblyComponentUsage)(s),
            "ASSEMBLY_COMPONENT_USAGE_SUBSTITUTE" => map(AssemblyComponentUsageSubstitute_::parse, Entity::AssemblyComponentUsageSubstitute)(s),
            "ATAN_FUNCTION" => map(AtanFunction_::parse, Entity::AtanFunction)(s),
            "ATTRIBUTE_CLASSIFICATION_ASSIGNMENT" => map(AttributeClassificationAssignment_::parse, Entity::AttributeClassificationAssignment)(s),
            "ATTRIBUTE_LANGUAGE_ASSIGNMENT" => map(AttributeLanguageAssignment_::parse, Entity::AttributeLanguageAssignment)(s),
            "ATTRIBUTE_VALUE_ASSIGNMENT" => map(AttributeValueAssignment_::parse, Entity::AttributeValueAssignment)(s),
            "ATTRIBUTE_VALUE_ROLE" => map(AttributeValueRole_::parse, Entity::AttributeValueRole)(s),
            "AXIS1_PLACEMENT" => map(Axis1Placement_::parse, Entity::Axis1Placement)(s),
            "AXIS2_PLACEMENT_2D" => map(Axis2Placement2d_::parse, Entity::Axis2Placement2d)(s),
            "AXIS2_PLACEMENT_3D" => map(Axis2Placement3d_::parse, Entity::Axis2Placement3d)(s),
            "B_SPLINE_CURVE" => map(BSplineCurve_::parse, Entity::BSplineCurve)(s),
            "B_SPLINE_CURVE_WITH_KNOTS" => map(BSplineCurveWithKnots_::parse, Entity::BSplineCurveWithKnots)(s),
            "B_SPLINE_SURFACE" => map(BSplineSurface_::parse, Entity::BSplineSurface)(s),
            "B_SPLINE_SURFACE_WITH_KNOTS" => map(BSplineSurfaceWithKnots_::parse, Entity::BSplineSurfaceWithKnots)(s),
            "BACKGROUND_COLOUR" => map(BackgroundColour_::parse, Entity::BackgroundColour)(s),
            "BARRING_HOLE" => map(BarringHole_::parse, Entity::BarringHole)(s),
            "BEAD" => map(Bead_::parse, Entity::Bead)(s),
            "BEAD_END" => map(BeadEnd_::parse, Entity::BeadEnd)(s),
            "BEZIER_CURVE" => map(BezierCurve_::parse, Entity::BezierCurve)(s),
            "BEZIER_SURFACE" => map(BezierSurface_::parse, Entity::BezierSurface)(s),
            "BINARY_BOOLEAN_EXPRESSION" => map(BinaryBooleanExpression_::parse, Entity::BinaryBooleanExpression)(s),
            "BINARY_FUNCTION_CALL" => map(BinaryFunctionCall_::parse, Entity::BinaryFunctionCall)(s),
            "BINARY_GENERIC_EXPRESSION" => map(BinaryGenericExpression_::parse, Entity::BinaryGenericExpression)(s),
            "BINARY_NUMERIC_EXPRESSION" => map(BinaryNumericExpression_::parse, Entity::BinaryNumericExpression)(s),
            "BLOCK" => map(Block_::parse, Entity::Block)(s),
            "BOOLEAN_DEFINED_FUNCTION" => map(BooleanDefinedFunction_::parse, Entity::BooleanDefinedFunction)(s),
            "BOOLEAN_EXPRESSION" => map(BooleanExpression_::parse, Entity::BooleanExpression)(s),
            "BOOLEAN_LITERAL" => map(BooleanLiteral_::parse, Entity::BooleanLiteral)(s),
            "BOOLEAN_RESULT" => map(BooleanResult_::parse, Entity::BooleanResult)(s),
            "BOOLEAN_VARIABLE" => map(BooleanVariable_::parse, Entity::BooleanVariable)(s),
            "BOSS" => map(Boss_::parse, Entity::Boss)(s),
            "BOSS_TOP" => map(BossTop_::parse, Entity::BossTop)(s),
            "BOUNDARY_CURVE" => map(BoundaryCurve_::parse, Entity::BoundaryCurve)(s),
            "BOUNDED_CURVE" => map(BoundedCurve_::parse, Entity::BoundedCurve)(s),
            "BOUNDED_PCURVE" => map(BoundedPcurve_::parse, Entity::BoundedPcurve)(s),
            "BOUNDED_SURFACE" => map(BoundedSurface_::parse, Entity::BoundedSurface)(s),
            "BOUNDED_SURFACE_CURVE" => map(BoundedSurfaceCurve_::parse, Entity::BoundedSurfaceCurve)(s),
            "BOX_DOMAIN" => map(BoxDomain_::parse, Entity::BoxDomain)(s),
            "BOXED_HALF_SPACE" => map(BoxedHalfSpace_::parse, Entity::BoxedHalfSpace)(s),
            "BREP_WITH_VOIDS" => map(BrepWithVoids_::parse, Entity::BrepWithVoids)(s),
            "CALENDAR_DATE" => map(CalendarDate_::parse, Entity::CalendarDate)(s),
            "CAMERA_IMAGE" => map(CameraImage_::parse, Entity::CameraImage)(s),
            "CAMERA_IMAGE_2D_WITH_SCALE" => map(CameraImage2dWithScale_::parse, Entity::CameraImage2dWithScale)(s),
            "CAMERA_IMAGE_3D_WITH_SCALE" => map(CameraImage3dWithScale_::parse, Entity::CameraImage3dWithScale)(s),
            "CAMERA_MODEL" => map(CameraModel_::parse, Entity::CameraModel)(s),
            "CAMERA_MODEL_D2" => map(CameraModelD2_::parse, Entity::CameraModelD2)(s),
            "CAMERA_MODEL_D3" => map(CameraModelD3_::parse, Entity::CameraModelD3)(s),
            "CAMERA_MODEL_D3_WITH_HLHSR" => map(CameraModelD3WithHlhsr_::parse, Entity::CameraModelD3WithHlhsr)(s),
            "CAMERA_USAGE" => map(CameraUsage_::parse, Entity::CameraUsage)(s),
            "CARTESIAN_POINT" => map(CartesianPoint_::parse, Entity::CartesianPoint)(s),
            "CARTESIAN_TRANSFORMATION_OPERATOR" => map(CartesianTransformationOperator_::parse, Entity::CartesianTransformationOperator)(s),
            "CARTESIAN_TRANSFORMATION_OPERATOR_2D" => map(CartesianTransformationOperator2d_::parse, Entity::CartesianTransformationOperator2d)(s),
            "CARTESIAN_TRANSFORMATION_OPERATOR_3D" => map(CartesianTransformationOperator3d_::parse, Entity::CartesianTransformationOperator3d)(s),
            "CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT" => map(CelsiusTemperatureMeasureWithUnit_::parse, Entity::CelsiusTemperatureMeasureWithUnit)(s),
            "CENTRE_OF_SYMMETRY" => map(CentreOfSymmetry_::parse, Entity::CentreOfSymmetry)(s),
            "CERTIFICATION" => map(Certification_::parse, Entity::Certification)(s),
            "CERTIFICATION_ASSIGNMENT" => map(CertificationAssignment_::parse, Entity::CertificationAssignment)(s),
            "CERTIFICATION_TYPE" => map(CertificationType_::parse, Entity::CertificationType)(s),
            "CHAMFER" => map(Chamfer_::parse, Entity::Chamfer)(s),
            "CHAMFER_OFFSET" => map(ChamferOffset_::parse, Entity::ChamferOffset)(s),
            "CHARACTER_GLYPH_SYMBOL" => map(CharacterGlyphSymbol_::parse, Entity::CharacterGlyphSymbol)(s),
            "CHARACTERIZED_CLASS" => map(CharacterizedClass_::parse, Entity::CharacterizedClass)(s),
            "CHARACTERIZED_OBJECT" => map(CharacterizedObject_::parse, Entity::CharacterizedObject)(s),
            "CIRCLE" => map(Circle_::parse, Entity::Circle)(s),
            "CIRCULAR_CLOSED_PROFILE" => map(CircularClosedProfile_::parse, Entity::CircularClosedProfile)(s),
            "CIRCULAR_PATTERN" => map(CircularPattern_::parse, Entity::CircularPattern)(s),
            "CIRCULAR_RUNOUT_TOLERANCE" => map(CircularRunoutTolerance_::parse, Entity::CircularRunoutTolerance)(s),
            "CLASS" => map(Class_::parse, Entity::Class)(s),
            "CLASS_SYSTEM" => map(ClassSystem_::parse, Entity::ClassSystem)(s),
            "CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT" => map(ClassUsageEffectivityContextAssignment_::parse, Entity::ClassUsageEffectivityContextAssignment)(s),
            "CLASSIFICATION_ASSIGNMENT" => map(ClassificationAssignment_::parse, Entity::ClassificationAssignment)(s),
            "CLASSIFICATION_ROLE" => map(ClassificationRole_::parse, Entity::ClassificationRole)(s),
            "CLOSED_PATH_PROFILE" => map(ClosedPathProfile_::parse, Entity::ClosedPathProfile)(s),
            "CLOSED_SHELL" => map(ClosedShell_::parse, Entity::ClosedShell)(s),
            "COAXIALITY_TOLERANCE" => map(CoaxialityTolerance_::parse, Entity::CoaxialityTolerance)(s),
            "COLOUR" => map(Colour_::parse, Entity::Colour)(s),
            "COLOUR_RGB" => map(ColourRgb_::parse, Entity::ColourRgb)(s),
            "COLOUR_SPECIFICATION" => map(ColourSpecification_::parse, Entity::ColourSpecification)(s),
            "COMMON_DATUM" => map(CommonDatum_::parse, Entity::CommonDatum)(s),
            "COMPARISON_EQUAL" => map(ComparisonEqual_::parse, Entity::ComparisonEqual)(s),
            "COMPARISON_EXPRESSION" => map(ComparisonExpression_::parse, Entity::ComparisonExpression)(s),
            "COMPARISON_GREATER" => map(ComparisonGreater_::parse, Entity::ComparisonGreater)(s),
            "COMPARISON_GREATER_EQUAL" => map(ComparisonGreaterEqual_::parse, Entity::ComparisonGreaterEqual)(s),
            "COMPARISON_LESS" => map(ComparisonLess_::parse, Entity::ComparisonLess)(s),
            "COMPARISON_LESS_EQUAL" => map(ComparisonLessEqual_::parse, Entity::ComparisonLessEqual)(s),
            "COMPARISON_NOT_EQUAL" => map(ComparisonNotEqual_::parse, Entity::ComparisonNotEqual)(s),
            "COMPOSITE_CURVE" => map(CompositeCurve_::parse, Entity::CompositeCurve)(s),
            "COMPOSITE_CURVE_ON_SURFACE" => map(CompositeCurveOnSurface_::parse, Entity::CompositeCurveOnSurface)(s),
            "COMPOSITE_CURVE_SEGMENT" => map(CompositeCurveSegment_::parse, Entity::CompositeCurveSegment)(s),
            "COMPOSITE_HOLE" => map(CompositeHole_::parse, Entity::CompositeHole)(s),
            "COMPOSITE_SHAPE_ASPECT" => map(CompositeShapeAspect_::parse, Entity::CompositeShapeAspect)(s),
            "COMPOSITE_TEXT" => map(CompositeText_::parse, Entity::CompositeText)(s),
            "COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES" => map(CompositeTextWithAssociatedCurves_::parse, Entity::CompositeTextWithAssociatedCurves)(s),
            "COMPOSITE_TEXT_WITH_BLANKING_BOX" => map(CompositeTextWithBlankingBox_::parse, Entity::CompositeTextWithBlankingBox)(s),
            "COMPOSITE_TEXT_WITH_EXTENT" => map(CompositeTextWithExtent_::parse, Entity::CompositeTextWithExtent)(s),
            "COMPOUND_FEATURE" => map(CompoundFeature_::parse, Entity::CompoundFeature)(s),
            "COMPOUND_REPRESENTATION_ITEM" => map(CompoundRepresentationItem_::parse, Entity::CompoundRepresentationItem)(s),
            "COMPOUND_SHAPE_REPRESENTATION" => map(CompoundShapeRepresentation_::parse, Entity::CompoundShapeRepresentation)(s),
            "CONCAT_EXPRESSION" => map(ConcatExpression_::parse, Entity::ConcatExpression)(s),
            "CONCENTRICITY_TOLERANCE" => map(ConcentricityTolerance_::parse, Entity::ConcentricityTolerance)(s),
            "CONCEPT_FEATURE_OPERATOR" => map(ConceptFeatureOperator_::parse, Entity::ConceptFeatureOperator)(s),
            "CONCEPT_FEATURE_RELATIONSHIP" => map(ConceptFeatureRelationship_::parse, Entity::ConceptFeatureRelationship)(s),
            "CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION" => map(ConceptFeatureRelationshipWithCondition_::parse, Entity::ConceptFeatureRelationshipWithCondition)(s),
            "CONDITIONAL_CONCEPT_FEATURE" => map(ConditionalConceptFeature_::parse, Entity::ConditionalConceptFeature)(s),
            "CONFIGURABLE_ITEM" => map(ConfigurableItem_::parse, Entity::ConfigurableItem)(s),
            "CONFIGURATION_DEFINITION" => map(ConfigurationDefinition_::parse, Entity::ConfigurationDefinition)(s),
            "CONFIGURATION_DESIGN" => map(ConfigurationDesign_::parse, Entity::ConfigurationDesign)(s),
            "CONFIGURATION_EFFECTIVITY" => map(ConfigurationEffectivity_::parse, Entity::ConfigurationEffectivity)(s),
            "CONFIGURATION_INTERPOLATION" => map(ConfigurationInterpolation_::parse, Entity::ConfigurationInterpolation)(s),
            "CONFIGURATION_ITEM" => map(ConfigurationItem_::parse, Entity::ConfigurationItem)(s),
            "CONFIGURED_EFFECTIVITY_ASSIGNMENT" => map(ConfiguredEffectivityAssignment_::parse, Entity::ConfiguredEffectivityAssignment)(s),
            "CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT" => map(ConfiguredEffectivityContextAssignment_::parse, Entity::ConfiguredEffectivityContextAssignment)(s),
            "CONIC" => map(Conic_::parse, Entity::Conic)(s),
            "CONICAL_SURFACE" => map(ConicalSurface_::parse, Entity::ConicalSurface)(s),
            "CONNECTED_EDGE_SET" => map(ConnectedEdgeSet_::parse, Entity::ConnectedEdgeSet)(s),
            "CONNECTED_FACE_SET" => map(ConnectedFaceSet_::parse, Entity::ConnectedFaceSet)(s),
            "CONNECTED_FACE_SUB_SET" => map(ConnectedFaceSubSet_::parse, Entity::ConnectedFaceSubSet)(s),
            "CONSTRUCTIVE_GEOMETRY_REPRESENTATION" => map(ConstructiveGeometryRepresentation_::parse, Entity::ConstructiveGeometryRepresentation)(s),
            "CONSTRUCTIVE_GEOMETRY_REPRESENTATION_RELATIONSHIP" => map(ConstructiveGeometryRepresentationRelationship_::parse, Entity::ConstructiveGeometryRepresentationRelationship)(s),
            "CONTACT_RATIO_REPRESENTATION" => map(ContactRatioRepresentation_::parse, Entity::ContactRatioRepresentation)(s),
            "CONTEXT_DEPENDENT_INVISIBILITY" => map(ContextDependentInvisibility_::parse, Entity::ContextDependentInvisibility)(s),
            "CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM" => map(ContextDependentOverRidingStyledItem_::parse, Entity::ContextDependentOverRidingStyledItem)(s),
            "CONTEXT_DEPENDENT_SHAPE_REPRESENTATION" => map(ContextDependentShapeRepresentation_::parse, Entity::ContextDependentShapeRepresentation)(s),
            "CONTEXT_DEPENDENT_UNIT" => map(ContextDependentUnit_::parse, Entity::ContextDependentUnit)(s),
            "CONTRACT" => map(Contract_::parse, Entity::Contract)(s),
            "CONTRACT_ASSIGNMENT" => map(ContractAssignment_::parse, Entity::ContractAssignment)(s),
            "CONTRACT_TYPE" => map(ContractType_::parse, Entity::ContractType)(s),
            "CONVERSION_BASED_UNIT" => map(ConversionBasedUnit_::parse, Entity::ConversionBasedUnit)(s),
            "COORDINATED_UNIVERSAL_TIME_OFFSET" => map(CoordinatedUniversalTimeOffset_::parse, Entity::CoordinatedUniversalTimeOffset)(s),
            "COS_FUNCTION" => map(CosFunction_::parse, Entity::CosFunction)(s),
            "CSG_SHAPE_REPRESENTATION" => map(CsgShapeRepresentation_::parse, Entity::CsgShapeRepresentation)(s),
            "CSG_SOLID" => map(CsgSolid_::parse, Entity::CsgSolid)(s),
            "CURVE" => map(Curve_::parse, Entity::Curve)(s),
            "CURVE_BOUNDED_SURFACE" => map(CurveBoundedSurface_::parse, Entity::CurveBoundedSurface)(s),
            "CURVE_DIMENSION" => map(CurveDimension_::parse, Entity::CurveDimension)(s),
            "CURVE_REPLICA" => map(CurveReplica_::parse, Entity::CurveReplica)(s),
            "CURVE_STYLE" => map(CurveStyle_::parse, Entity::CurveStyle)(s),
            "CURVE_STYLE_FONT" => map(CurveStyleFont_::parse, Entity::CurveStyleFont)(s),
            "CURVE_STYLE_FONT_PATTERN" => map(CurveStyleFontPattern_::parse, Entity::CurveStyleFontPattern)(s),
            "CURVE_STYLE_RENDERING" => map(CurveStyleRendering_::parse, Entity::CurveStyleRendering)(s),
            "CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION" => map(CurveSweptSolidShapeRepresentation_::parse, Entity::CurveSweptSolidShapeRepresentation)(s),
            "CYLINDRICAL_PAIR" => map(CylindricalPair_::parse, Entity::CylindricalPair)(s),
            "CYLINDRICAL_PAIR_RANGE" => map(CylindricalPairRange_::parse, Entity::CylindricalPairRange)(s),
            "CYLINDRICAL_PAIR_VALUE" => map(CylindricalPairValue_::parse, Entity::CylindricalPairValue)(s),
            "CYLINDRICAL_SURFACE" => map(CylindricalSurface_::parse, Entity::CylindricalSurface)(s),
            "CYLINDRICITY_TOLERANCE" => map(CylindricityTolerance_::parse, Entity::CylindricityTolerance)(s),
            "DATA_ENVIRONMENT" => map(DataEnvironment_::parse, Entity::DataEnvironment)(s),
            "DATE" => map(Date_::parse, Entity::Date)(s),
            "DATE_AND_TIME" => map(DateAndTime_::parse, Entity::DateAndTime)(s),
            "DATE_AND_TIME_ASSIGNMENT" => map(DateAndTimeAssignment_::parse, Entity::DateAndTimeAssignment)(s),
            "DATE_ASSIGNMENT" => map(DateAssignment_::parse, Entity::DateAssignment)(s),
            "DATE_ROLE" => map(DateRole_::parse, Entity::DateRole)(s),
            "DATE_TIME_ROLE" => map(DateTimeRole_::parse, Entity::DateTimeRole)(s),
            "DATED_EFFECTIVITY" => map(DatedEffectivity_::parse, Entity::DatedEffectivity)(s),
            "DATUM" => map(Datum_::parse, Entity::Datum)(s),
            "DATUM_FEATURE" => map(DatumFeature_::parse, Entity::DatumFeature)(s),
            "DATUM_FEATURE_CALLOUT" => map(DatumFeatureCallout_::parse, Entity::DatumFeatureCallout)(s),
            "DATUM_REFERENCE" => map(DatumReference_::parse, Entity::DatumReference)(s),
            "DATUM_TARGET" => map(DatumTarget_::parse, Entity::DatumTarget)(s),
            "DATUM_TARGET_CALLOUT" => map(DatumTargetCallout_::parse, Entity::DatumTargetCallout)(s),
            "DEFAULT_TOLERANCE_TABLE" => map(DefaultToleranceTable_::parse, Entity::DefaultToleranceTable)(s),
            "DEFAULT_TOLERANCE_TABLE_CELL" => map(DefaultToleranceTableCell_::parse, Entity::DefaultToleranceTableCell)(s),
            "DEFINED_CHARACTER_GLYPH" => map(DefinedCharacterGlyph_::parse, Entity::DefinedCharacterGlyph)(s),
            "DEFINED_FUNCTION" => map(DefinedFunction_::parse, Entity::DefinedFunction)(s),
            "DEFINED_SYMBOL" => map(DefinedSymbol_::parse, Entity::DefinedSymbol)(s),
            "DEFINITIONAL_REPRESENTATION" => map(DefinitionalRepresentation_::parse, Entity::DefinitionalRepresentation)(s),
            "DEGENERATE_PCURVE" => map(DegeneratePcurve_::parse, Entity::DegeneratePcurve)(s),
            "DEGENERATE_TOROIDAL_SURFACE" => map(DegenerateToroidalSurface_::parse, Entity::DegenerateToroidalSurface)(s),
            "DERIVED_SHAPE_ASPECT" => map(DerivedShapeAspect_::parse, Entity::DerivedShapeAspect)(s),
            "DERIVED_UNIT" => map(DerivedUnit_::parse, Entity::DerivedUnit)(s),
            "DERIVED_UNIT_ELEMENT" => map(DerivedUnitElement_::parse, Entity::DerivedUnitElement)(s),
            "DERIVED_UNIT_VARIABLE" => map(DerivedUnitVariable_::parse, Entity::DerivedUnitVariable)(s),
            "DESCRIPTION_ATTRIBUTE" => map(DescriptionAttribute_::parse, Entity::DescriptionAttribute)(s),
            "DESCRIPTIVE_REPRESENTATION_ITEM" => map(DescriptiveRepresentationItem_::parse, Entity::DescriptiveRepresentationItem)(s),
            "DIAMETER_DIMENSION" => map(DiameterDimension_::parse, Entity::DiameterDimension)(s),
            "DIMENSION_CALLOUT" => map(DimensionCallout_::parse, Entity::DimensionCallout)(s),
            "DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP" => map(DimensionCalloutComponentRelationship_::parse, Entity::DimensionCalloutComponentRelationship)(s),
            "DIMENSION_CALLOUT_RELATIONSHIP" => map(DimensionCalloutRelationship_::parse, Entity::DimensionCalloutRelationship)(s),
            "DIMENSION_CURVE" => map(DimensionCurve_::parse, Entity::DimensionCurve)(s),
            "DIMENSION_CURVE_DIRECTED_CALLOUT" => map(DimensionCurveDirectedCallout_::parse, Entity::DimensionCurveDirectedCallout)(s),
            "DIMENSION_CURVE_TERMINATOR" => map(DimensionCurveTerminator_::parse, Entity::DimensionCurveTerminator)(s),
            "DIMENSION_PAIR" => map(DimensionPair_::parse, Entity::DimensionPair)(s),
            "DIMENSION_RELATED_TOLERANCE_ZONE_ELEMENT" => map(DimensionRelatedToleranceZoneElement_::parse, Entity::DimensionRelatedToleranceZoneElement)(s),
            "DIMENSION_TEXT_ASSOCIATIVITY" => map(DimensionTextAssociativity_::parse, Entity::DimensionTextAssociativity)(s),
            "DIMENSIONAL_CHARACTERISTIC_REPRESENTATION" => map(DimensionalCharacteristicRepresentation_::parse, Entity::DimensionalCharacteristicRepresentation)(s),
            "DIMENSIONAL_EXPONENTS" => map(DimensionalExponents_::parse, Entity::DimensionalExponents)(s),
            "DIMENSIONAL_LOCATION" => map(DimensionalLocation_::parse, Entity::DimensionalLocation)(s),
            "DIMENSIONAL_LOCATION_WITH_PATH" => map(DimensionalLocationWithPath_::parse, Entity::DimensionalLocationWithPath)(s),
            "DIMENSIONAL_SIZE" => map(DimensionalSize_::parse, Entity::DimensionalSize)(s),
            "DIMENSIONAL_SIZE_WITH_PATH" => map(DimensionalSizeWithPath_::parse, Entity::DimensionalSizeWithPath)(s),
            "DIRECTED_ACTION" => map(DirectedAction_::parse, Entity::DirectedAction)(s),
            "DIRECTED_ANGLE" => map(DirectedAngle_::parse, Entity::DirectedAngle)(s),
            "DIRECTED_DIMENSIONAL_LOCATION" => map(DirectedDimensionalLocation_::parse, Entity::DirectedDimensionalLocation)(s),
            "DIRECTION" => map(Direction_::parse, Entity::Direction)(s),
            "DIRECTION_SHAPE_REPRESENTATION" => map(DirectionShapeRepresentation_::parse, Entity::DirectionShapeRepresentation)(s),
            "DIV_EXPRESSION" => map(DivExpression_::parse, Entity::DivExpression)(s),
            "DOCUMENT" => map(Document_::parse, Entity::Document)(s),
            "DOCUMENT_FILE" => map(DocumentFile_::parse, Entity::DocumentFile)(s),
            "DOCUMENT_PRODUCT_ASSOCIATION" => map(DocumentProductAssociation_::parse, Entity::DocumentProductAssociation)(s),
            "DOCUMENT_PRODUCT_EQUIVALENCE" => map(DocumentProductEquivalence_::parse, Entity::DocumentProductEquivalence)(s),
            "DOCUMENT_REFERENCE" => map(DocumentReference_::parse, Entity::DocumentReference)(s),
            "DOCUMENT_RELATIONSHIP" => map(DocumentRelationship_::parse, Entity::DocumentRelationship)(s),
            "DOCUMENT_REPRESENTATION_TYPE" => map(DocumentRepresentationType_::parse, Entity::DocumentRepresentationType)(s),
            "DOCUMENT_TYPE" => map(DocumentType_::parse, Entity::DocumentType)(s),
            "DOCUMENT_USAGE_CONSTRAINT" => map(DocumentUsageConstraint_::parse, Entity::DocumentUsageConstraint)(s),
            "DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => map(DocumentUsageConstraintAssignment_::parse, Entity::DocumentUsageConstraintAssignment)(s),
            "DOCUMENT_USAGE_ROLE" => map(DocumentUsageRole_::parse, Entity::DocumentUsageRole)(s),
            "DRAUGHTING_ANNOTATION_OCCURRENCE" => map(DraughtingAnnotationOccurrence_::parse, Entity::DraughtingAnnotationOccurrence)(s),
            "DRAUGHTING_CALLOUT" => map(DraughtingCallout_::parse, Entity::DraughtingCallout)(s),
            "DRAUGHTING_CALLOUT_RELATIONSHIP" => map(DraughtingCalloutRelationship_::parse, Entity::DraughtingCalloutRelationship)(s),
            "DRAUGHTING_ELEMENTS" => map(DraughtingElements_::parse, Entity::DraughtingElements)(s),
            "DRAUGHTING_MODEL" => map(DraughtingModel_::parse, Entity::DraughtingModel)(s),
            "DRAUGHTING_MODEL_ITEM_ASSOCIATION" => map(DraughtingModelItemAssociation_::parse, Entity::DraughtingModelItemAssociation)(s),
            "DRAUGHTING_PRE_DEFINED_COLOUR" => map(DraughtingPreDefinedColour_::parse, Entity::DraughtingPreDefinedColour)(s),
            "DRAUGHTING_PRE_DEFINED_CURVE_FONT" => map(DraughtingPreDefinedCurveFont_::parse, Entity::DraughtingPreDefinedCurveFont)(s),
            "DRAUGHTING_PRE_DEFINED_TEXT_FONT" => map(DraughtingPreDefinedTextFont_::parse, Entity::DraughtingPreDefinedTextFont)(s),
            "DRAUGHTING_SPECIFICATION_REFERENCE" => map(DraughtingSpecificationReference_::parse, Entity::DraughtingSpecificationReference)(s),
            "DRAUGHTING_SUBFIGURE_REPRESENTATION" => map(DraughtingSubfigureRepresentation_::parse, Entity::DraughtingSubfigureRepresentation)(s),
            "DRAUGHTING_SYMBOL_REPRESENTATION" => map(DraughtingSymbolRepresentation_::parse, Entity::DraughtingSymbolRepresentation)(s),
            "DRAUGHTING_TEXT_LITERAL_WITH_DELINEATION" => map(DraughtingTextLiteralWithDelineation_::parse, Entity::DraughtingTextLiteralWithDelineation)(s),
            "DRAUGHTING_TITLE" => map(DraughtingTitle_::parse, Entity::DraughtingTitle)(s),
            "DRAWING_DEFINITION" => map(DrawingDefinition_::parse, Entity::DrawingDefinition)(s),
            "DRAWING_REVISION" => map(DrawingRevision_::parse, Entity::DrawingRevision)(s),
            "DRAWING_REVISION_SEQUENCE" => map(DrawingRevisionSequence_::parse, Entity::DrawingRevisionSequence)(s),
            "DRAWING_SHEET_LAYOUT" => map(DrawingSheetLayout_::parse, Entity::DrawingSheetLayout)(s),
            "DRAWING_SHEET_REVISION" => map(DrawingSheetRevision_::parse, Entity::DrawingSheetRevision)(s),
            "DRAWING_SHEET_REVISION_USAGE" => map(DrawingSheetRevisionUsage_::parse, Entity::DrawingSheetRevisionUsage)(s),
            "EDGE" => map(Edge_::parse, Entity::Edge)(s),
            "EDGE_BASED_WIREFRAME_MODEL" => map(EdgeBasedWireframeModel_::parse, Entity::EdgeBasedWireframeModel)(s),
            "EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION" => map(EdgeBasedWireframeShapeRepresentation_::parse, Entity::EdgeBasedWireframeShapeRepresentation)(s),
            "EDGE_CURVE" => map(EdgeCurve_::parse, Entity::EdgeCurve)(s),
            "EDGE_LOOP" => map(EdgeLoop_::parse, Entity::EdgeLoop)(s),
            "EDGE_ROUND" => map(EdgeRound_::parse, Entity::EdgeRound)(s),
            "EFFECTIVITY" => map(Effectivity_::parse, Entity::Effectivity)(s),
            "EFFECTIVITY_ASSIGNMENT" => map(EffectivityAssignment_::parse, Entity::EffectivityAssignment)(s),
            "EFFECTIVITY_CONTEXT_ASSIGNMENT" => map(EffectivityContextAssignment_::parse, Entity::EffectivityContextAssignment)(s),
            "EFFECTIVITY_CONTEXT_ROLE" => map(EffectivityContextRole_::parse, Entity::EffectivityContextRole)(s),
            "EFFECTIVITY_RELATIONSHIP" => map(EffectivityRelationship_::parse, Entity::EffectivityRelationship)(s),
            "ELECTRIC_CURRENT_MEASURE_WITH_UNIT" => map(ElectricCurrentMeasureWithUnit_::parse, Entity::ElectricCurrentMeasureWithUnit)(s),
            "ELECTRIC_CURRENT_UNIT" => map(ElectricCurrentUnit_::parse, Entity::ElectricCurrentUnit)(s),
            "ELEMENT_DELIVERY" => map(ElementDelivery_::parse, Entity::ElementDelivery)(s),
            "ELEMENTARY_SURFACE" => map(ElementarySurface_::parse, Entity::ElementarySurface)(s),
            "ELLIPSE" => map(Ellipse_::parse, Entity::Ellipse)(s),
            "ENVIRONMENT" => map(Environment_::parse, Entity::Environment)(s),
            "EQUALS_EXPRESSION" => map(EqualsExpression_::parse, Entity::EqualsExpression)(s),
            "EVALUATED_DEGENERATE_PCURVE" => map(EvaluatedDegeneratePcurve_::parse, Entity::EvaluatedDegeneratePcurve)(s),
            "EVENT_OCCURRENCE" => map(EventOccurrence_::parse, Entity::EventOccurrence)(s),
            "EVENT_OCCURRENCE_ASSIGNMENT" => map(EventOccurrenceAssignment_::parse, Entity::EventOccurrenceAssignment)(s),
            "EVENT_OCCURRENCE_CONTEXT_ASSIGNMENT" => map(EventOccurrenceContextAssignment_::parse, Entity::EventOccurrenceContextAssignment)(s),
            "EVENT_OCCURRENCE_CONTEXT_ROLE" => map(EventOccurrenceContextRole_::parse, Entity::EventOccurrenceContextRole)(s),
            "EVENT_OCCURRENCE_ROLE" => map(EventOccurrenceRole_::parse, Entity::EventOccurrenceRole)(s),
            "EXCLUSIVE_PRODUCT_CONCEPT_FEATURE_CATEGORY" => map(ExclusiveProductConceptFeatureCategory_::parse, Entity::ExclusiveProductConceptFeatureCategory)(s),
            "EXECUTED_ACTION" => map(ExecutedAction_::parse, Entity::ExecutedAction)(s),
            "EXP_FUNCTION" => map(ExpFunction_::parse, Entity::ExpFunction)(s),
            "EXPRESSION" => map(Expression_::parse, Entity::Expression)(s),
            "EXPRESSION_CONVERSION_BASED_UNIT" => map(ExpressionConversionBasedUnit_::parse, Entity::ExpressionConversionBasedUnit)(s),
            "EXTENSION" => map(Extension_::parse, Entity::Extension)(s),
            "EXTERNAL_IDENTIFICATION_ASSIGNMENT" => map(ExternalIdentificationAssignment_::parse, Entity::ExternalIdentificationAssignment)(s),
            "EXTERNAL_SOURCE" => map(ExternalSource_::parse, Entity::ExternalSource)(s),
            "EXTERNALLY_DEFINED_CHARACTER_GLYPH" => map(ExternallyDefinedCharacterGlyph_::parse, Entity::ExternallyDefinedCharacterGlyph)(s),
            "EXTERNALLY_DEFINED_CLASS" => map(ExternallyDefinedClass_::parse, Entity::ExternallyDefinedClass)(s),
            "EXTERNALLY_DEFINED_CURVE_FONT" => map(ExternallyDefinedCurveFont_::parse, Entity::ExternallyDefinedCurveFont)(s),
            "EXTERNALLY_DEFINED_DIMENSION_DEFINITION" => map(ExternallyDefinedDimensionDefinition_::parse, Entity::ExternallyDefinedDimensionDefinition)(s),
            "EXTERNALLY_DEFINED_FEATURE_DEFINITION" => map(ExternallyDefinedFeatureDefinition_::parse, Entity::ExternallyDefinedFeatureDefinition)(s),
            "EXTERNALLY_DEFINED_GENERAL_PROPERTY" => map(ExternallyDefinedGeneralProperty_::parse, Entity::ExternallyDefinedGeneralProperty)(s),
            "EXTERNALLY_DEFINED_HATCH_STYLE" => map(ExternallyDefinedHatchStyle_::parse, Entity::ExternallyDefinedHatchStyle)(s),
            "EXTERNALLY_DEFINED_ITEM" => map(ExternallyDefinedItem_::parse, Entity::ExternallyDefinedItem)(s),
            "EXTERNALLY_DEFINED_ITEM_RELATIONSHIP" => map(ExternallyDefinedItemRelationship_::parse, Entity::ExternallyDefinedItemRelationship)(s),
            "EXTERNALLY_DEFINED_STYLE" => map(ExternallyDefinedStyle_::parse, Entity::ExternallyDefinedStyle)(s),
            "EXTERNALLY_DEFINED_SYMBOL" => map(ExternallyDefinedSymbol_::parse, Entity::ExternallyDefinedSymbol)(s),
            "EXTERNALLY_DEFINED_TEXT_FONT" => map(ExternallyDefinedTextFont_::parse, Entity::ExternallyDefinedTextFont)(s),
            "EXTERNALLY_DEFINED_TILE_STYLE" => map(ExternallyDefinedTileStyle_::parse, Entity::ExternallyDefinedTileStyle)(s),
            "EXTRUDED_AREA_SOLID" => map(ExtrudedAreaSolid_::parse, Entity::ExtrudedAreaSolid)(s),
            "EXTRUDED_FACE_SOLID" => map(ExtrudedFaceSolid_::parse, Entity::ExtrudedFaceSolid)(s),
            "FACE" => map(Face_::parse, Entity::Face)(s),
            "FACE_BASED_SURFACE_MODEL" => map(FaceBasedSurfaceModel_::parse, Entity::FaceBasedSurfaceModel)(s),
            "FACE_BOUND" => map(FaceBound_::parse, Entity::FaceBound)(s),
            "FACE_OUTER_BOUND" => map(FaceOuterBound_::parse, Entity::FaceOuterBound)(s),
            "FACE_SHAPE_REPRESENTATION" => map(FaceShapeRepresentation_::parse, Entity::FaceShapeRepresentation)(s),
            "FACE_SURFACE" => map(FaceSurface_::parse, Entity::FaceSurface)(s),
            "FACETED_BREP" => map(FacetedBrep_::parse, Entity::FacetedBrep)(s),
            "FACETED_BREP_SHAPE_REPRESENTATION" => map(FacetedBrepShapeRepresentation_::parse, Entity::FacetedBrepShapeRepresentation)(s),
            "FEATURE_COMPONENT_DEFINITION" => map(FeatureComponentDefinition_::parse, Entity::FeatureComponentDefinition)(s),
            "FEATURE_COMPONENT_RELATIONSHIP" => map(FeatureComponentRelationship_::parse, Entity::FeatureComponentRelationship)(s),
            "FEATURE_DEFINITION" => map(FeatureDefinition_::parse, Entity::FeatureDefinition)(s),
            "FEATURE_IN_PANEL" => map(FeatureInPanel_::parse, Entity::FeatureInPanel)(s),
            "FEATURE_PATTERN" => map(FeaturePattern_::parse, Entity::FeaturePattern)(s),
            "FEATURED_SHAPE" => map(FeaturedShape_::parse, Entity::FeaturedShape)(s),
            "FILL_AREA_STYLE" => map(FillAreaStyle_::parse, Entity::FillAreaStyle)(s),
            "FILL_AREA_STYLE_COLOUR" => map(FillAreaStyleColour_::parse, Entity::FillAreaStyleColour)(s),
            "FILL_AREA_STYLE_HATCHING" => map(FillAreaStyleHatching_::parse, Entity::FillAreaStyleHatching)(s),
            "FILL_AREA_STYLE_TILE_SYMBOL_WITH_STYLE" => map(FillAreaStyleTileSymbolWithStyle_::parse, Entity::FillAreaStyleTileSymbolWithStyle)(s),
            "FILL_AREA_STYLE_TILES" => map(FillAreaStyleTiles_::parse, Entity::FillAreaStyleTiles)(s),
            "FILLET" => map(Fillet_::parse, Entity::Fillet)(s),
            "FLATNESS_TOLERANCE" => map(FlatnessTolerance_::parse, Entity::FlatnessTolerance)(s),
            "FORMAT_FUNCTION" => map(FormatFunction_::parse, Entity::FormatFunction)(s),
            "FOUNDED_ITEM" => map(FoundedItem_::parse, Entity::FoundedItem)(s),
            "FOUNDED_KINEMATIC_PATH" => map(FoundedKinematicPath_::parse, Entity::FoundedKinematicPath)(s),
            "FULLY_CONSTRAINED_PAIR" => map(FullyConstrainedPair_::parse, Entity::FullyConstrainedPair)(s),
            "FUNCTIONALLY_DEFINED_TRANSFORMATION" => map(FunctionallyDefinedTransformation_::parse, Entity::FunctionallyDefinedTransformation)(s),
            "GEAR_PAIR" => map(GearPair_::parse, Entity::GearPair)(s),
            "GEAR_PAIR_RANGE" => map(GearPairRange_::parse, Entity::GearPairRange)(s),
            "GEAR_PAIR_VALUE" => map(GearPairValue_::parse, Entity::GearPairValue)(s),
            "GENERAL_FEATURE" => map(GeneralFeature_::parse, Entity::GeneralFeature)(s),
            "GENERAL_MATERIAL_PROPERTY" => map(GeneralMaterialProperty_::parse, Entity::GeneralMaterialProperty)(s),
            "GENERAL_PROPERTY" => map(GeneralProperty_::parse, Entity::GeneralProperty)(s),
            "GENERAL_PROPERTY_ASSOCIATION" => map(GeneralPropertyAssociation_::parse, Entity::GeneralPropertyAssociation)(s),
            "GENERAL_PROPERTY_RELATIONSHIP" => map(GeneralPropertyRelationship_::parse, Entity::GeneralPropertyRelationship)(s),
            "GENERIC_CHARACTER_GLYPH_SYMBOL" => map(GenericCharacterGlyphSymbol_::parse, Entity::GenericCharacterGlyphSymbol)(s),
            "GENERIC_EXPRESSION" => map(GenericExpression_::parse, Entity::GenericExpression)(s),
            "GENERIC_LITERAL" => map(GenericLiteral_::parse, Entity::GenericLiteral)(s),
            "GENERIC_VARIABLE" => map(GenericVariable_::parse, Entity::GenericVariable)(s),
            "GEOMETRIC_ALIGNMENT" => map(GeometricAlignment_::parse, Entity::GeometricAlignment)(s),
            "GEOMETRIC_CURVE_SET" => map(GeometricCurveSet_::parse, Entity::GeometricCurveSet)(s),
            "GEOMETRIC_INTERSECTION" => map(GeometricIntersection_::parse, Entity::GeometricIntersection)(s),
            "GEOMETRIC_ITEM_SPECIFIC_USAGE" => map(GeometricItemSpecificUsage_::parse, Entity::GeometricItemSpecificUsage)(s),
            "GEOMETRIC_REPRESENTATION_CONTEXT" => map(GeometricRepresentationContext_::parse, Entity::GeometricRepresentationContext)(s),
            "GEOMETRIC_REPRESENTATION_ITEM" => map(GeometricRepresentationItem_::parse, Entity::GeometricRepresentationItem)(s),
            "GEOMETRIC_SET" => map(GeometricSet_::parse, Entity::GeometricSet)(s),
            "GEOMETRIC_TOLERANCE" => map(GeometricTolerance_::parse, Entity::GeometricTolerance)(s),
            "GEOMETRIC_TOLERANCE_RELATIONSHIP" => map(GeometricToleranceRelationship_::parse, Entity::GeometricToleranceRelationship)(s),
            "GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE" => map(GeometricToleranceWithDatumReference_::parse, Entity::GeometricToleranceWithDatumReference)(s),
            "GEOMETRIC_TOLERANCE_WITH_DEFINED_UNIT" => map(GeometricToleranceWithDefinedUnit_::parse, Entity::GeometricToleranceWithDefinedUnit)(s),
            "GEOMETRICAL_TOLERANCE_CALLOUT" => map(GeometricalToleranceCallout_::parse, Entity::GeometricalToleranceCallout)(s),
            "GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION" => map(GeometricallyBounded2dWireframeRepresentation_::parse, Entity::GeometricallyBounded2dWireframeRepresentation)(s),
            "GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION" => map(GeometricallyBoundedSurfaceShapeRepresentation_::parse, Entity::GeometricallyBoundedSurfaceShapeRepresentation)(s),
            "GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION" => map(GeometricallyBoundedWireframeShapeRepresentation_::parse, Entity::GeometricallyBoundedWireframeShapeRepresentation)(s),
            "GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT" => map(GlobalUncertaintyAssignedContext_::parse, Entity::GlobalUncertaintyAssignedContext)(s),
            "GLOBAL_UNIT_ASSIGNED_CONTEXT" => map(GlobalUnitAssignedContext_::parse, Entity::GlobalUnitAssignedContext)(s),
            "GROUP" => map(Group_::parse, Entity::Group)(s),
            "GROUP_ASSIGNMENT" => map(GroupAssignment_::parse, Entity::GroupAssignment)(s),
            "GROUP_RELATIONSHIP" => map(GroupRelationship_::parse, Entity::GroupRelationship)(s),
            "HALF_SPACE_SOLID" => map(HalfSpaceSolid_::parse, Entity::HalfSpaceSolid)(s),
            "HARDNESS_REPRESENTATION" => map(HardnessRepresentation_::parse, Entity::HardnessRepresentation)(s),
            "HIDDEN_ELEMENT_OVER_RIDING_STYLED_ITEM" => map(HiddenElementOverRidingStyledItem_::parse, Entity::HiddenElementOverRidingStyledItem)(s),
            "HOLE_BOTTOM" => map(HoleBottom_::parse, Entity::HoleBottom)(s),
            "HOLE_IN_PANEL" => map(HoleInPanel_::parse, Entity::HoleInPanel)(s),
            "HOMOKINETIC_PAIR" => map(HomokineticPair_::parse, Entity::HomokineticPair)(s),
            "HYPERBOLA" => map(Hyperbola_::parse, Entity::Hyperbola)(s),
            "ID_ATTRIBUTE" => map(IdAttribute_::parse, Entity::IdAttribute)(s),
            "IDENTIFICATION_ASSIGNMENT" => map(IdentificationAssignment_::parse, Entity::IdentificationAssignment)(s),
            "IDENTIFICATION_ROLE" => map(IdentificationRole_::parse, Entity::IdentificationRole)(s),
            "INCLUSION_PRODUCT_CONCEPT_FEATURE" => map(InclusionProductConceptFeature_::parse, Entity::InclusionProductConceptFeature)(s),
            "INDEX_EXPRESSION" => map(IndexExpression_::parse, Entity::IndexExpression)(s),
            "INITIAL_STATE" => map(InitialState_::parse, Entity::InitialState)(s),
            "INSTANCED_FEATURE" => map(InstancedFeature_::parse, Entity::InstancedFeature)(s),
            "INT_LITERAL" => map(IntLiteral_::parse, Entity::IntLiteral)(s),
            "INT_NUMERIC_VARIABLE" => map(IntNumericVariable_::parse, Entity::IntNumericVariable)(s),
            "INT_VALUE_FUNCTION" => map(IntValueFunction_::parse, Entity::IntValueFunction)(s),
            "INTEGER_DEFINED_FUNCTION" => map(IntegerDefinedFunction_::parse, Entity::IntegerDefinedFunction)(s),
            "INTERPOLATED_CONFIGURATION_SEQUENCE" => map(InterpolatedConfigurationSequence_::parse, Entity::InterpolatedConfigurationSequence)(s),
            "INTERSECTION_CURVE" => map(IntersectionCurve_::parse, Entity::IntersectionCurve)(s),
            "INTERVAL_EXPRESSION" => map(IntervalExpression_::parse, Entity::IntervalExpression)(s),
            "INVISIBILITY" => map(Invisibility_::parse, Entity::Invisibility)(s),
            "ITEM_DEFINED_TRANSFORMATION" => map(ItemDefinedTransformation_::parse, Entity::ItemDefinedTransformation)(s),
            "ITEM_IDENTIFIED_REPRESENTATION_USAGE" => map(ItemIdentifiedRepresentationUsage_::parse, Entity::ItemIdentifiedRepresentationUsage)(s),
            "JOGGLE" => map(Joggle_::parse, Entity::Joggle)(s),
            "JOGGLE_TERMINATION" => map(JoggleTermination_::parse, Entity::JoggleTermination)(s),
            "KINEMATIC_ANALYSIS_CONSISTENCY" => map(KinematicAnalysisConsistency_::parse, Entity::KinematicAnalysisConsistency)(s),
            "KINEMATIC_ANALYSIS_RESULT" => map(KinematicAnalysisResult_::parse, Entity::KinematicAnalysisResult)(s),
            "KINEMATIC_CONTROL" => map(KinematicControl_::parse, Entity::KinematicControl)(s),
            "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION" => map(KinematicFrameBackgroundRepresentation_::parse, Entity::KinematicFrameBackgroundRepresentation)(s),
            "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION_ASSOCIATION" => map(KinematicFrameBackgroundRepresentationAssociation_::parse, Entity::KinematicFrameBackgroundRepresentationAssociation)(s),
            "KINEMATIC_FRAME_BASED_TRANSFORMATION" => map(KinematicFrameBasedTransformation_::parse, Entity::KinematicFrameBasedTransformation)(s),
            "KINEMATIC_GROUND_REPRESENTATION" => map(KinematicGroundRepresentation_::parse, Entity::KinematicGroundRepresentation)(s),
            "KINEMATIC_JOINT" => map(KinematicJoint_::parse, Entity::KinematicJoint)(s),
            "KINEMATIC_LINK" => map(KinematicLink_::parse, Entity::KinematicLink)(s),
            "KINEMATIC_LINK_REPRESENTATION" => map(KinematicLinkRepresentation_::parse, Entity::KinematicLinkRepresentation)(s),
            "KINEMATIC_LINK_REPRESENTATION_ASSOCIATION" => map(KinematicLinkRepresentationAssociation_::parse, Entity::KinematicLinkRepresentationAssociation)(s),
            "KINEMATIC_LINK_REPRESENTATION_RELATION" => map(KinematicLinkRepresentationRelation_::parse, Entity::KinematicLinkRepresentationRelation)(s),
            "KINEMATIC_PAIR" => map(KinematicPair_::parse, Entity::KinematicPair)(s),
            "KINEMATIC_PATH" => map(KinematicPath_::parse, Entity::KinematicPath)(s),
            "KINEMATIC_PROPERTY_DEFINITION" => map(KinematicPropertyDefinition_::parse, Entity::KinematicPropertyDefinition)(s),
            "KINEMATIC_PROPERTY_REPRESENTATION_RELATION" => map(KinematicPropertyRepresentationRelation_::parse, Entity::KinematicPropertyRepresentationRelation)(s),
            "KINEMATIC_STRUCTURE" => map(KinematicStructure_::parse, Entity::KinematicStructure)(s),
            "KNOWN_SOURCE" => map(KnownSource_::parse, Entity::KnownSource)(s),
            "LANGUAGE" => map(Language_::parse, Entity::Language)(s),
            "LANGUAGE_ASSIGNMENT" => map(LanguageAssignment_::parse, Entity::LanguageAssignment)(s),
            "LEADER_CURVE" => map(LeaderCurve_::parse, Entity::LeaderCurve)(s),
            "LEADER_DIRECTED_CALLOUT" => map(LeaderDirectedCallout_::parse, Entity::LeaderDirectedCallout)(s),
            "LEADER_DIRECTED_DIMENSION" => map(LeaderDirectedDimension_::parse, Entity::LeaderDirectedDimension)(s),
            "LEADER_TERMINATOR" => map(LeaderTerminator_::parse, Entity::LeaderTerminator)(s),
            "LENGTH_FUNCTION" => map(LengthFunction_::parse, Entity::LengthFunction)(s),
            "LENGTH_MEASURE_WITH_UNIT" => map(LengthMeasureWithUnit_::parse, Entity::LengthMeasureWithUnit)(s),
            "LENGTH_UNIT" => map(LengthUnit_::parse, Entity::LengthUnit)(s),
            "LIGHT_SOURCE" => map(LightSource_::parse, Entity::LightSource)(s),
            "LIGHT_SOURCE_AMBIENT" => map(LightSourceAmbient_::parse, Entity::LightSourceAmbient)(s),
            "LIGHT_SOURCE_DIRECTIONAL" => map(LightSourceDirectional_::parse, Entity::LightSourceDirectional)(s),
            "LIGHT_SOURCE_POSITIONAL" => map(LightSourcePositional_::parse, Entity::LightSourcePositional)(s),
            "LIGHT_SOURCE_SPOT" => map(LightSourceSpot_::parse, Entity::LightSourceSpot)(s),
            "LIKE_EXPRESSION" => map(LikeExpression_::parse, Entity::LikeExpression)(s),
            "LIMITS_AND_FITS" => map(LimitsAndFits_::parse, Entity::LimitsAndFits)(s),
            "LINE" => map(Line_::parse, Entity::Line)(s),
            "LINE_PROFILE_TOLERANCE" => map(LineProfileTolerance_::parse, Entity::LineProfileTolerance)(s),
            "LINEAR_DIMENSION" => map(LinearDimension_::parse, Entity::LinearDimension)(s),
            "LITERAL_NUMBER" => map(LiteralNumber_::parse, Entity::LiteralNumber)(s),
            "LOCAL_TIME" => map(LocalTime_::parse, Entity::LocalTime)(s),
            "LOCATION_SHAPE_REPRESENTATION" => map(LocationShapeRepresentation_::parse, Entity::LocationShapeRepresentation)(s),
            "LOCATOR" => map(Locator_::parse, Entity::Locator)(s),
            "LOG10_FUNCTION" => map(Log10Function_::parse, Entity::Log10Function)(s),
            "LOG2_FUNCTION" => map(Log2Function_::parse, Entity::Log2Function)(s),
            "LOG_FUNCTION" => map(LogFunction_::parse, Entity::LogFunction)(s),
            "LOOP" => map(Loop_::parse, Entity::Loop)(s),
            "LOT_EFFECTIVITY" => map(LotEffectivity_::parse, Entity::LotEffectivity)(s),
            "LUMINOUS_INTENSITY_MEASURE_WITH_UNIT" => map(LuminousIntensityMeasureWithUnit_::parse, Entity::LuminousIntensityMeasureWithUnit)(s),
            "LUMINOUS_INTENSITY_UNIT" => map(LuminousIntensityUnit_::parse, Entity::LuminousIntensityUnit)(s),
            "MAKE_FROM_USAGE_OPTION" => map(MakeFromUsageOption_::parse, Entity::MakeFromUsageOption)(s),
            "MANIFOLD_SOLID_BREP" => map(ManifoldSolidBrep_::parse, Entity::ManifoldSolidBrep)(s),
            "MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION" => map(ManifoldSubsurfaceShapeRepresentation_::parse, Entity::ManifoldSubsurfaceShapeRepresentation)(s),
            "MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => map(ManifoldSurfaceShapeRepresentation_::parse, Entity::ManifoldSurfaceShapeRepresentation)(s),
            "MAPPED_ITEM" => map(MappedItem_::parse, Entity::MappedItem)(s),
            "MASS_MEASURE_WITH_UNIT" => map(MassMeasureWithUnit_::parse, Entity::MassMeasureWithUnit)(s),
            "MASS_UNIT" => map(MassUnit_::parse, Entity::MassUnit)(s),
            "MATERIAL_DESIGNATION" => map(MaterialDesignation_::parse, Entity::MaterialDesignation)(s),
            "MATERIAL_DESIGNATION_CHARACTERIZATION" => map(MaterialDesignationCharacterization_::parse, Entity::MaterialDesignationCharacterization)(s),
            "MATERIAL_PROPERTY" => map(MaterialProperty_::parse, Entity::MaterialProperty)(s),
            "MATERIAL_PROPERTY_REPRESENTATION" => map(MaterialPropertyRepresentation_::parse, Entity::MaterialPropertyRepresentation)(s),
            "MAXIMUM_FUNCTION" => map(MaximumFunction_::parse, Entity::MaximumFunction)(s),
            "MEASURE_QUALIFICATION" => map(MeasureQualification_::parse, Entity::MeasureQualification)(s),
            "MEASURE_REPRESENTATION_ITEM" => map(MeasureRepresentationItem_::parse, Entity::MeasureRepresentationItem)(s),
            "MEASURE_WITH_UNIT" => map(MeasureWithUnit_::parse, Entity::MeasureWithUnit)(s),
            "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_AREA" => map(MechanicalDesignGeometricPresentationArea_::parse, Entity::MechanicalDesignGeometricPresentationArea)(s),
            "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION" => map(MechanicalDesignGeometricPresentationRepresentation_::parse, Entity::MechanicalDesignGeometricPresentationRepresentation)(s),
            "MECHANISM" => map(Mechanism_::parse, Entity::Mechanism)(s),
            "MECHANISM_BASE_PLACEMENT" => map(MechanismBasePlacement_::parse, Entity::MechanismBasePlacement)(s),
            "MINIMUM_FUNCTION" => map(MinimumFunction_::parse, Entity::MinimumFunction)(s),
            "MINUS_EXPRESSION" => map(MinusExpression_::parse, Entity::MinusExpression)(s),
            "MINUS_FUNCTION" => map(MinusFunction_::parse, Entity::MinusFunction)(s),
            "MOD_EXPRESSION" => map(ModExpression_::parse, Entity::ModExpression)(s),
            "MODIFIED_GEOMETRIC_TOLERANCE" => map(ModifiedGeometricTolerance_::parse, Entity::ModifiedGeometricTolerance)(s),
            "MODIFIED_PATTERN" => map(ModifiedPattern_::parse, Entity::ModifiedPattern)(s),
            "MOMENTS_OF_INERTIA_REPRESENTATION" => map(MomentsOfInertiaRepresentation_::parse, Entity::MomentsOfInertiaRepresentation)(s),
            "MOTION_LINK_RELATIONSHIP" => map(MotionLinkRelationship_::parse, Entity::MotionLinkRelationship)(s),
            "MULT_EXPRESSION" => map(MultExpression_::parse, Entity::MultExpression)(s),
            "MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT" => map(MultiLanguageAttributeAssignment_::parse, Entity::MultiLanguageAttributeAssignment)(s),
            "MULTIPLE_ARITY_BOOLEAN_EXPRESSION" => map(MultipleArityBooleanExpression_::parse, Entity::MultipleArityBooleanExpression)(s),
            "MULTIPLE_ARITY_FUNCTION_CALL" => map(MultipleArityFunctionCall_::parse, Entity::MultipleArityFunctionCall)(s),
            "MULTIPLE_ARITY_GENERIC_EXPRESSION" => map(MultipleArityGenericExpression_::parse, Entity::MultipleArityGenericExpression)(s),
            "MULTIPLE_ARITY_NUMERIC_EXPRESSION" => map(MultipleArityNumericExpression_::parse, Entity::MultipleArityNumericExpression)(s),
            "NAME_ASSIGNMENT" => map(NameAssignment_::parse, Entity::NameAssignment)(s),
            "NAME_ATTRIBUTE" => map(NameAttribute_::parse, Entity::NameAttribute)(s),
            "NAMED_UNIT" => map(NamedUnit_::parse, Entity::NamedUnit)(s),
            "NAMED_UNIT_VARIABLE" => map(NamedUnitVariable_::parse, Entity::NamedUnitVariable)(s),
            "NEXT_ASSEMBLY_USAGE_OCCURRENCE" => map(NextAssemblyUsageOccurrence_::parse, Entity::NextAssemblyUsageOccurrence)(s),
            "NGON_CLOSED_PROFILE" => map(NgonClosedProfile_::parse, Entity::NgonClosedProfile)(s),
            "NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => map(NonManifoldSurfaceShapeRepresentation_::parse, Entity::NonManifoldSurfaceShapeRepresentation)(s),
            "NOT_EXPRESSION" => map(NotExpression_::parse, Entity::NotExpression)(s),
            "NUMERIC_DEFINED_FUNCTION" => map(NumericDefinedFunction_::parse, Entity::NumericDefinedFunction)(s),
            "NUMERIC_EXPRESSION" => map(NumericExpression_::parse, Entity::NumericExpression)(s),
            "NUMERIC_VARIABLE" => map(NumericVariable_::parse, Entity::NumericVariable)(s),
            "OBJECT_ROLE" => map(ObjectRole_::parse, Entity::ObjectRole)(s),
            "ODD_FUNCTION" => map(OddFunction_::parse, Entity::OddFunction)(s),
            "OFFSET_CURVE_2D" => map(OffsetCurve2d_::parse, Entity::OffsetCurve2d)(s),
            "OFFSET_CURVE_3D" => map(OffsetCurve3d_::parse, Entity::OffsetCurve3d)(s),
            "OFFSET_SURFACE" => map(OffsetSurface_::parse, Entity::OffsetSurface)(s),
            "ONE_DIRECTION_REPEAT_FACTOR" => map(OneDirectionRepeatFactor_::parse, Entity::OneDirectionRepeatFactor)(s),
            "OPEN_PATH_PROFILE" => map(OpenPathProfile_::parse, Entity::OpenPathProfile)(s),
            "OPEN_SHELL" => map(OpenShell_::parse, Entity::OpenShell)(s),
            "OR_EXPRESSION" => map(OrExpression_::parse, Entity::OrExpression)(s),
            "ORDINATE_DIMENSION" => map(OrdinateDimension_::parse, Entity::OrdinateDimension)(s),
            "ORGANIZATION" => map(Organization_::parse, Entity::Organization)(s),
            "ORGANIZATION_ASSIGNMENT" => map(OrganizationAssignment_::parse, Entity::OrganizationAssignment)(s),
            "ORGANIZATION_RELATIONSHIP" => map(OrganizationRelationship_::parse, Entity::OrganizationRelationship)(s),
            "ORGANIZATION_ROLE" => map(OrganizationRole_::parse, Entity::OrganizationRole)(s),
            "ORGANIZATIONAL_ADDRESS" => map(OrganizationalAddress_::parse, Entity::OrganizationalAddress)(s),
            "ORGANIZATIONAL_PROJECT" => map(OrganizationalProject_::parse, Entity::OrganizationalProject)(s),
            "ORGANIZATIONAL_PROJECT_ASSIGNMENT" => map(OrganizationalProjectAssignment_::parse, Entity::OrganizationalProjectAssignment)(s),
            "ORGANIZATIONAL_PROJECT_RELATIONSHIP" => map(OrganizationalProjectRelationship_::parse, Entity::OrganizationalProjectRelationship)(s),
            "ORGANIZATIONAL_PROJECT_ROLE" => map(OrganizationalProjectRole_::parse, Entity::OrganizationalProjectRole)(s),
            "ORIENTED_CLOSED_SHELL" => map(OrientedClosedShell_::parse, Entity::OrientedClosedShell)(s),
            "ORIENTED_EDGE" => map(OrientedEdge_::parse, Entity::OrientedEdge)(s),
            "ORIENTED_FACE" => map(OrientedFace_::parse, Entity::OrientedFace)(s),
            "ORIENTED_OPEN_SHELL" => map(OrientedOpenShell_::parse, Entity::OrientedOpenShell)(s),
            "ORIENTED_PATH" => map(OrientedPath_::parse, Entity::OrientedPath)(s),
            "ORIENTED_SURFACE" => map(OrientedSurface_::parse, Entity::OrientedSurface)(s),
            "OUTER_BOUNDARY_CURVE" => map(OuterBoundaryCurve_::parse, Entity::OuterBoundaryCurve)(s),
            "OVER_RIDING_STYLED_ITEM" => map(OverRidingStyledItem_::parse, Entity::OverRidingStyledItem)(s),
            "PACKAGE_PRODUCT_CONCEPT_FEATURE" => map(PackageProductConceptFeature_::parse, Entity::PackageProductConceptFeature)(s),
            "PAIR_ACTUATOR" => map(PairActuator_::parse, Entity::PairActuator)(s),
            "PAIR_VALUE" => map(PairValue_::parse, Entity::PairValue)(s),
            "PARABOLA" => map(Parabola_::parse, Entity::Parabola)(s),
            "PARALLEL_OFFSET" => map(ParallelOffset_::parse, Entity::ParallelOffset)(s),
            "PARALLELISM_TOLERANCE" => map(ParallelismTolerance_::parse, Entity::ParallelismTolerance)(s),
            "PARAMETRIC_REPRESENTATION_CONTEXT" => map(ParametricRepresentationContext_::parse, Entity::ParametricRepresentationContext)(s),
            "PARTIAL_CIRCULAR_PROFILE" => map(PartialCircularProfile_::parse, Entity::PartialCircularProfile)(s),
            "PATH" => map(Path_::parse, Entity::Path)(s),
            "PATH_FEATURE_COMPONENT" => map(PathFeatureComponent_::parse, Entity::PathFeatureComponent)(s),
            "PATH_SHAPE_REPRESENTATION" => map(PathShapeRepresentation_::parse, Entity::PathShapeRepresentation)(s),
            "PATTERN_OFFSET_MEMBERSHIP" => map(PatternOffsetMembership_::parse, Entity::PatternOffsetMembership)(s),
            "PATTERN_OMIT_MEMBERSHIP" => map(PatternOmitMembership_::parse, Entity::PatternOmitMembership)(s),
            "PCURVE" => map(Pcurve_::parse, Entity::Pcurve)(s),
            "PERPENDICULAR_TO" => map(PerpendicularTo_::parse, Entity::PerpendicularTo)(s),
            "PERPENDICULARITY_TOLERANCE" => map(PerpendicularityTolerance_::parse, Entity::PerpendicularityTolerance)(s),
            "PERSON" => map(Person_::parse, Entity::Person)(s),
            "PERSON_AND_ORGANIZATION" => map(PersonAndOrganization_::parse, Entity::PersonAndOrganization)(s),
            "PERSON_AND_ORGANIZATION_ADDRESS" => map(PersonAndOrganizationAddress_::parse, Entity::PersonAndOrganizationAddress)(s),
            "PERSON_AND_ORGANIZATION_ASSIGNMENT" => map(PersonAndOrganizationAssignment_::parse, Entity::PersonAndOrganizationAssignment)(s),
            "PERSON_AND_ORGANIZATION_ROLE" => map(PersonAndOrganizationRole_::parse, Entity::PersonAndOrganizationRole)(s),
            "PERSONAL_ADDRESS" => map(PersonalAddress_::parse, Entity::PersonalAddress)(s),
            "PHYSICALLY_MODELLED_PRODUCT_DEFINITION" => map(PhysicallyModelledProductDefinition_::parse, Entity::PhysicallyModelledProductDefinition)(s),
            "PLACED_DATUM_TARGET_FEATURE" => map(PlacedDatumTargetFeature_::parse, Entity::PlacedDatumTargetFeature)(s),
            "PLACED_FEATURE" => map(PlacedFeature_::parse, Entity::PlacedFeature)(s),
            "PLACEMENT" => map(Placement_::parse, Entity::Placement)(s),
            "PLANAR_BOX" => map(PlanarBox_::parse, Entity::PlanarBox)(s),
            "PLANAR_CURVE_PAIR" => map(PlanarCurvePair_::parse, Entity::PlanarCurvePair)(s),
            "PLANAR_CURVE_PAIR_RANGE" => map(PlanarCurvePairRange_::parse, Entity::PlanarCurvePairRange)(s),
            "PLANAR_EXTENT" => map(PlanarExtent_::parse, Entity::PlanarExtent)(s),
            "PLANAR_PAIR" => map(PlanarPair_::parse, Entity::PlanarPair)(s),
            "PLANAR_PAIR_RANGE" => map(PlanarPairRange_::parse, Entity::PlanarPairRange)(s),
            "PLANAR_PAIR_VALUE" => map(PlanarPairValue_::parse, Entity::PlanarPairValue)(s),
            "PLANAR_SHAPE_REPRESENTATION" => map(PlanarShapeRepresentation_::parse, Entity::PlanarShapeRepresentation)(s),
            "PLANE" => map(Plane_::parse, Entity::Plane)(s),
            "PLANE_ANGLE_MEASURE_WITH_UNIT" => map(PlaneAngleMeasureWithUnit_::parse, Entity::PlaneAngleMeasureWithUnit)(s),
            "PLANE_ANGLE_UNIT" => map(PlaneAngleUnit_::parse, Entity::PlaneAngleUnit)(s),
            "PLUS_EXPRESSION" => map(PlusExpression_::parse, Entity::PlusExpression)(s),
            "PLUS_MINUS_TOLERANCE" => map(PlusMinusTolerance_::parse, Entity::PlusMinusTolerance)(s),
            "POCKET" => map(Pocket_::parse, Entity::Pocket)(s),
            "POCKET_BOTTOM" => map(PocketBottom_::parse, Entity::PocketBottom)(s),
            "POINT" => map(Point_::parse, Entity::Point)(s),
            "POINT_ON_CURVE" => map(PointOnCurve_::parse, Entity::PointOnCurve)(s),
            "POINT_ON_PLANAR_CURVE_PAIR" => map(PointOnPlanarCurvePair_::parse, Entity::PointOnPlanarCurvePair)(s),
            "POINT_ON_PLANAR_CURVE_PAIR_RANGE" => map(PointOnPlanarCurvePairRange_::parse, Entity::PointOnPlanarCurvePairRange)(s),
            "POINT_ON_PLANAR_CURVE_PAIR_VALUE" => map(PointOnPlanarCurvePairValue_::parse, Entity::PointOnPlanarCurvePairValue)(s),
            "POINT_ON_SURFACE" => map(PointOnSurface_::parse, Entity::PointOnSurface)(s),
            "POINT_ON_SURFACE_PAIR" => map(PointOnSurfacePair_::parse, Entity::PointOnSurfacePair)(s),
            "POINT_ON_SURFACE_PAIR_RANGE" => map(PointOnSurfacePairRange_::parse, Entity::PointOnSurfacePairRange)(s),
            "POINT_ON_SURFACE_PAIR_VALUE" => map(PointOnSurfacePairValue_::parse, Entity::PointOnSurfacePairValue)(s),
            "POINT_PLACEMENT_SHAPE_REPRESENTATION" => map(PointPlacementShapeRepresentation_::parse, Entity::PointPlacementShapeRepresentation)(s),
            "POINT_REPLICA" => map(PointReplica_::parse, Entity::PointReplica)(s),
            "POINT_STYLE" => map(PointStyle_::parse, Entity::PointStyle)(s),
            "POLY_LOOP" => map(PolyLoop_::parse, Entity::PolyLoop)(s),
            "POLYLINE" => map(Polyline_::parse, Entity::Polyline)(s),
            "POSITION_TOLERANCE" => map(PositionTolerance_::parse, Entity::PositionTolerance)(s),
            "POWER_EXPRESSION" => map(PowerExpression_::parse, Entity::PowerExpression)(s),
            "PRE_DEFINED_COLOUR" => map(PreDefinedColour_::parse, Entity::PreDefinedColour)(s),
            "PRE_DEFINED_CURVE_FONT" => map(PreDefinedCurveFont_::parse, Entity::PreDefinedCurveFont)(s),
            "PRE_DEFINED_DIMENSION_SYMBOL" => map(PreDefinedDimensionSymbol_::parse, Entity::PreDefinedDimensionSymbol)(s),
            "PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL" => map(PreDefinedGeometricalToleranceSymbol_::parse, Entity::PreDefinedGeometricalToleranceSymbol)(s),
            "PRE_DEFINED_ITEM" => map(PreDefinedItem_::parse, Entity::PreDefinedItem)(s),
            "PRE_DEFINED_MARKER" => map(PreDefinedMarker_::parse, Entity::PreDefinedMarker)(s),
            "PRE_DEFINED_POINT_MARKER_SYMBOL" => map(PreDefinedPointMarkerSymbol_::parse, Entity::PreDefinedPointMarkerSymbol)(s),
            "PRE_DEFINED_PRESENTATION_STYLE" => map(PreDefinedPresentationStyle_::parse, Entity::PreDefinedPresentationStyle)(s),
            "PRE_DEFINED_SURFACE_CONDITION_SYMBOL" => map(PreDefinedSurfaceConditionSymbol_::parse, Entity::PreDefinedSurfaceConditionSymbol)(s),
            "PRE_DEFINED_SYMBOL" => map(PreDefinedSymbol_::parse, Entity::PreDefinedSymbol)(s),
            "PRE_DEFINED_TERMINATOR_SYMBOL" => map(PreDefinedTerminatorSymbol_::parse, Entity::PreDefinedTerminatorSymbol)(s),
            "PRE_DEFINED_TEXT_FONT" => map(PreDefinedTextFont_::parse, Entity::PreDefinedTextFont)(s),
            "PRECISION_QUALIFIER" => map(PrecisionQualifier_::parse, Entity::PrecisionQualifier)(s),
            "PRESENTATION_AREA" => map(PresentationArea_::parse, Entity::PresentationArea)(s),
            "PRESENTATION_LAYER_ASSIGNMENT" => map(PresentationLayerAssignment_::parse, Entity::PresentationLayerAssignment)(s),
            "PRESENTATION_REPRESENTATION" => map(PresentationRepresentation_::parse, Entity::PresentationRepresentation)(s),
            "PRESENTATION_SET" => map(PresentationSet_::parse, Entity::PresentationSet)(s),
            "PRESENTATION_SIZE" => map(PresentationSize_::parse, Entity::PresentationSize)(s),
            "PRESENTATION_STYLE_ASSIGNMENT" => map(PresentationStyleAssignment_::parse, Entity::PresentationStyleAssignment)(s),
            "PRESENTATION_STYLE_BY_CONTEXT" => map(PresentationStyleByContext_::parse, Entity::PresentationStyleByContext)(s),
            "PRESENTATION_VIEW" => map(PresentationView_::parse, Entity::PresentationView)(s),
            "PRESENTED_ITEM" => map(PresentedItem_::parse, Entity::PresentedItem)(s),
            "PRESENTED_ITEM_REPRESENTATION" => map(PresentedItemRepresentation_::parse, Entity::PresentedItemRepresentation)(s),
            "PRISMATIC_PAIR" => map(PrismaticPair_::parse, Entity::PrismaticPair)(s),
            "PRISMATIC_PAIR_RANGE" => map(PrismaticPairRange_::parse, Entity::PrismaticPairRange)(s),
            "PRISMATIC_PAIR_VALUE" => map(PrismaticPairValue_::parse, Entity::PrismaticPairValue)(s),
            "PROCESS_OPERATION" => map(ProcessOperation_::parse, Entity::ProcessOperation)(s),
            "PROCESS_PLAN" => map(ProcessPlan_::parse, Entity::ProcessPlan)(s),
            "PROCESS_PRODUCT_ASSOCIATION" => map(ProcessProductAssociation_::parse, Entity::ProcessProductAssociation)(s),
            "PROCESS_PROPERTY_ASSOCIATION" => map(ProcessPropertyAssociation_::parse, Entity::ProcessPropertyAssociation)(s),
            "PRODUCT" => map(Product_::parse, Entity::Product)(s),
            "PRODUCT_CATEGORY" => map(ProductCategory_::parse, Entity::ProductCategory)(s),
            "PRODUCT_CATEGORY_RELATIONSHIP" => map(ProductCategoryRelationship_::parse, Entity::ProductCategoryRelationship)(s),
            "PRODUCT_CLASS" => map(ProductClass_::parse, Entity::ProductClass)(s),
            "PRODUCT_CONCEPT" => map(ProductConcept_::parse, Entity::ProductConcept)(s),
            "PRODUCT_CONCEPT_CONTEXT" => map(ProductConceptContext_::parse, Entity::ProductConceptContext)(s),
            "PRODUCT_CONCEPT_FEATURE" => map(ProductConceptFeature_::parse, Entity::ProductConceptFeature)(s),
            "PRODUCT_CONCEPT_FEATURE_ASSOCIATION" => map(ProductConceptFeatureAssociation_::parse, Entity::ProductConceptFeatureAssociation)(s),
            "PRODUCT_CONCEPT_FEATURE_CATEGORY" => map(ProductConceptFeatureCategory_::parse, Entity::ProductConceptFeatureCategory)(s),
            "PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE" => map(ProductConceptFeatureCategoryUsage_::parse, Entity::ProductConceptFeatureCategoryUsage)(s),
            "PRODUCT_CONCEPT_RELATIONSHIP" => map(ProductConceptRelationship_::parse, Entity::ProductConceptRelationship)(s),
            "PRODUCT_CONTEXT" => map(ProductContext_::parse, Entity::ProductContext)(s),
            "PRODUCT_DEFINITION" => map(ProductDefinition_::parse, Entity::ProductDefinition)(s),
            "PRODUCT_DEFINITION_CONTEXT" => map(ProductDefinitionContext_::parse, Entity::ProductDefinitionContext)(s),
            "PRODUCT_DEFINITION_CONTEXT_ASSOCIATION" => map(ProductDefinitionContextAssociation_::parse, Entity::ProductDefinitionContextAssociation)(s),
            "PRODUCT_DEFINITION_CONTEXT_ROLE" => map(ProductDefinitionContextRole_::parse, Entity::ProductDefinitionContextRole)(s),
            "PRODUCT_DEFINITION_EFFECTIVITY" => map(ProductDefinitionEffectivity_::parse, Entity::ProductDefinitionEffectivity)(s),
            "PRODUCT_DEFINITION_FORMATION" => map(ProductDefinitionFormation_::parse, Entity::ProductDefinitionFormation)(s),
            "PRODUCT_DEFINITION_FORMATION_RELATIONSHIP" => map(ProductDefinitionFormationRelationship_::parse, Entity::ProductDefinitionFormationRelationship)(s),
            "PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE" => map(ProductDefinitionFormationWithSpecifiedSource_::parse, Entity::ProductDefinitionFormationWithSpecifiedSource)(s),
            "PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP" => map(ProductDefinitionOccurrenceRelationship_::parse, Entity::ProductDefinitionOccurrenceRelationship)(s),
            "PRODUCT_DEFINITION_PROCESS" => map(ProductDefinitionProcess_::parse, Entity::ProductDefinitionProcess)(s),
            "PRODUCT_DEFINITION_RELATIONSHIP" => map(ProductDefinitionRelationship_::parse, Entity::ProductDefinitionRelationship)(s),
            "PRODUCT_DEFINITION_RESOURCE" => map(ProductDefinitionResource_::parse, Entity::ProductDefinitionResource)(s),
            "PRODUCT_DEFINITION_SHAPE" => map(ProductDefinitionShape_::parse, Entity::ProductDefinitionShape)(s),
            "PRODUCT_DEFINITION_SUBSTITUTE" => map(ProductDefinitionSubstitute_::parse, Entity::ProductDefinitionSubstitute)(s),
            "PRODUCT_DEFINITION_USAGE" => map(ProductDefinitionUsage_::parse, Entity::ProductDefinitionUsage)(s),
            "PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS" => map(ProductDefinitionWithAssociatedDocuments_::parse, Entity::ProductDefinitionWithAssociatedDocuments)(s),
            "PRODUCT_IDENTIFICATION" => map(ProductIdentification_::parse, Entity::ProductIdentification)(s),
            "PRODUCT_PROCESS_PLAN" => map(ProductProcessPlan_::parse, Entity::ProductProcessPlan)(s),
            "PRODUCT_RELATED_PRODUCT_CATEGORY" => map(ProductRelatedProductCategory_::parse, Entity::ProductRelatedProductCategory)(s),
            "PRODUCT_SPECIFICATION" => map(ProductSpecification_::parse, Entity::ProductSpecification)(s),
            "PROJECTED_ZONE_DEFINITION" => map(ProjectedZoneDefinition_::parse, Entity::ProjectedZoneDefinition)(s),
            "PROJECTION_CURVE" => map(ProjectionCurve_::parse, Entity::ProjectionCurve)(s),
            "PROJECTION_DIRECTED_CALLOUT" => map(ProjectionDirectedCallout_::parse, Entity::ProjectionDirectedCallout)(s),
            "PROMISSORY_USAGE_OCCURRENCE" => map(PromissoryUsageOccurrence_::parse, Entity::PromissoryUsageOccurrence)(s),
            "PROPERTY_DEFINITION" => map(PropertyDefinition_::parse, Entity::PropertyDefinition)(s),
            "PROPERTY_DEFINITION_RELATIONSHIP" => map(PropertyDefinitionRelationship_::parse, Entity::PropertyDefinitionRelationship)(s),
            "PROPERTY_DEFINITION_REPRESENTATION" => map(PropertyDefinitionRepresentation_::parse, Entity::PropertyDefinitionRepresentation)(s),
            "PROPERTY_PROCESS" => map(PropertyProcess_::parse, Entity::PropertyProcess)(s),
            "QUALIFIED_REPRESENTATION_ITEM" => map(QualifiedRepresentationItem_::parse, Entity::QualifiedRepresentationItem)(s),
            "QUALITATIVE_UNCERTAINTY" => map(QualitativeUncertainty_::parse, Entity::QualitativeUncertainty)(s),
            "QUANTIFIED_ASSEMBLY_COMPONENT_USAGE" => map(QuantifiedAssemblyComponentUsage_::parse, Entity::QuantifiedAssemblyComponentUsage)(s),
            "QUASI_UNIFORM_CURVE" => map(QuasiUniformCurve_::parse, Entity::QuasiUniformCurve)(s),
            "QUASI_UNIFORM_SURFACE" => map(QuasiUniformSurface_::parse, Entity::QuasiUniformSurface)(s),
            "RACK_AND_PINION_PAIR" => map(RackAndPinionPair_::parse, Entity::RackAndPinionPair)(s),
            "RACK_AND_PINION_PAIR_RANGE" => map(RackAndPinionPairRange_::parse, Entity::RackAndPinionPairRange)(s),
            "RACK_AND_PINION_PAIR_VALUE" => map(RackAndPinionPairValue_::parse, Entity::RackAndPinionPairValue)(s),
            "RADIUS_DIMENSION" => map(RadiusDimension_::parse, Entity::RadiusDimension)(s),
            "RATIO_MEASURE_WITH_UNIT" => map(RatioMeasureWithUnit_::parse, Entity::RatioMeasureWithUnit)(s),
            "RATIO_UNIT" => map(RatioUnit_::parse, Entity::RatioUnit)(s),
            "RATIONAL_B_SPLINE_CURVE" => map(RationalBSplineCurve_::parse, Entity::RationalBSplineCurve)(s),
            "RATIONAL_B_SPLINE_SURFACE" => map(RationalBSplineSurface_::parse, Entity::RationalBSplineSurface)(s),
            "REAL_DEFINED_FUNCTION" => map(RealDefinedFunction_::parse, Entity::RealDefinedFunction)(s),
            "REAL_LITERAL" => map(RealLiteral_::parse, Entity::RealLiteral)(s),
            "REAL_NUMERIC_VARIABLE" => map(RealNumericVariable_::parse, Entity::RealNumericVariable)(s),
            "RECTANGULAR_CLOSED_PROFILE" => map(RectangularClosedProfile_::parse, Entity::RectangularClosedProfile)(s),
            "RECTANGULAR_COMPOSITE_SURFACE" => map(RectangularCompositeSurface_::parse, Entity::RectangularCompositeSurface)(s),
            "RECTANGULAR_PATTERN" => map(RectangularPattern_::parse, Entity::RectangularPattern)(s),
            "RECTANGULAR_TRIMMED_SURFACE" => map(RectangularTrimmedSurface_::parse, Entity::RectangularTrimmedSurface)(s),
            "REFERENCED_MODIFIED_DATUM" => map(ReferencedModifiedDatum_::parse, Entity::ReferencedModifiedDatum)(s),
            "RELATIVE_EVENT_OCCURRENCE" => map(RelativeEventOccurrence_::parse, Entity::RelativeEventOccurrence)(s),
            "REP_ITEM_GROUP" => map(RepItemGroup_::parse, Entity::RepItemGroup)(s),
            "REPARAMETRISED_COMPOSITE_CURVE_SEGMENT" => map(ReparametrisedCompositeCurveSegment_::parse, Entity::ReparametrisedCompositeCurveSegment)(s),
            "REPLICATE_FEATURE" => map(ReplicateFeature_::parse, Entity::ReplicateFeature)(s),
            "REPRESENTATION" => map(Representation_::parse, Entity::Representation)(s),
            "REPRESENTATION_CONTEXT" => map(RepresentationContext_::parse, Entity::RepresentationContext)(s),
            "REPRESENTATION_ITEM" => map(RepresentationItem_::parse, Entity::RepresentationItem)(s),
            "REPRESENTATION_MAP" => map(RepresentationMap_::parse, Entity::RepresentationMap)(s),
            "REPRESENTATION_RELATIONSHIP" => map(RepresentationRelationship_::parse, Entity::RepresentationRelationship)(s),
            "REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION" => map(RepresentationRelationshipWithTransformation_::parse, Entity::RepresentationRelationshipWithTransformation)(s),
            "REQUIREMENT_FOR_ACTION_RESOURCE" => map(RequirementForActionResource_::parse, Entity::RequirementForActionResource)(s),
            "RESOURCE_PROPERTY" => map(ResourceProperty_::parse, Entity::ResourceProperty)(s),
            "RESOURCE_PROPERTY_REPRESENTATION" => map(ResourcePropertyRepresentation_::parse, Entity::ResourcePropertyRepresentation)(s),
            "RESOURCE_REQUIREMENT_TYPE" => map(ResourceRequirementType_::parse, Entity::ResourceRequirementType)(s),
            "RESULTING_PATH" => map(ResultingPath_::parse, Entity::ResultingPath)(s),
            "RETENTION" => map(Retention_::parse, Entity::Retention)(s),
            "REVOLUTE_PAIR" => map(RevolutePair_::parse, Entity::RevolutePair)(s),
            "REVOLUTE_PAIR_RANGE" => map(RevolutePairRange_::parse, Entity::RevolutePairRange)(s),
            "REVOLUTE_PAIR_VALUE" => map(RevolutePairValue_::parse, Entity::RevolutePairValue)(s),
            "REVOLVED_AREA_SOLID" => map(RevolvedAreaSolid_::parse, Entity::RevolvedAreaSolid)(s),
            "REVOLVED_FACE_SOLID" => map(RevolvedFaceSolid_::parse, Entity::RevolvedFaceSolid)(s),
            "RIB" => map(Rib_::parse, Entity::Rib)(s),
            "RIGHT_ANGULAR_WEDGE" => map(RightAngularWedge_::parse, Entity::RightAngularWedge)(s),
            "RIGHT_CIRCULAR_CONE" => map(RightCircularCone_::parse, Entity::RightCircularCone)(s),
            "RIGHT_CIRCULAR_CYLINDER" => map(RightCircularCylinder_::parse, Entity::RightCircularCylinder)(s),
            "ROLE_ASSOCIATION" => map(RoleAssociation_::parse, Entity::RoleAssociation)(s),
            "ROLLING_CURVE_PAIR" => map(RollingCurvePair_::parse, Entity::RollingCurvePair)(s),
            "ROLLING_CURVE_PAIR_VALUE" => map(RollingCurvePairValue_::parse, Entity::RollingCurvePairValue)(s),
            "ROLLING_SURFACE_PAIR" => map(RollingSurfacePair_::parse, Entity::RollingSurfacePair)(s),
            "ROLLING_SURFACE_PAIR_VALUE" => map(RollingSurfacePairValue_::parse, Entity::RollingSurfacePairValue)(s),
            "ROTATION_ABOUT_DIRECTION" => map(RotationAboutDirection_::parse, Entity::RotationAboutDirection)(s),
            "ROUND_HOLE" => map(RoundHole_::parse, Entity::RoundHole)(s),
            "ROUNDED_U_PROFILE" => map(RoundedUProfile_::parse, Entity::RoundedUProfile)(s),
            "ROUNDNESS_TOLERANCE" => map(RoundnessTolerance_::parse, Entity::RoundnessTolerance)(s),
            "RULED_SURFACE_SWEPT_AREA_SOLID" => map(RuledSurfaceSweptAreaSolid_::parse, Entity::RuledSurfaceSweptAreaSolid)(s),
            "RUNOUT_ZONE_DEFINITION" => map(RunoutZoneDefinition_::parse, Entity::RunoutZoneDefinition)(s),
            "RUNOUT_ZONE_ORIENTATION" => map(RunoutZoneOrientation_::parse, Entity::RunoutZoneOrientation)(s),
            "RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION" => map(RunoutZoneOrientationReferenceDirection_::parse, Entity::RunoutZoneOrientationReferenceDirection)(s),
            "SCREW_PAIR" => map(ScrewPair_::parse, Entity::ScrewPair)(s),
            "SCREW_PAIR_RANGE" => map(ScrewPairRange_::parse, Entity::ScrewPairRange)(s),
            "SCREW_PAIR_VALUE" => map(ScrewPairValue_::parse, Entity::ScrewPairValue)(s),
            "SEAM_CURVE" => map(SeamCurve_::parse, Entity::SeamCurve)(s),
            "SEAM_EDGE" => map(SeamEdge_::parse, Entity::SeamEdge)(s),
            "SECURITY_CLASSIFICATION" => map(SecurityClassification_::parse, Entity::SecurityClassification)(s),
            "SECURITY_CLASSIFICATION_ASSIGNMENT" => map(SecurityClassificationAssignment_::parse, Entity::SecurityClassificationAssignment)(s),
            "SECURITY_CLASSIFICATION_LEVEL" => map(SecurityClassificationLevel_::parse, Entity::SecurityClassificationLevel)(s),
            "SERIAL_NUMBERED_EFFECTIVITY" => map(SerialNumberedEffectivity_::parse, Entity::SerialNumberedEffectivity)(s),
            "SHAPE_ASPECT" => map(ShapeAspect_::parse, Entity::ShapeAspect)(s),
            "SHAPE_ASPECT_ASSOCIATIVITY" => map(ShapeAspectAssociativity_::parse, Entity::ShapeAspectAssociativity)(s),
            "SHAPE_ASPECT_DERIVING_RELATIONSHIP" => map(ShapeAspectDerivingRelationship_::parse, Entity::ShapeAspectDerivingRelationship)(s),
            "SHAPE_ASPECT_RELATIONSHIP" => map(ShapeAspectRelationship_::parse, Entity::ShapeAspectRelationship)(s),
            "SHAPE_ASPECT_TRANSITION" => map(ShapeAspectTransition_::parse, Entity::ShapeAspectTransition)(s),
            "SHAPE_DEFINING_RELATIONSHIP" => map(ShapeDefiningRelationship_::parse, Entity::ShapeDefiningRelationship)(s),
            "SHAPE_DEFINITION_REPRESENTATION" => map(ShapeDefinitionRepresentation_::parse, Entity::ShapeDefinitionRepresentation)(s),
            "SHAPE_DIMENSION_REPRESENTATION" => map(ShapeDimensionRepresentation_::parse, Entity::ShapeDimensionRepresentation)(s),
            "SHAPE_REPRESENTATION" => map(ShapeRepresentation_::parse, Entity::ShapeRepresentation)(s),
            "SHAPE_REPRESENTATION_RELATIONSHIP" => map(ShapeRepresentationRelationship_::parse, Entity::ShapeRepresentationRelationship)(s),
            "SHAPE_REPRESENTATION_WITH_PARAMETERS" => map(ShapeRepresentationWithParameters_::parse, Entity::ShapeRepresentationWithParameters)(s),
            "SHELL_BASED_SURFACE_MODEL" => map(ShellBasedSurfaceModel_::parse, Entity::ShellBasedSurfaceModel)(s),
            "SI_UNIT" => map(SiUnit_::parse, Entity::SiUnit)(s),
            "SIMPLE_BOOLEAN_EXPRESSION" => map(SimpleBooleanExpression_::parse, Entity::SimpleBooleanExpression)(s),
            "SIMPLE_GENERIC_EXPRESSION" => map(SimpleGenericExpression_::parse, Entity::SimpleGenericExpression)(s),
            "SIMPLE_NUMERIC_EXPRESSION" => map(SimpleNumericExpression_::parse, Entity::SimpleNumericExpression)(s),
            "SIMPLE_PAIR_RANGE" => map(SimplePairRange_::parse, Entity::SimplePairRange)(s),
            "SIMPLE_STRING_EXPRESSION" => map(SimpleStringExpression_::parse, Entity::SimpleStringExpression)(s),
            "SIN_FUNCTION" => map(SinFunction_::parse, Entity::SinFunction)(s),
            "SLASH_EXPRESSION" => map(SlashExpression_::parse, Entity::SlashExpression)(s),
            "SLIDING_CURVE_PAIR" => map(SlidingCurvePair_::parse, Entity::SlidingCurvePair)(s),
            "SLIDING_CURVE_PAIR_VALUE" => map(SlidingCurvePairValue_::parse, Entity::SlidingCurvePairValue)(s),
            "SLIDING_SURFACE_PAIR" => map(SlidingSurfacePair_::parse, Entity::SlidingSurfacePair)(s),
            "SLIDING_SURFACE_PAIR_VALUE" => map(SlidingSurfacePairValue_::parse, Entity::SlidingSurfacePairValue)(s),
            "SLOT" => map(Slot_::parse, Entity::Slot)(s),
            "SLOT_END" => map(SlotEnd_::parse, Entity::SlotEnd)(s),
            "SOLID_ANGLE_MEASURE_WITH_UNIT" => map(SolidAngleMeasureWithUnit_::parse, Entity::SolidAngleMeasureWithUnit)(s),
            "SOLID_ANGLE_UNIT" => map(SolidAngleUnit_::parse, Entity::SolidAngleUnit)(s),
            "SOLID_MODEL" => map(SolidModel_::parse, Entity::SolidModel)(s),
            "SOLID_REPLICA" => map(SolidReplica_::parse, Entity::SolidReplica)(s),
            "SPECIFIED_HIGHER_USAGE_OCCURRENCE" => map(SpecifiedHigherUsageOccurrence_::parse, Entity::SpecifiedHigherUsageOccurrence)(s),
            "SPHERE" => map(Sphere_::parse, Entity::Sphere)(s),
            "SPHERICAL_PAIR" => map(SphericalPair_::parse, Entity::SphericalPair)(s),
            "SPHERICAL_PAIR_RANGE" => map(SphericalPairRange_::parse, Entity::SphericalPairRange)(s),
            "SPHERICAL_PAIR_VALUE" => map(SphericalPairValue_::parse, Entity::SphericalPairValue)(s),
            "SPHERICAL_SURFACE" => map(SphericalSurface_::parse, Entity::SphericalSurface)(s),
            "SQL_MAPPABLE_DEFINED_FUNCTION" => map(SqlMappableDefinedFunction_::parse, Entity::SqlMappableDefinedFunction)(s),
            "SQUARE_ROOT_FUNCTION" => map(SquareRootFunction_::parse, Entity::SquareRootFunction)(s),
            "SQUARE_U_PROFILE" => map(SquareUProfile_::parse, Entity::SquareUProfile)(s),
            "STANDARD_UNCERTAINTY" => map(StandardUncertainty_::parse, Entity::StandardUncertainty)(s),
            "STRAIGHTNESS_TOLERANCE" => map(StraightnessTolerance_::parse, Entity::StraightnessTolerance)(s),
            "STRING_DEFINED_FUNCTION" => map(StringDefinedFunction_::parse, Entity::StringDefinedFunction)(s),
            "STRING_EXPRESSION" => map(StringExpression_::parse, Entity::StringExpression)(s),
            "STRING_LITERAL" => map(StringLiteral_::parse, Entity::StringLiteral)(s),
            "STRING_VARIABLE" => map(StringVariable_::parse, Entity::StringVariable)(s),
            "STRUCTURED_DIMENSION_CALLOUT" => map(StructuredDimensionCallout_::parse, Entity::StructuredDimensionCallout)(s),
            "STYLED_ITEM" => map(StyledItem_::parse, Entity::StyledItem)(s),
            "SUBEDGE" => map(Subedge_::parse, Entity::Subedge)(s),
            "SUBFACE" => map(Subface_::parse, Entity::Subface)(s),
            "SUBSTRING_EXPRESSION" => map(SubstringExpression_::parse, Entity::SubstringExpression)(s),
            "SURFACE" => map(Surface_::parse, Entity::Surface)(s),
            "SURFACE_CONDITION_CALLOUT" => map(SurfaceConditionCallout_::parse, Entity::SurfaceConditionCallout)(s),
            "SURFACE_CURVE" => map(SurfaceCurve_::parse, Entity::SurfaceCurve)(s),
            "SURFACE_CURVE_SWEPT_AREA_SOLID" => map(SurfaceCurveSweptAreaSolid_::parse, Entity::SurfaceCurveSweptAreaSolid)(s),
            "SURFACE_OF_LINEAR_EXTRUSION" => map(SurfaceOfLinearExtrusion_::parse, Entity::SurfaceOfLinearExtrusion)(s),
            "SURFACE_OF_REVOLUTION" => map(SurfaceOfRevolution_::parse, Entity::SurfaceOfRevolution)(s),
            "SURFACE_PAIR" => map(SurfacePair_::parse, Entity::SurfacePair)(s),
            "SURFACE_PAIR_RANGE" => map(SurfacePairRange_::parse, Entity::SurfacePairRange)(s),
            "SURFACE_PATCH" => map(SurfacePatch_::parse, Entity::SurfacePatch)(s),
            "SURFACE_PROFILE_TOLERANCE" => map(SurfaceProfileTolerance_::parse, Entity::SurfaceProfileTolerance)(s),
            "SURFACE_RENDERING_PROPERTIES" => map(SurfaceRenderingProperties_::parse, Entity::SurfaceRenderingProperties)(s),
            "SURFACE_REPLICA" => map(SurfaceReplica_::parse, Entity::SurfaceReplica)(s),
            "SURFACE_SIDE_STYLE" => map(SurfaceSideStyle_::parse, Entity::SurfaceSideStyle)(s),
            "SURFACE_STYLE_BOUNDARY" => map(SurfaceStyleBoundary_::parse, Entity::SurfaceStyleBoundary)(s),
            "SURFACE_STYLE_CONTROL_GRID" => map(SurfaceStyleControlGrid_::parse, Entity::SurfaceStyleControlGrid)(s),
            "SURFACE_STYLE_FILL_AREA" => map(SurfaceStyleFillArea_::parse, Entity::SurfaceStyleFillArea)(s),
            "SURFACE_STYLE_PARAMETER_LINE" => map(SurfaceStyleParameterLine_::parse, Entity::SurfaceStyleParameterLine)(s),
            "SURFACE_STYLE_REFLECTANCE_AMBIENT" => map(SurfaceStyleReflectanceAmbient_::parse, Entity::SurfaceStyleReflectanceAmbient)(s),
            "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE" => map(SurfaceStyleReflectanceAmbientDiffuse_::parse, Entity::SurfaceStyleReflectanceAmbientDiffuse)(s),
            "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE_SPECULAR" => map(SurfaceStyleReflectanceAmbientDiffuseSpecular_::parse, Entity::SurfaceStyleReflectanceAmbientDiffuseSpecular)(s),
            "SURFACE_STYLE_RENDERING" => map(SurfaceStyleRendering_::parse, Entity::SurfaceStyleRendering)(s),
            "SURFACE_STYLE_RENDERING_WITH_PROPERTIES" => map(SurfaceStyleRenderingWithProperties_::parse, Entity::SurfaceStyleRenderingWithProperties)(s),
            "SURFACE_STYLE_SEGMENTATION_CURVE" => map(SurfaceStyleSegmentationCurve_::parse, Entity::SurfaceStyleSegmentationCurve)(s),
            "SURFACE_STYLE_SILHOUETTE" => map(SurfaceStyleSilhouette_::parse, Entity::SurfaceStyleSilhouette)(s),
            "SURFACE_STYLE_TRANSPARENT" => map(SurfaceStyleTransparent_::parse, Entity::SurfaceStyleTransparent)(s),
            "SURFACE_STYLE_USAGE" => map(SurfaceStyleUsage_::parse, Entity::SurfaceStyleUsage)(s),
            "SURFACE_TEXTURE_REPRESENTATION" => map(SurfaceTextureRepresentation_::parse, Entity::SurfaceTextureRepresentation)(s),
            "SWEPT_AREA_SOLID" => map(SweptAreaSolid_::parse, Entity::SweptAreaSolid)(s),
            "SWEPT_DISK_SOLID" => map(SweptDiskSolid_::parse, Entity::SweptDiskSolid)(s),
            "SWEPT_FACE_SOLID" => map(SweptFaceSolid_::parse, Entity::SweptFaceSolid)(s),
            "SWEPT_SURFACE" => map(SweptSurface_::parse, Entity::SweptSurface)(s),
            "SYMBOL_COLOUR" => map(SymbolColour_::parse, Entity::SymbolColour)(s),
            "SYMBOL_REPRESENTATION" => map(SymbolRepresentation_::parse, Entity::SymbolRepresentation)(s),
            "SYMBOL_REPRESENTATION_MAP" => map(SymbolRepresentationMap_::parse, Entity::SymbolRepresentationMap)(s),
            "SYMBOL_STYLE" => map(SymbolStyle_::parse, Entity::SymbolStyle)(s),
            "SYMBOL_TARGET" => map(SymbolTarget_::parse, Entity::SymbolTarget)(s),
            "SYMMETRIC_SHAPE_ASPECT" => map(SymmetricShapeAspect_::parse, Entity::SymmetricShapeAspect)(s),
            "SYMMETRY_TOLERANCE" => map(SymmetryTolerance_::parse, Entity::SymmetryTolerance)(s),
            "TACTILE_APPEARANCE_REPRESENTATION" => map(TactileAppearanceRepresentation_::parse, Entity::TactileAppearanceRepresentation)(s),
            "TAN_FUNCTION" => map(TanFunction_::parse, Entity::TanFunction)(s),
            "TANGENT" => map(Tangent_::parse, Entity::Tangent)(s),
            "TAPER" => map(Taper_::parse, Entity::Taper)(s),
            "TEE_PROFILE" => map(TeeProfile_::parse, Entity::TeeProfile)(s),
            "TERMINATOR_SYMBOL" => map(TerminatorSymbol_::parse, Entity::TerminatorSymbol)(s),
            "TEXT_LITERAL" => map(TextLiteral_::parse, Entity::TextLiteral)(s),
            "TEXT_LITERAL_WITH_ASSOCIATED_CURVES" => map(TextLiteralWithAssociatedCurves_::parse, Entity::TextLiteralWithAssociatedCurves)(s),
            "TEXT_LITERAL_WITH_BLANKING_BOX" => map(TextLiteralWithBlankingBox_::parse, Entity::TextLiteralWithBlankingBox)(s),
            "TEXT_LITERAL_WITH_DELINEATION" => map(TextLiteralWithDelineation_::parse, Entity::TextLiteralWithDelineation)(s),
            "TEXT_LITERAL_WITH_EXTENT" => map(TextLiteralWithExtent_::parse, Entity::TextLiteralWithExtent)(s),
            "TEXT_STRING_REPRESENTATION" => map(TextStringRepresentation_::parse, Entity::TextStringRepresentation)(s),
            "TEXT_STYLE" => map(TextStyle_::parse, Entity::TextStyle)(s),
            "TEXT_STYLE_FOR_DEFINED_FONT" => map(TextStyleForDefinedFont_::parse, Entity::TextStyleForDefinedFont)(s),
            "TEXT_STYLE_WITH_BOX_CHARACTERISTICS" => map(TextStyleWithBoxCharacteristics_::parse, Entity::TextStyleWithBoxCharacteristics)(s),
            "TEXT_STYLE_WITH_MIRROR" => map(TextStyleWithMirror_::parse, Entity::TextStyleWithMirror)(s),
            "TEXT_STYLE_WITH_SPACING" => map(TextStyleWithSpacing_::parse, Entity::TextStyleWithSpacing)(s),
            "THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT" => map(ThermodynamicTemperatureMeasureWithUnit_::parse, Entity::ThermodynamicTemperatureMeasureWithUnit)(s),
            "THERMODYNAMIC_TEMPERATURE_UNIT" => map(ThermodynamicTemperatureUnit_::parse, Entity::ThermodynamicTemperatureUnit)(s),
            "THREAD" => map(Thread_::parse, Entity::Thread)(s),
            "TIME_INTERVAL" => map(TimeInterval_::parse, Entity::TimeInterval)(s),
            "TIME_INTERVAL_ASSIGNMENT" => map(TimeIntervalAssignment_::parse, Entity::TimeIntervalAssignment)(s),
            "TIME_INTERVAL_BASED_EFFECTIVITY" => map(TimeIntervalBasedEffectivity_::parse, Entity::TimeIntervalBasedEffectivity)(s),
            "TIME_INTERVAL_ROLE" => map(TimeIntervalRole_::parse, Entity::TimeIntervalRole)(s),
            "TIME_INTERVAL_WITH_BOUNDS" => map(TimeIntervalWithBounds_::parse, Entity::TimeIntervalWithBounds)(s),
            "TIME_MEASURE_WITH_UNIT" => map(TimeMeasureWithUnit_::parse, Entity::TimeMeasureWithUnit)(s),
            "TIME_UNIT" => map(TimeUnit_::parse, Entity::TimeUnit)(s),
            "TOLERANCE_VALUE" => map(ToleranceValue_::parse, Entity::ToleranceValue)(s),
            "TOLERANCE_ZONE" => map(ToleranceZone_::parse, Entity::ToleranceZone)(s),
            "TOLERANCE_ZONE_DEFINITION" => map(ToleranceZoneDefinition_::parse, Entity::ToleranceZoneDefinition)(s),
            "TOLERANCE_ZONE_FORM" => map(ToleranceZoneForm_::parse, Entity::ToleranceZoneForm)(s),
            "TOPOLOGICAL_REPRESENTATION_ITEM" => map(TopologicalRepresentationItem_::parse, Entity::TopologicalRepresentationItem)(s),
            "TOROIDAL_SURFACE" => map(ToroidalSurface_::parse, Entity::ToroidalSurface)(s),
            "TORUS" => map(Torus_::parse, Entity::Torus)(s),
            "TOTAL_RUNOUT_TOLERANCE" => map(TotalRunoutTolerance_::parse, Entity::TotalRunoutTolerance)(s),
            "TRANSITION_FEATURE" => map(TransitionFeature_::parse, Entity::TransitionFeature)(s),
            "TRIMMED_CURVE" => map(TrimmedCurve_::parse, Entity::TrimmedCurve)(s),
            "TWO_DIRECTION_REPEAT_FACTOR" => map(TwoDirectionRepeatFactor_::parse, Entity::TwoDirectionRepeatFactor)(s),
            "TYPE_QUALIFIER" => map(TypeQualifier_::parse, Entity::TypeQualifier)(s),
            "UNARY_BOOLEAN_EXPRESSION" => map(UnaryBooleanExpression_::parse, Entity::UnaryBooleanExpression)(s),
            "UNARY_FUNCTION_CALL" => map(UnaryFunctionCall_::parse, Entity::UnaryFunctionCall)(s),
            "UNARY_GENERIC_EXPRESSION" => map(UnaryGenericExpression_::parse, Entity::UnaryGenericExpression)(s),
            "UNARY_NUMERIC_EXPRESSION" => map(UnaryNumericExpression_::parse, Entity::UnaryNumericExpression)(s),
            "UNCERTAINTY_ASSIGNED_REPRESENTATION" => map(UncertaintyAssignedRepresentation_::parse, Entity::UncertaintyAssignedRepresentation)(s),
            "UNCERTAINTY_MEASURE_WITH_UNIT" => map(UncertaintyMeasureWithUnit_::parse, Entity::UncertaintyMeasureWithUnit)(s),
            "UNCERTAINTY_QUALIFIER" => map(UncertaintyQualifier_::parse, Entity::UncertaintyQualifier)(s),
            "UNCONSTRAINED_PAIR" => map(UnconstrainedPair_::parse, Entity::UnconstrainedPair)(s),
            "UNCONSTRAINED_PAIR_VALUE" => map(UnconstrainedPairValue_::parse, Entity::UnconstrainedPairValue)(s),
            "UNIFORM_CURVE" => map(UniformCurve_::parse, Entity::UniformCurve)(s),
            "UNIFORM_SURFACE" => map(UniformSurface_::parse, Entity::UniformSurface)(s),
            "UNIVERSAL_PAIR" => map(UniversalPair_::parse, Entity::UniversalPair)(s),
            "UNIVERSAL_PAIR_RANGE" => map(UniversalPairRange_::parse, Entity::UniversalPairRange)(s),
            "UNIVERSAL_PAIR_VALUE" => map(UniversalPairValue_::parse, Entity::UniversalPairValue)(s),
            "VALUE_FUNCTION" => map(ValueFunction_::parse, Entity::ValueFunction)(s),
            "VALUE_RANGE" => map(ValueRange_::parse, Entity::ValueRange)(s),
            "VALUE_REPRESENTATION_ITEM" => map(ValueRepresentationItem_::parse, Entity::ValueRepresentationItem)(s),
            "VARIABLE" => map(Variable_::parse, Entity::Variable)(s),
            "VARIABLE_SEMANTICS" => map(VariableSemantics_::parse, Entity::VariableSemantics)(s),
            "VECTOR" => map(Vector_::parse, Entity::Vector)(s),
            "VECTOR_STYLE" => map(VectorStyle_::parse, Entity::VectorStyle)(s),
            "VEE_PROFILE" => map(VeeProfile_::parse, Entity::VeeProfile)(s),
            "VERSIONED_ACTION_REQUEST" => map(VersionedActionRequest_::parse, Entity::VersionedActionRequest)(s),
            "VERSIONED_ACTION_REQUEST_RELATIONSHIP" => map(VersionedActionRequestRelationship_::parse, Entity::VersionedActionRequestRelationship)(s),
            "VERTEX" => map(Vertex_::parse, Entity::Vertex)(s),
            "VERTEX_LOOP" => map(VertexLoop_::parse, Entity::VertexLoop)(s),
            "VERTEX_POINT" => map(VertexPoint_::parse, Entity::VertexPoint)(s),
            "VIEW_VOLUME" => map(ViewVolume_::parse, Entity::ViewVolume)(s),
            "VISUAL_APPEARANCE_REPRESENTATION" => map(VisualAppearanceRepresentation_::parse, Entity::VisualAppearanceRepresentation)(s),
            "VOLUME_MEASURE_WITH_UNIT" => map(VolumeMeasureWithUnit_::parse, Entity::VolumeMeasureWithUnit)(s),
            "VOLUME_UNIT" => map(VolumeUnit_::parse, Entity::VolumeUnit)(s),
            "XOR_EXPRESSION" => map(XorExpression_::parse, Entity::XorExpression)(s),
            "" => parse_complex_mapping(s),
            _ => panic!("Invalid case"),
        }
    }
}
